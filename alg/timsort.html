<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Timsort Lab — Stable, Hybrid Sort Visualizer</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Alpine.js -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <!-- Chart.js (optional mini charts) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root { color-scheme: light; }
    html { scroll-behavior: smooth; }
    .bg-hero {
      background: linear-gradient(120deg, #eef2ff, #f0fdf4, #ecfeff);
      background-size: 200% 200%;
      animation: grad 18s ease infinite;
    }
    @keyframes grad { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .fade-in { animation: fade .25s ease-in; }
    @keyframes fade { from {opacity:.2} to {opacity:1} }
    .bar { transition: transform .15s ease, background-color .15s ease; }
    .bar.highlight { outline: 2px solid #7c3aed; box-shadow: 0 0 0 2px rgba(124,58,237,.25) inset; }
  </style>
</head>

<body class="min-h-screen text-slate-800">
  <!-- Header / Hero -->
  <header class="bg-hero">
    <div class="max-w-7xl mx-auto px-6 py-12 lg:py-16">
      <div class="flex flex-col lg:flex-row items-center gap-10">
        <div class="flex-1">
          <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900">
            Timsort <span class="text-indigo-600">Lab</span>
          </h1>
          <p class="mt-3 text-lg md:text-xl text-slate-700">
            Interactive, single‑file site to <span class="font-semibold">detect runs</span>,
            <span class="font-semibold">binary‑insert</span> short runs up to <span class="font-semibold">minrun</span>, and
            <span class="font-semibold">merge with galloping</span> while enforcing the stack invariants — exactly how Python’s sort works.
          </p>
          <div class="mt-5 flex flex-wrap gap-3">
            <a href="#sim" class="px-5 py-3 rounded-xl bg-indigo-600 text-white font-semibold shadow hover:bg-indigo-700">Open Simulator</a>
            <a href="#guide" class="px-5 py-3 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50">Read the Illustrated Guide</a>
          </div>
          <p class="mt-4 text-sm text-slate-500">Stable hybrid of run detection + insertion sort + merge sort (with galloping).</p>
        </div>
        <div class="flex-1 w-full">
          <div class="bg-white/70 backdrop-blur rounded-2xl p-6 shadow border border-slate-100">
            <canvas id="lenChart" height="220"></canvas>
            <p class="mt-3 text-center text-sm text-slate-600">Run‑length distribution updates as the array changes.</p>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Simulator -->
  <section id="sim" class="py-12" x-data="timsortLab()" x-init="init()">
    <div class="max-w-7xl mx-auto px-6">
      <div class="mb-6 flex items-center justify-between gap-4 flex-wrap">
        <div>
          <h2 class="text-3xl font-bold tracking-tight text-slate-900">Interactive Simulator</h2>
          <p class="text-slate-600 mt-1">Generate data, step through the algorithm, and watch <span class="font-semibold">runs</span>, <span class="font-semibold">stack invariants</span>, and <span class="font-semibold">galloping</span>.</p>
        </div>
        <div class="flex items-center gap-2 text-sm">
          <label class="text-slate-600">N</label>
          <input type="number" min="8" step="1" class="w-20 rounded-lg border-slate-300" x-model.number="N">
          <label class="text-slate-600 ml-2">Range</label>
          <input type="number" min="5" step="5" class="w-24 rounded-lg border-slate-300" x-model.number="rangeMax">
          <label class="text-slate-600 ml-2">Nearly‑sorted</label>
          <input type="range" min="0" max="100" step="5" x-model.number="nearly" class="w-32">
          <label class="text-slate-600 ml-2">Reversed</label>
          <input type="checkbox" x-model="reversed">
          <button class="ml-2 px-3 py-1.5 rounded-lg bg-slate-800 text-white" @click="regen()">Regenerate</button>
        </div>
      </div>

      <!-- Controls -->
      <div class="grid lg:grid-cols-5 gap-6">
        <div class="lg:col-span-2">
          <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
            <h3 class="font-semibold text-slate-800">Controls</h3>
            <div class="mt-3 flex flex-wrap gap-2">
              <button class="px-3 py-1.5 rounded-lg bg-indigo-600 text-white" @click="resetAlgo()">Prepare</button>
              <button class="px-3 py-1.5 rounded-lg bg-emerald-600 text-white" @click="step()">Step</button>
              <button class="px-3 py-1.5 rounded-lg bg-emerald-700 text-white" @click="play()">Play</button>
              <button class="px-3 py-1.5 rounded-lg bg-slate-700 text-white" @click="pause()">Pause</button>
              <button class="px-3 py-1.5 rounded-lg bg-amber-600 text-white" @click="finish()">Finish</button>
            </div>
            <div class="mt-3 flex items-center gap-2 text-sm">
              <label class="text-slate-600">Speed</label>
              <input type="range" min="20" max="800" step="20" class="w-40" x-model.number="speed">
              <span class="text-slate-500">(<span x-text="speed"></span> ms)</span>
            </div>
            <div class="mt-4 text-xs text-slate-600">
              <p><span class="font-semibold">minrun</span> is computed as in CPython: collapse high bits of n until it fits \[32, 64), then leftover bits decide the final value.</p>
              <p class="mt-1">Short runs (len &lt; minrun) are extended via <span class="font-semibold">binary insertion sort</span>.</p>
              <p class="mt-1">Merge stack invariants ensure <span class="font-semibold">balanced merges</span>, triggering merges whenever violated.</p>
              <p class="mt-1">Galloping switches from 1‑by‑1 comparisons to <span class="font-semibold">exponential jumps</span> once a side wins repeatedly.</p>
            </div>
          </div>

          <div class="mt-6 bg-white rounded-2xl shadow p-5 border border-slate-200">
            <h3 class="font-semibold text-slate-800">Metrics</h3>
            <div class="mt-3 grid grid-cols-2 gap-3 text-sm">
              <div>
                <div class="text-xs text-slate-500">minrun</div>
                <div class="text-xl font-semibold" x-text="state.minrun"></div>
              </div>
              <div>
                <div class="text-xs text-slate-500">Comparisons</div>
                <div class="text-xl font-semibold" x-text="metrics.cmps"></div>
              </div>
              <div>
                <div class="text-xs text-slate-500">Moves</div>
                <div class="text-xl font-semibold" x-text="metrics.moves"></div>
              </div>
              <div>
                <div class="text-xs text-slate-500">Merges</div>
                <div class="text-xl font-semibold" x-text="metrics.merges"></div>
              </div>
              <div>
                <div class="text-xs text-slate-500">Gallops</div>
                <div class="text-xl font-semibold" x-text="metrics.gallops"></div>
              </div>
              <div>
                <div class="text-xs text-slate-500">Runs on stack</div>
                <div class="text-xl font-semibold" x-text="state.stack.length"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Visualization + Log -->
        <div class="lg:col-span-3">
          <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
            <div class="flex items-center justify-between">
              <h3 class="font-semibold text-slate-800">Array</h3>
              <div class="text-sm text-slate-600 flex gap-4">
                <span>n: <span class="font-mono" x-text="A.length"></span></span>
                <span>phase: <span class="font-mono" x-text="state.phase"></span></span>
                <span>i: <span class="font-mono" x-text="state.i"></span></span>
              </div>
            </div>

            <!-- Bars -->
            <div class="mt-3 border rounded-xl p-3 overflow-x-auto">
              <div class="flex items-end gap-1 min-w-full">
                <template x-for="(v, idx) in A" :key="idx">
                  <div class="bar rounded-md w-6 sm:w-7 md:w-8" :style="barStyle(v, idx)" :class="barClass(idx)">
                    <div class="text-[10px] text-center mt-1 select-none" x-text="v"></div>
                  </div>
                </template>
              </div>
            </div>

            <!-- Runs on stack -->
            <div class="mt-4">
              <h4 class="font-semibold text-slate-800">Run stack (base..top)</h4>
              <div class="mt-2 flex flex-wrap gap-2">
                <template x-for="(r, k) in state.stack" :key="k">
                  <span class="px-2 py-1 rounded-lg text-xs font-mono"
                        :style="`background:${r.color}22;border:1px solid ${r.color}55`">
                    [<span x-text="r.lo"></span>..<span x-text="r.lo + r.len - 1"></span>] len=<span x-text="r.len"></span>
                  </span>
                </template>
                <template x-if="!state.stack.length"><span class="text-sm text-slate-500">(empty)</span></template>
              </div>
            </div>

            <!-- Log -->
            <div class="mt-4">
              <h4 class="font-semibold text-slate-800">Operation Log</h4>
              <div id="logBox" class="mt-2 h-40 overflow-auto rounded-lg border border-slate-200 bg-slate-50 p-3 text-[12px] code">
                <template x-for="(line, i) in log" :key="i">
                  <div class="mb-0.5"><span class="text-slate-400">#</span> <span x-text="line"></span></div>
                </template>
              </div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </section>

  <!-- Guide -->
  <section id="guide" class="py-12 bg-slate-50">
    <div class="max-w-7xl mx-auto px-6">
      <div class="mb-8">
        <h2 class="text-3xl font-bold tracking-tight text-slate-900">Illustrated Guide</h2>
        <p class="mt-2 text-slate-600">Timsort = natural <span class="font-semibold">run detection</span> + <span class="font-semibold">insertion sort</span> for short runs + <span class="font-semibold">merge sort</span> with <span class="font-semibold">galloping</span>, guarded by invariants.</p>
      </div>
      <div class="grid lg:grid-cols-3 gap-6">
        <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
          <h3 class="text-xl font-semibold">1) Detect runs & compute minrun</h3>
          <p class="mt-2 text-sm leading-7 text-slate-700">
            Scan left→right to find monotone runs. If a run is strictly decreasing, reverse it to make it increasing (stability is preserved).
            Compute <span class="font-mono">minrun</span> from <span class="font-mono">n</span> so most runs are at least 32…64 long.
          </p>
        </article>
        <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
          <h3 class="text-xl font-semibold">2) Extend short runs by binary insertion</h3>
          <p class="mt-2 text-sm leading-7 text-slate-700">
            If <span class="font-mono">len(run) &lt; minrun</span>, extend it using binary insertion sort.
            This keeps the overall work small on nearly‑sorted data, a common real‑world case.
          </p>
        </article>
        <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
          <h3 class="text-xl font-semibold">3) Merge with invariants + galloping</h3>
          <p class="mt-2 text-sm leading-7 text-slate-700">
            Maintain a stack of runs with length invariants to avoid very unbalanced merges. When violated, merge the appropriate runs.
            During merging, if one side wins repeatedly, switch to <em>galloping</em> (exponential then binary search) to skip ahead.
          </p>
        </article>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="py-10 bg-slate-900 text-slate-200">
    <div class="max-w-7xl mx-auto px-6">
      <div class="flex flex-col md:flex-row items-center justify-between gap-4">
        <p class="text-sm">© <span id="year"></span> Timsort Lab — Single‑file, no build.</p>
        <div class="text-xs text-slate-400">Tailwind • Alpine.js • Chart.js</div>
      </div>
    </div>
  </footer>

  <!-- Logic -->
  <script>
  // ------------------------- Utilities -------------------------
  const COLORS = ["#ef4444","#f59e0b","#10b981","#3b82f6","#8b5cf6","#ec4899","#14b8a6","#f97316","#22c55e","#06b6d4"]; // looped
  function colorFor(k){ return COLORS[k % COLORS.length]; }
  function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

  function computeMinrun(n){
    // CPython timsort logic (simplified but equivalent)
    let r = 0;
    while (n >= 64) { r |= n & 1; n >>= 1; }
    return n + r; // in [32,64]
  }

  function binarySearch(arr, lo, hi, x, cmps){
    // find first index >= x in arr[lo..hi)
    while (lo < hi){
      const mid = (lo + hi) >>> 1; cmps.c++;
      if (arr[mid] < x) lo = mid + 1; else hi = mid;
    }
    return lo;
  }

  function gallop(arr, start, length, key, dir, cmps){
    // Exponential then binary locate boundary where condition flips.
    // dir: 1 to find first > key; -1 to find first >= key when scanning backward.
    let ofs = 1, last = 0;
    if (dir > 0){
      while (ofs < length && (cmps.c++, arr[start + ofs] <= key)) { last = ofs; ofs = (ofs<<1) + 1; }
      if (ofs > length) ofs = length;
      // now key in (last .. ofs]
      const base = start + last + 1;
      const end = start + ofs + 1;
      let lo = base, hi = end; // find first > key
      while (lo < hi){ const mid = (lo+hi)>>>1; cmps.c++; if (arr[mid-1] <= key) lo = mid; else hi = mid; }
      return lo - start; // offset into [start..start+length]
    } else {
      // backward variant (not fully needed here). Keep simple:
      let idx = start + length - 1;
      while (idx >= start && (cmps.c++, arr[idx] > key)) idx--;
      return idx - start + 1;
    }
  }

  // ------------------------- Timsort core (step-able) -------------------------
  function timsortEngine(A){
    const n = A.length;
    const minrun = computeMinrun(n);
    const state = {
      phase: 'scan',
      i: 0,
      minrun,
      stack: [], // runs: {lo,len,color}
      merging: null, // {a:{lo,len}, b:{lo,len}, i:0, j:0, buf:[], outLo}
      gallopWins: 0,
    };
    const metrics = { cmps:0, moves:0, merges:0, gallops:0 };

    // helper: push run and enforce invariants
    function pushRun(lo, len){
      state.stack.push({lo, len, color: colorFor(state.stack.length)});
    }

    function top(k){ return state.stack[state.stack.length-1-k]; }

    function invariantViolated(){
      // Classic timsort invariants (simplified):
      // A: length of second-last, B: last, C: third-last (on stack base..top)
      if (state.stack.length < 2) return false;
      const n = state.stack.length;
      const X = state.stack[n-1];
      const Y = state.stack[n-2];
      const Z = n>=3 ? state.stack[n-3] : null;
      if (Z && Z.len <= Y.len + X.len) return true;
      if (Y.len <= X.len) return true;
      return false;
    }

    function mergeAt(pos){
      // merge stack[pos-1] with stack[pos]
      const left = state.stack[pos-1];
      const right = state.stack[pos];
      const a = A.slice(left.lo, left.lo+left.len); // copies for clarity
      const b = A.slice(right.lo, right.lo+right.len);
      metrics.moves += a.length + b.length; // buffer copies (teaching metric)
      const outLo = left.lo;
      let i=0, j=0, out=outLo;
      let winCount = 0; // for galloping

      // merge loop with simple galloping trigger (threshold=7)
      while (i < a.length && j < b.length){
        // try gallop from the side that is winning repeatedly
        if (winCount >= 7){
          // determine which side is winning
          const aWinning = (metrics.cmps++, a[i] <= b[j]);
          if (aWinning){
            const adv = gallop(a, i, a.length - i, b[j], 1, {c:metrics.cmps});
            for (let t=0; t<adv; t++) { A[out++] = a[i++]; metrics.moves++; }
          } else {
            const adv = gallop(b, j, b.length - j, a[i], 1, {c:metrics.cmps});
            for (let t=0; t<adv; t++) { A[out++] = b[j++]; metrics.moves++; }
          }
          metrics.gallops++; winCount = 0; // reset after gallop
          continue;
        }
        if (metrics.cmps++, a[i] <= b[j]) { A[out++] = a[i++]; metrics.moves++; winCount++; }
        else { A[out++] = b[j++]; metrics.moves++; winCount = 0; }
      }
      while (i < a.length) { A[out++] = a[i++]; metrics.moves++; }
      while (j < b.length) { A[out++] = b[j++]; metrics.moves++; }

      // fix stack: replace left with merged, remove right
      const mergedLen = left.len + right.len;
      state.stack.splice(pos-1, 2, {lo: outLo, len: mergedLen, color: left.color});
      metrics.merges++;
    }

    function enforceInvariants(){
      // keep merging while violated; prefer merging the smaller of the two topmost runs
      while (invariantViolated()){
        const n = state.stack.length;
        if (n >= 3){
          const X = state.stack[n-1], Y = state.stack[n-2], Z = state.stack[n-3];
          if (Z.len < X.len) mergeAt(n-2); else mergeAt(n-1);
        } else {
          mergeAt(n-1);
        }
      }
    }

    // public step: returns description string
    function step(){
      if (state.phase === 'done') return {done:true, msg:'done'};

      if (state.phase === 'scan'){
        if (state.i >= n) { state.phase = 'merge'; return {msg:'switch to merge'}; }
        // detect next run starting at i
        let lo = state.i;
        let hi = lo + 1;
        if (hi === n){ // single element run
          pushRun(lo, 1); state.i = hi; return {msg:`run [${lo}..${hi-1}] len=1`};
        }
        // decide direction
        if (A[hi] < A[lo]){ // descending
          while (hi < n && A[hi] < A[hi-1]) hi++;
          // reverse to make it ascending (stable for equal keys)
          const len = hi - lo;
          for (let L=0, R=len-1; L < R; L++, R--){ const tmp=A[lo+L]; A[lo+L]=A[lo+R]; A[lo+R]=tmp; metrics.moves+=2; }
          pushRun(lo, len);
          state.i = hi;
          return {msg:`found descending run, reversed → [${lo}..${hi-1}] len=${len}`};
        } else { // non-decreasing
          while (hi < n && A[hi] >= A[hi-1]) hi++;
          let len = hi - lo;
          // grow to minrun using binary insertion sort
          if (len < minrun){
            const target = Math.min(n, lo + minrun);
            while (hi < target){
              const x = A[hi];
              // find position in A[lo..hi)
              const pos = binarySearch(A, lo, hi, x, metrics); // first >= x
              // move [pos..hi) right by 1
              for (let k=hi; k>pos; k--){ A[k]=A[k-1]; metrics.moves++; }
              A[pos]=x; metrics.moves++;
              hi++;
            }
            len = hi - lo;
            pushRun(lo, len);
            state.i = hi;
            return {msg:`extended short run to minrun → [${lo}..${hi-1}] len=${len}`};
          } else {
            pushRun(lo, len);
            state.i = hi;
            return {msg:`run [${lo}..${hi-1}] len=${len}`};
          }
        }
      }

      if (state.phase === 'merge'){
        if (state.stack.length <= 1){ state.phase = 'done'; return {done:true, msg:'sorted'}; }
        // enforce invariants & merge
        const before = state.stack.map(r=>r.len).join(',');
        enforceInvariants();
        const after = state.stack.map(r=>r.len).join(',');
        return {msg:`merge step: stack ${before} → ${after}`};
      }

      return {msg:'noop'};
    }

    return { state, metrics, step, A };
  }

  // ------------------------- Alpine component -------------------------
  function timsortLab(){
    return {
      // data
      N: 40,
      rangeMax: 99,
      nearly: 0, // 0..100
      reversed: false,
      speed: 160,
      A: [],
      engine: null,
      state: { minrun: 0, i: 0, phase: 'idle', stack: [] },
      metrics: { cmps:0, moves:0, merges:0, gallops:0 },
      log: [],
      chart: null,
      player: null,

      init(){
        this.regen();
        this.initChart();
        this.$nextTick(()=>this._autoScroll());
      },

      regen(){
        // base ascending array to support "nearly-sorted"
        const base = Array.from({length:this.N}, (_,i)=>randInt(0, this.rangeMax));
        base.sort((a,b)=>a-b);
        // introduce perturbations proportional to nearly% and reversed flag
        const swaps = Math.floor(this.N * (this.nearly/100));
        for (let s=0; s<swaps; s++){
          const i = randInt(0,this.N-1), j = randInt(0,this.N-1);
          const t = base[i]; base[i]=base[j]; base[j]=t;
        }
        if (this.reversed) base.reverse();
        this.A = base;
        this.resetAlgo();
        this.updateChart();
        this.log.push(`regen: n=${this.N}, nearly=${this.nearly}%, reversed=${this.reversed}`);
        this.$nextTick(()=>this._autoScroll());
      },

      resetAlgo(){
        this.engine = timsortEngine(this.A);
        this.state = this.engine.state;
        this.metrics = this.engine.metrics;
        this.state.phase = 'scan';
        this.state.i = 0;
        this.log.push(`prepare: minrun=${this.state.minrun}`);
        this.$nextTick(()=>this._autoScroll());
      },

      step(){
        if (!this.engine) return;
        const { msg, done } = this.engine.step();
        this.log.push(msg);
        this.updateChart();
        if (done) this.pause();
        this.$nextTick(()=>this._autoScroll());
      },

      play(){
        this.pause();
        this.player = setInterval(()=>this.step(), this.speed);
      },

      pause(){ if (this.player){ clearInterval(this.player); this.player=null; } },

      finish(){
        this.pause();
        while (this.state.phase !== 'done'){ this.engine.step(); }
        this.log.push('finish: sorted');
        this.updateChart();
        this.$nextTick(()=>this._autoScroll());
      },

      // --- visuals ---
      barStyle(v, idx){
        const max = Math.max(1, ...this.A);
        const h = Math.max(10, Math.round((v/max)*120)+10);
        // color by current run membership (approx: top run if covers idx)
        let color = '#cbd5e1';
        for (const r of this.state.stack){
          if (idx >= r.lo && idx < r.lo + r.len){ color = r.color; break; }
        }
        return `height:${h}px;background:${color}55`;
      },
      barClass(idx){
        // highlight scanning boundary
        if (this.state.phase==='scan' && idx===this.state.i) return 'highlight';
        return '';
      },

      // --- charts ---
      initChart(){
        const ctx = document.getElementById('lenChart');
        this.chart = new Chart(ctx, {
          type: 'bar',
          data: { labels: [], datasets: [{ label: 'len', data: [] }] },
          options: { responsive:true, aspectRatio: 2.2, plugins:{legend:{display:false}}, scales:{x:{title:{display:true,text:'run #'}}, y:{beginAtZero:true}} }
        });
        this.updateChart();
      },
      updateChart(){
        const lens = this.state.stack.map(r=>r.len);
        this.chart.data.labels = lens.map((_,i)=>String(i));
        this.chart.data.datasets[0].data = lens;
        this.chart.update();
      },

      // --- log ---
      _autoScroll(){ const box=document.getElementById('logBox'); if(box) box.scrollTop = box.scrollHeight; }
    }
  }

  // Footer year
  document.addEventListener('DOMContentLoaded', () => {
    const y = document.getElementById('year');
    if (y) y.textContent = new Date().getFullYear();
  });
  </script>
</body>
</html>
