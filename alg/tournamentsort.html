<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tournament Sort — Interactive Visualizer (Vanilla JS + Tailwind)</title>
  <!-- TailwindCSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .node { transition: transform 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease; }
    .node:hover { transform: translateY(-1px); }
    .tree-edge { stroke: #cbd5e1; stroke-width: 1.2; }
  </style>
</head>
<body class="min-h-screen w-full bg-gradient-to-br from-indigo-50 via-sky-50 to-emerald-50 text-slate-800">
  <div class="mx-auto max-w-6xl px-5 py-8">
    <header>
      <h1 class="text-3xl md:text-4xl font-extrabold tracking-tight text-slate-900">Tournament Sort — Interactive Visualizer</h1>
      <p class="mt-2 text-slate-600 max-w-5xl">
        Build a <b>min-tournament tree</b> over the array. The root is the global minimum.
        Remove it (set the winning leaf to ∞), then update only the path to the root. Repeat to obtain a sorted prefix.
      </p>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-3 gap-6 pb-16 mt-6">

      <!-- Right: Tree -->
      <section class="lg:col-span-3 flex flex-col gap-4">
        <div class="rounded-3xl border border-slate-200 bg-white p-5 shadow-sm">
          <h3 class="text-lg font-semibold">Tournament Tree</h3>
          <p class="mt-2 text-sm text-slate-600">
            Internal nodes store the min of their two children. Root is the global min.
          </p>
          <div id="tree" class="mt-3 relative w-full min-h-[380px] bg-slate-50 border border-slate-200 rounded-2xl overflow-hidden p-3"></div>
          <div class="mt-3 text-xs text-slate-600">
            <span class="font-medium text-amber-700">Amber</span>: compared this step ·
            <span class="font-medium text-cyan-700">Cyan</span>: current winner path ·
            <span class="font-medium text-emerald-700">Emerald</span>: leaves already removed (∞)
          </div>
        </div>

    </section>

      <!-- Left: Visualization -->
      <section class="lg:col-span-4 flex flex-col gap-4">
        <div class="rounded-3xl border border-slate-200 bg-white p-4 shadow-sm">
          <div class="flex flex-wrap items-center gap-2 mb-3">
            <button id="btnPlay" class="px-3 py-2 rounded-xl shadow-sm border bg-white hover:bg-slate-50 text-sm font-medium">Play</button>
            <button id="btnStep" class="px-3 py-2 rounded-xl shadow-sm border bg-white hover:bg-slate-50 text-sm">Step</button>
            <button id="btnReset" class="px-3 py-2 rounded-xl shadow-sm border bg-white hover:bg-slate-50 text-sm">Reset</button>
            <button id="btnShuffle" class="px-3 py-2 rounded-xl shadow-sm border bg-white hover:bg-slate-50 text-sm">Shuffle</button>

            <div class="ml-auto flex items-center gap-3">
              <label class="text-sm text-slate-600">Speed</label>
              <input id="rangeSpeed" type="range" min="50" max="1500" value="400" class="w-40">
              <label class="text-sm text-slate-600">Size</label>
              <input id="rangeSize" type="range" min="6" max="64" value="20" class="w-40">
            </div>
          </div>

          <div id="bars" class="relative w-full h-64 md:h-72 lg:h-80 flex items-end gap-1 p-2 rounded-2xl bg-gradient-to-b from-white to-slate-100 border border-slate-200"></div>

          <div class="mt-4 grid grid-cols-3 gap-3">
            <div class="flex flex-col items-center justify-center rounded-2xl bg-white/60 backdrop-blur p-3 shadow-sm">
              <div class="text-xs uppercase tracking-wide text-slate-500">Comparisons</div>
              <div id="statComparisons" class="text-xl font-semibold tabular-nums text-slate-900">0</div>
            </div>
            <div class="flex flex-col items-center justify-center rounded-2xl bg-white/60 backdrop-blur p-3 shadow-sm">
              <div class="text-xs uppercase tracking-wide text-slate-500">Swaps</div>
              <div id="statSwaps" class="text-xl font-semibold tabular-nums text-slate-900">0</div>
            </div>
            <div class="flex flex-col items-center justify-center rounded-2xl bg-white/60 backdrop-blur p-3 shadow-sm">
              <div class="text-xs uppercase tracking-wide text-slate-500">Array Size</div>
              <div id="statSize" class="text-xl font-semibold tabular-nums text-slate-900">20</div>
            </div>
          </div>
        </div>

        <div class="rounded-3xl border border-slate-200 bg-white p-4 shadow-sm">
          <h3 class="text-lg font-semibold mb-2">Pseudocode (Min-Tournament, In-place Prefix)</h3>
          <pre id="pseudocode" class="rounded-2xl p-4 bg-slate-900 text-slate-100 text-sm leading-6 overflow-auto"><code>
<span data-line="1"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">01</span>L ← next power of two ≥ n</span>
<span data-line="2"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">02</span>Put A[0..n−1] at leaves L..L+n−1; fill rest with +∞</span>
<span data-line="3"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">03</span>Build: for i = L−1 .. 1: node[i] ← min(node[2i], node[2i+1])</span>
<span data-line="4"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">04</span>for k = 0 .. n−1:</span>
<span data-line="5"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">05</span>  leaf* ← winner leaf for root</span>
<span data-line="6"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">06</span>  pos ← array index represented by leaf*</span>
<span data-line="7"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">07</span>  swap A[k] ↔ A[pos] (to grow sorted prefix)</span>
<span data-line="8"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">08</span>  set leaf for k to +∞; update path k→root</span>
<span data-line="9"  class="block px-2 rounded-md"><span class="text-slate-400 mr-3 select-none">09</span>  if pos ≠ k: set leaf for pos to old A[k]; update path pos→root</span>
          </code></pre>
        </div>

                <div class="rounded-3xl border border-slate-200 bg-white p-5 shadow-sm">
          <h3 class="text-lg font-semibold">Remarks</h3>
          <ul class="mt-2 list-disc pl-5 text-sm text-slate-700 space-y-1">
            <li>Build once in <span class="font-mono">O(L)</span>; each extraction updates only the changed path(s) in <span class="font-mono">O(log L)</span>.</li>
            <li>We display a sorted <em>prefix</em> by swapping the winner into position <span class="font-mono">k</span>.</li>
            <li>Padding leaves are set to <span class="font-mono">∞</span> (ignored).</li>
          </ul>
        </div>
      </section>

    </main>

    <footer class="text-center text-xs text-slate-500 pb-4">Built for learning. Use sliders to explore behavior.</footer>
  </div>

  <script>
    // ---------- Utilities ----------
    function rngArray(n, min = 5, max = 100) {
      return Array.from({ length: n }, () => Math.floor(min + Math.random() * (max - min + 1)));
    }
    const INF = Number.POSITIVE_INFINITY;
    function nextPow2(x){ let p=1; while(p < x) p <<= 1; return p; }

    // ---------- Tournament Sort (step generator) ----------
    // We use a 1-based tree array of size 2*L: leaves at [L .. 2L-1]
    // Mappings:
    //  - leafOfPos[pos] -> leaf index for this array position
    //  - posOfLeaf[leaf] -> which array position this leaf represents (-1 for padding)
    function* tournamentSortSteps(original) {
      const arr = [...original];
      const n = arr.length;
      const L = nextPow2(n);
      const N = 2 * L; // 1..(2L-1) used
      const tree = new Array(N).fill(INF);
      const winLeaf = new Array(N).fill(-1); // winner leaf index per node
      const posOfLeaf = new Array(N).fill(-1);
      const leafOfPos = new Array(n).fill(-1);

      // --- Put A at leaves; fill the rest with INF
      for (let k = 0; k < L; k++) {
        const leaf = L + k;
        if (k < n) {
          tree[leaf] = arr[k];
          posOfLeaf[leaf] = k;
          leafOfPos[k] = leaf;
        } else {
          tree[leaf] = INF;
          posOfLeaf[leaf] = -1;
        }
        yield {
          phase: 'init-leaf',
          tree: [...tree],
          posOfLeaf: [...posOfLeaf],
          leafOfPos: [...leafOfPos],
          highlight: { leaves: [leaf], compare: [], path: [], root: null },
          array: [...arr],
          info: { L, n }
        };
      }

      // --- Build tree bottom-up
      for (let i = L - 1; i >= 1; i--) {
        const lc = 2 * i, rc = lc + 1;
        // show comparison
        yield {
          phase: 'build-compare',
          tree: [...tree],
          posOfLeaf: [...posOfLeaf],
          leafOfPos: [...leafOfPos],
          highlight: { leaves: [], compare: [lc, rc], path: [], root: i },
          array: [...arr],
          info: { L, n }
        };
        // choose winner (stable to left on tie)
        if (tree[lc] <= tree[rc]) {
          tree[i] = tree[lc];
          winLeaf[i] = (lc >= L) ? lc : winLeaf[lc];
        } else {
          tree[i] = tree[rc];
          winLeaf[i] = (rc >= L) ? rc : winLeaf[rc];
        }
        // propagate leaf winners upward for children if not set
        if (lc < L && winLeaf[lc] === -1) {
          // child internal: set from its children
          // (we may leave it lazy; not needed for correctness)
        }
        if (rc < L && winLeaf[rc] === -1) {}

        // if current is leaf, winLeaf[i] must be its leaf
        if (i >= L) winLeaf[i] = i;

        yield {
          phase: 'build-assign',
          tree: [...tree],
          posOfLeaf: [...posOfLeaf],
          leafOfPos: [...leafOfPos],
          highlight: { leaves: [], compare: [], path: [i], root: i },
          array: [...arr],
          info: { L, n }
        };
      }

      // After build, ensure every internal node has a correct winner leaf
      function computeWinner(i){
        if (i >= L) return i;
        const lc = 2*i, rc = lc+1;
        const wl = computeWinner(lc);
        const wr = computeWinner(rc);
        winLeaf[lc] = wl; winLeaf[rc] = wr;
        const vl = tree[lc], vr = tree[rc];
        if (vl <= vr) { winLeaf[i] = wl; return wl; }
        else { winLeaf[i] = wr; return wr; }
      }
      computeWinner(1);

      // --- Helper: update along path of a single leaf to root
      function* updatePathFromLeaf(leaf, arrView, compareColor = true) {
        let i = Math.floor(leaf / 2);
        const touched = [leaf];
        while (i >= 1) {
          const lc = 2 * i, rc = lc + 1;
          // comparison at this internal node
          yield {
            phase: 'update-compare',
            tree: [...tree],
            posOfLeaf: [...posOfLeaf],
            leafOfPos: [...leafOfPos],
            highlight: { leaves: [], compare: [lc, rc], path: [i], root: 1 },
            array: [...arrView],
            info: { L, n }
          };
          if (tree[lc] <= tree[rc]) {
            tree[i] = tree[lc];
            winLeaf[i] = (lc >= L) ? lc : winLeaf[lc];
          } else {
            tree[i] = tree[rc];
            winLeaf[i] = (rc >= L) ? rc : winLeaf[rc];
          }
          touched.push(i);
          i = Math.floor(i / 2);
        }
        // final highlight at root
        yield {
          phase: 'update-assign',
          tree: [...tree],
          posOfLeaf: [...posOfLeaf],
          leafOfPos: [...leafOfPos],
          highlight: { leaves: [], compare: [], path: touched, root: 1 },
          array: [...arrView],
          info: { L, n }
        };
      }

      // --- Extraction rounds: grow a sorted prefix in arr
      for (let k = 0; k < n; k++) {
        const leafWin = winLeaf[1]; // winner leaf for the root
        const posMin = posOfLeaf[leafWin];
        const minVal = tree[1];

        // show the selection at root and the leaf position
        yield {
          phase: 'select-min',
          tree: [...tree],
          posOfLeaf: [...posOfLeaf],
          leafOfPos: [...leafOfPos],
          highlight: { leaves: [leafWin], compare: [], path: [1], root: 1 },
          array: [...arr],
          info: { L, n, k, posMin, minVal }
        };

        // If min is already at position k, no swap; otherwise swap to grow prefix
        let swapHappened = false;
        let posOther = k;
        if (posMin !== k) {
          const tmp = arr[k];
          arr[k] = arr[posMin];
          arr[posMin] = tmp;
          swapHappened = true;
          posOther = posMin;

          yield {
            phase: 'swap-prefix',
            tree: [...tree],
            posOfLeaf: [...posOfLeaf],
            leafOfPos: [...leafOfPos],
            highlight: { leaves: [leafWin], compare: [], path: [1], root: 1 },
            array: [...arr],
            info: { L, n, k, posMin }
          };
        }

        // We must reflect swaps in the tournament leaves:
        // - leaf for position k is now the min and should be removed => set to INF
        // - if a swap happened, the leaf for posMin must get the old A[k] value (already in arr[posMin])
        const leafK = leafOfPos[k];
        tree[leafK] = INF;
        posOfLeaf[leafK] = -1;

        // update path for leafK (removed)
        yield* updatePathFromLeaf(leafK, arr);

        if (swapHappened) {
          const leafPosMin = leafOfPos[posMin];
          // its value changed to the old A[k] (now at arr[posMin]) — refresh leaf value
          tree[leafPosMin] = arr[posMin];
          yield* updatePathFromLeaf(leafPosMin, arr);
        }

        // one round done
        yield {
          phase: 'round-end',
          tree: [...tree],
          posOfLeaf: [...posOfLeaf],
          leafOfPos: [...leafOfPos],
          highlight: { leaves: [], compare: [], path: [], root: 1 },
          array: [...arr],
          info: { L, n, kDone: k }
        };
      }

      yield {
        phase: 'done',
        tree: [...tree],
        posOfLeaf: [...posOfLeaf],
        leafOfPos: [...leafOfPos],
        highlight: { leaves: [], compare: [], path: [], root: null },
        array: [...arr],
        info: { L, n }
      };
    }

    // ---------- State ----------
    const barsEl = document.getElementById('bars');
    const treeEl = document.getElementById('tree');
    const statComparisons = document.getElementById('statComparisons');
    const statSwaps = document.getElementById('statSwaps');
    const statSize = document.getElementById('statSize');
    const btnPlay = document.getElementById('btnPlay');
    const btnStep = document.getElementById('btnStep');
    const btnReset = document.getElementById('btnReset');
    const btnShuffle = document.getElementById('btnShuffle');
    const rangeSpeed = document.getElementById('rangeSpeed');
    const rangeSize = document.getElementById('rangeSize');
    const PSEUDO = document.getElementById('pseudocode');

    let arr = rngArray(parseInt(rangeSize.value, 10));
    let steps = Array.from(tournamentSortSteps(arr));
    let stepIdx = 0;
    let running = false;

    let sortedHead = 0;     // prefix length
    let comparisons = 0;
    let swaps = 0;
    let timer = null;

    function maxVal(a){ return a.length ? Math.max(...a) : 1; }

    // ---------- Rendering: Bars ----------
    function renderBars(snapshot, highlightPhase) {
      const M = maxVal(snapshot);
      barsEl.innerHTML = '';
      snapshot.forEach((v, idx) => {
        const h = Math.max(4, (v / M) * 100);
        let cls = 'bg-slate-400';
        if (idx < sortedHead) cls = 'bg-emerald-400';
        if (highlightPhase === 'swap') {
          // flash ends of prefix
          if (idx === sortedHead || idx === sortedHead - 1) cls = 'bg-rose-400';
        }
        const d = document.createElement('div');
        d.className = `w-full max-w-[18px] flex-1 rounded-t-lg transition-all duration-300 ease-out ${cls}`;
        d.style.height = h + '%';
        d.title = `A[${idx}] = ${v}`;
        barsEl.appendChild(d);
      });
    }

    // ---------- Rendering: Tree ----------
    function renderTree(s) {
      const { tree, highlight, info } = s;
      const { L } = info;
      treeEl.innerHTML = '';
      const W = treeEl.clientWidth || 520;
      const H = 360;

      // Build levels: level 0 = root (index 1), ... , level h = leaves
      const levels = [];
      const height = Math.log2(L) + 1; // internal levels + leaf level
      for (let lvl = 0; lvl < height; lvl++) {
        levels.push([]);
      }
      // Fill internal nodes (1..L-1)
      for (let i = 1; i < L; i++) {
        const lvl = Math.floor(Math.log2(i));
        levels[lvl].push(i);
      }
      // Leaves (L..2L-1)
      const leafLevel = height - 1;
      for (let i = L; i <= 2*L - 1; i++) levels[leafLevel].push(i);

      // Precompute positions
      const positions = {};
      const vGap = H / (height + 0.5);
      levels.forEach((nodes, lvl) => {
        const count = nodes.length;
        const hGap = W / (count + 1);
        nodes.forEach((nodeIdx, j) => {
          const x = (j + 1) * hGap;
          const y = (lvl + 0.5) * vGap;
          positions[nodeIdx] = { x, y };
        });
      });

      // SVG for edges
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', H);
      // Draw edges
      for (let i = 1; i < L; i++) {
        const lc = 2*i, rc = lc+1;
        const p = positions[i], cl = positions[lc], cr = positions[rc];
        if (cl) {
          const line = document.createElementNS(svgNS, 'line');
          line.setAttribute('x1', p.x); line.setAttribute('y1', p.y);
          line.setAttribute('x2', cl.x); line.setAttribute('y2', cl.y);
          line.setAttribute('class', 'tree-edge');
          svg.appendChild(line);
        }
        if (cr) {
          const line = document.createElementNS(svgNS, 'line');
          line.setAttribute('x1', p.x); line.setAttribute('y1', p.y);
          line.setAttribute('x2', cr.x); line.setAttribute('y2', cr.y);
          line.setAttribute('class', 'tree-edge');
          svg.appendChild(line);
        }
      }
      treeEl.appendChild(svg);

      // Draw nodes
      function nodeClass(i) {
        const value = tree[i];
        const isLeafRemoved = (i >= L && (value === INF || !isFinite(value)));
        let cls = 'bg-white border border-slate-300 text-slate-700';
        if (isLeafRemoved) cls = 'bg-emerald-100 border-emerald-300 text-emerald-700';
        if (highlight.compare && highlight.compare.includes(i)) cls = 'bg-amber-100 border-amber-300 text-amber-800';
        if (highlight.path && highlight.path.includes(i)) cls = 'bg-cyan-100 border-cyan-300 text-cyan-800';
        if (highlight.leaves && highlight.leaves.includes(i)) cls = 'bg-cyan-100 border-cyan-300 text-cyan-800';
        if (highlight.root === i) cls = 'ring-2 ring-cyan-400';
        return cls;
      }

      Object.keys(positions).forEach(k => {
        const i = Number(k);
        const { x, y } = positions[i];
        const val = tree[i];
        const wrap = document.createElement('div');
        wrap.className = `node absolute px-2 py-1 rounded-xl text-xs shadow-sm ${nodeClass(i)}`;
        wrap.style.left = `${x - 16}px`;
        wrap.style.top  = `${y - 10}px`;
        wrap.textContent = (val === INF) ? '∞' : String(val);
        treeEl.appendChild(wrap);
      });
    }

    // ---------- Pseudocode highlight ----------
    function setPseudoHighlight(line){
      PSEUDO.querySelectorAll('[data-line]').forEach(x => {
        x.classList.remove('bg-emerald-700/30');
        x.querySelectorAll('span').forEach(s => s.classList.remove('text-emerald-300'));
      });
      if (line > 0){
        const el = PSEUDO.querySelector(`[data-line="${line}"]`);
        if (el){
          el.classList.add('bg-emerald-700/30');
          const spans = el.querySelectorAll('span');
          if (spans.length) spans[spans.length-1].classList.add('text-emerald-300');
        }
      }
    }

    // ---------- Orchestration ----------
    function resetState(newArr){
      arr = [...newArr];
      steps = Array.from(tournamentSortSteps(arr));
      stepIdx = 0; running = false;
      sortedHead = 0; swaps = 0; comparisons = 0;
      statComparisons.textContent = '0';
      statSwaps.textContent = '0';
      statSize.textContent = String(arr.length);
      btnPlay.textContent = 'Play';
      clearInterval(timer); timer = null;
      setPseudoHighlight(0);
      // Render first snapshot (init-leaf step 0 if exists, else bars only)
      renderBars(arr, null);
      if (steps.length) renderTree(steps[0]);
    }

    function applyStep(s){
      // Stats & state evolution
      if (s.phase === 'build-compare' || s.phase === 'update-compare') {
        comparisons += 1; statComparisons.textContent = String(comparisons);
      }
      if (s.phase === 'swap-prefix') {
        swaps += 1; statSwaps.textContent = String(swaps);
      }
      if (s.phase === 'round-end') {
        sortedHead = (s.info.kDone + 1);
      }
      // Pseudocode hints
      const mapLine = {
        'init-leaf': 2,
        'build-compare': 3,
        'build-assign': 3,
        'select-min': 5,
        'swap-prefix': 7,
        'update-compare': 8,
        'update-assign': 8,
        'round-end': 4,
        'done': 0
      };
      setPseudoHighlight(mapLine[s.phase] || 0);

      // Render
      renderBars(s.array, s.phase === 'swap-prefix' ? 'swap' : null);
      renderTree(s);
    }

    function stepOnce(){
      if (stepIdx >= steps.length) return;
      const s = steps[stepIdx];
      applyStep(s);
      stepIdx += 1;
    }

    function playLoop(){
      clearInterval(timer);
      const delay = Math.max(
        30,
        Number(rangeSpeed.max) - Number(rangeSpeed.value) + Number(rangeSpeed.min)
      );
      timer = setInterval(() => {
        if (stepIdx >= steps.length){
          running = false; btnPlay.textContent = 'Play'; clearInterval(timer); timer=null; return;
        }
        stepOnce();
      }, delay);
    }

    // ---------- Events ----------
    btnPlay.addEventListener('click', () => {
      running = !running;
      btnPlay.textContent = running ? 'Pause' : 'Play';
      if (running) playLoop(); else { clearInterval(timer); timer = null; }
    });
    btnStep.addEventListener('click', () => { if (!running) stepOnce(); });
    btnReset.addEventListener('click', () => { resetState(arr); });
    btnShuffle.addEventListener('click', () => {
      const n = parseInt(rangeSize.value,10);
      resetState(rngArray(n));
    });
    rangeSize.addEventListener('input', () => {
      const n = parseInt(rangeSize.value,10);
      statSize.textContent = String(n);
    });
    rangeSize.addEventListener('change', () => {
      const n = parseInt(rangeSize.value,10);
      resetState(rngArray(n));
    });
    rangeSpeed.addEventListener('change', () => {
      if (running) playLoop();
    });

    // ---------- Init ----------
    resetState(arr);
  </script>
</body>
</html>
