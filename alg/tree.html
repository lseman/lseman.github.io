<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CART Regression & Ensembles Lab</title>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Alpine -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      chtml: {
        // disable MathJax linebreaking entirely
        linebreaks: { automatic: false },
        matchFontHeight: true
      },
      options: {
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      }
    };
  </script>
  <!-- Use CHTML instead of SVG -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <style>
        :root {
            color-scheme: light;
        }

        html {
            scroll-behavior: smooth;
        }

        .bg-hero {
            background: linear-gradient(120deg, #eef2ff, #f0fdf4, #ecfeff);
            background-size: 200% 200%;
            animation: grad 18s ease infinite;
        }

        @keyframes grad {
            0% {
                background-position: 0% 50%
            }

            50% {
                background-position: 100% 50%
            }

            100% {
                background-position: 0% 50%
            }
        }

        .code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .fade-in {
            animation: fade .25s ease-in;
        }

        @keyframes fade {
            from {
                opacity: .2
            }

            to {
                opacity: 1
            }
        }

        .node {
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, .08));
        }
    </style>
</head>

<body class="min-h-screen text-slate-800">

    <!-- Header -->
    <header class="bg-hero">
        <div class="max-w-7xl mx-auto px-6 py-12 lg:py-16">
            <div class="flex flex-col lg:flex-row items-center gap-10">
                <div class="flex-1">
                    <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900">
                        CART <span class="text-indigo-600">Regression</span> & Ensembles Lab
                    </h1>
                    <p class="mt-3 text-lg md:text-xl text-slate-700">
                        Build a <span class="font-semibold">CART regressor</span>, compare with
                        <span class="font-semibold">Bagging</span> (averager) and
                        <span class="font-semibold">Gradient Boosting</span> (residual chain).
                        Toggle classification to contrast impurity vs MSE logic.
                    </p>
                    <div class="mt-5 flex flex-wrap gap-3">
                        <a href="#sim"
                            class="px-5 py-3 rounded-xl bg-indigo-600 text-white font-semibold shadow hover:bg-indigo-700">Open
                            Simulator</a>
                        <a href="#guide"
                            class="px-5 py-3 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50">Illustrated
                            Guide</a>
                    </div>
                    <p class="mt-4 text-sm text-slate-500">Single file • Tailwind + Alpine + Chart.js • No build step
                    </p>
                </div>
                <div class="flex-1 w-full">
                    <div class="bg-white/70 backdrop-blur rounded-2xl p-6 shadow border border-slate-100">
                        <canvas id="featChart" height="220"></canvas>
                        <p class="mt-3 text-center text-sm text-slate-600">
                            Split gain (feature importance) across the trained model(s).
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </header>
    <!-- Simulator -->
    <section id="sim" class="py-12" x-data="lab()" x-init="init()">
        <div class="max-w-7xl mx-auto px-6">
            <!-- Header -->
            <div class="mb-6 flex items-center justify-between gap-4 flex-wrap">
                <div>
                    <h2 class="text-3xl font-bold tracking-tight text-slate-900">Interactive Simulator</h2>
                    <p class="text-slate-600 mt-1">2D problems for visualization; focus on regression, optional
                        classification.</p>
                </div>
                <div class="flex items-center gap-3 text-sm">
                    <span class="text-slate-600">MSE/R² or Acc update after training.</span>
                </div>
            </div>

            <!-- Top toolbar: all controls -->
            <div class="mb-6 bg-white rounded-2xl shadow p-5 border border-slate-200">
                <div class="grid sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
                    <!-- Task / Data size / Noise -->
                    <div class="flex flex-col">
                        <label class="text-sm text-slate-700">Task</label>
                        <select class="mt-1 rounded-xl border-slate-300" x-model="task">
                            <option value="reg">Regression</option>
                            <option value="clf">Classification</option>
                        </select>
                    </div>
                    <div class="flex flex-col">
                        <label class="text-sm text-slate-700">Samples</label>
                        <input type="number" min="60" step="10" class="mt-1 rounded-xl border-slate-300"
                            x-model.number="nSamples">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-sm text-slate-700">Noise</label>
                        <input type="number" step="0.02" min="0" max="0.6" class="mt-1 rounded-xl border-slate-300"
                            x-model.number="noise">
                    </div>

                    <!-- Dataset selector -->
                    <div class="flex flex-col">
                        <label class="text-sm text-slate-700">Dataset</label>
                        <select class="mt-1 rounded-xl border-slate-300" x-model="dataset">
                            <template x-if="task==='reg'">
                                <optgroup label="Regression">
                                    <option value="sine">Sine ridge (nonlinear)</option>
                                    <option value="plane">Plane (linear)</option>
                                    <option value="peaks">Humps (piecewise)</option>
                                    <option value="friedman2d">Friedman-like (2D)</option>
                                </optgroup>
                            </template>
                            <template x-if="task==='clf'">
                                <optgroup label="Classification">
                                    <option value="blobs">Blobs</option>
                                    <option value="moons">Two Moons</option>
                                    <option value="xor">XOR</option>
                                </optgroup>
                            </template>
                        </select>
                    </div>

                    <!-- Balance (clf) -->
                    <div class="flex flex-col">
                        <label class="text-sm text-slate-700">Balance (clf)</label>
                        <select class="mt-1 rounded-xl border-slate-300" x-model="balance">
                            <option value="balanced">Balanced</option>
                            <option value="skewed">Skewed</option>
                        </select>
                    </div>

                    <!-- Model mode -->
                    <div class="flex flex-col">
                        <label class="text-sm text-slate-700">Mode</label>
                        <select class="mt-1 rounded-xl border-slate-300" x-model="mode">
                            <option value="cart">Single CART</option>
                            <option value="bagging">Bagging / Random Forest-like</option>
                            <option value="gbdt">Gradient Boosting</option>
                        </select>
                    </div>

                    <!-- n_estimators when needed -->
                    <template x-if="mode!=='cart'">
                        <div class="flex flex-col">
                            <label class="text-sm text-slate-700">n_estimators</label>
                            <input type="number" min="1" step="1" class="mt-1 rounded-xl border-slate-300"
                                x-model.number="nEstimators">
                        </div>
                    </template>

                    <!-- Depth / Leaf -->
                    <div class="flex flex-col">
                        <label class="text-sm text-slate-700">max_depth</label>
                        <input type="number" min="1" max="20" step="1" class="mt-1 rounded-xl border-slate-300"
                            x-model.number="maxDepth">
                    </div>
                    <div class="flex flex-col">
                        <label class="text-sm text-slate-700">min_samples_leaf</label>
                        <input type="number" min="1" step="1" class="mt-1 rounded-xl border-slate-300"
                            x-model.number="minLeaf">
                    </div>

                    <!-- Bagging extras -->
                    <template x-if="mode==='bagging'">
                        <div class="flex flex-col">
                            <label class="text-sm text-slate-700">bootstrap rows</label>
                            <select class="mt-1 rounded-xl border-slate-300" x-model="bootstrapRows">
                                <option :value="true">true</option>
                                <option :value="false">false</option>
                            </select>
                        </div>
                    </template>
                    <template x-if="mode==='bagging'">
                        <div class="flex flex-col">
                            <label class="text-sm text-slate-700">max_features</label>
                            <select class="mt-1 rounded-xl border-slate-300" x-model="maxFeaturesMode">
                                <option value="all">all</option>
                                <option value="sqrt">sqrt</option>
                                <option value="half">half</option>
                            </select>
                        </div>
                    </template>

                    <!-- GBDT extras -->
                    <template x-if="mode==='gbdt'">
                        <div class="flex flex-col">
                            <label class="text-sm text-slate-700">learning_rate</label>
                            <input type="number" step="0.05" min="0.05" max="1" class="mt-1 rounded-xl border-slate-300"
                                x-model.number="learningRate">
                        </div>
                    </template>
                    <template x-if="mode==='gbdt'">
                        <div class="flex flex-col">
                            <label class="text-sm text-slate-700">subsample (rows)</label>
                            <input type="number" step="0.05" min="0.2" max="1" class="mt-1 rounded-xl border-slate-300"
                                x-model.number="subsample">
                        </div>
                    </template>
                </div>

                <!-- Toolbar actions -->
                <div class="mt-4 flex flex-wrap gap-2">
                    <button class="px-3 py-1.5 rounded-lg bg-indigo-600 text-white" @click="train()">Train</button>
                    <button class="px-3 py-1.5 rounded-lg bg-slate-200" @click="resetModel()">Clear Model</button>
                    <button class="px-3 py-1.5 rounded-lg bg-slate-800 text-white ml-auto"
                        @click="regenData()">Regenerate Data</button>
                </div>
            </div>

            <!-- Visualizations -->
            <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
                <div class="flex items-center justify-between flex-wrap gap-3">
                    <h3 class="font-semibold text-slate-800">Fit & Visualizations</h3>
                    <div class="text-sm text-slate-600 grid grid-flow-col gap-4">
                        <template x-if="task==='reg'">
span>MSE: <span class="font-mono" x-text="Number.isFinite(metrics.mse) ? metrics.mse.toFixed(4) : '—'"></span></span>                        </template>
                        <template x-if="task==='reg'">
                            <span>R²: <span class="font-mono" x-text="metrics.r2.toFixed(3)"></span></span>
                        </template>
                        <template x-if="task==='clf'">
                            <span>Acc: <span class="font-mono" x-text="(metrics.acc*100).toFixed(1)+'%'"></span></span>
                        </template>
                        <span>trees: <span class="font-mono" x-text="modelSummary.trees"></span></span>
                    </div>
                </div>

                <!-- Bigger canvases & tree -->
                <div class="mt-4 grid grid-cols-1 2xl:grid-cols-3 gap-6">
                    <!-- Decision surface / scatter -->
                    <div class="2xl:col-span-2">
                        <canvas id="dbCanvas" width="840" height="560"
                            class="w-full h-[520px] rounded-xl border border-slate-200"></canvas>
                        <div class="text-xs text-slate-500 mt-2">
                            Regression: color = predicted value (blue low → red high). Classification: blue vs green
                            regions.
                        </div>
                    </div>

                    <!-- Ensemble diagram -->
                    <div class="">
                        <h4 class="font-semibold text-slate-800">Ensemble Topology</h4>
                        <svg id="ensSvg" class="mt-2 w-full h-[520px] border rounded-xl border-slate-200 bg-white"
                            viewBox="0 0 900 560" preserveAspectRatio="xMidYMid meet"></svg>
                        <div class="text-xs text-slate-500 mt-2">
                            Bagging: parallel trees → <span class="font-semibold">averager</span>. Boosting: residuals →
                            next tree (gradient flow).
                        </div>
                    </div>

                    <!-- Tree viz (now spans full width on 2xl) -->
                    <div class="2xl:col-span-3">
                        <h4 class="font-semibold text-slate-800">Current CART (structure)</h4>
                        <svg id="treeSvg" class="mt-2 w-full h-[640px] border rounded-xl border-slate-200 bg-white"
                            viewBox="0 0 1400 900" preserveAspectRatio="xMidYMid meet"></svg>
                        <div class="text-xs text-slate-500 mt-2">
                            Internal node: <span class="font-mono">xj ≤ thr</span> (gain). Leaf: prediction (reg) /
                            proba (clf).
                        </div>
                    </div>
                </div>

                <!-- Log + stats -->
                <div class="mt-6 grid lg:grid-cols-2 gap-4">
                    <div>
                        <h4 class="font-semibold text-slate-800">Operation Log</h4>
                        <div id="logBox"
                            class="mt-2 h-48 overflow-auto rounded-lg border border-slate-200 bg-slate-50 p-3 text-[12px] code">
                            <template x-for="(line,i) in log" :key="i">
                                <div class="mb-0.5"><span class="text-slate-400">#</span> <span x-text="line"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                        <div class="bg-slate-50 rounded p-3 border">
                            <div class="text-slate-500 text-xs">Model summary</div>
                            <div class="font-mono mt-1 text-sm">
                                <div>max_depth=<span x-text="maxDepth"></span></div>
                                <div>min_leaf=<span x-text="minLeaf"></span></div>
                                <template x-if="mode!=='cart'">
                                    <div>n_estimators=<span x-text="nEstimators"></span></div>
                                </template>
                                <template x-if="mode==='gbdt'">
                                    <div>lr=<span x-text="learningRate"></span>, subsample=<span
                                            x-text="subsample"></span></div>
                                </template>
                            </div>
                        </div>
                        <div class="bg-slate-50 rounded p-3 border">
                            <div class="text-slate-500 text-xs">Tree stats</div>
                            <div class="font-mono mt-1 text-sm">
                                <div>Avg depth: <span x-text="modelSummary.avgDepth.toFixed(2)"></span></div>
                                <div>Avg leaves: <span x-text="modelSummary.avgLeaves.toFixed(1)"></span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- KPI cards -->
            <div class="mt-6 grid sm:grid-cols-2 lg:grid-cols-4 gap-4">
                <div class="bg-white rounded-2xl shadow p-4 border border-slate-200">
                    <div class="text-xs text-slate-500" x-text="task==='reg' ? 'MSE (train)' : 'Accuracy (train)'">
                    </div>
                    <div class="text-2xl font-semibold">
                        <span x-show="task==='reg'" x-text="metrics.mse.toFixed(4)"></span>
                    </div>
                </div>
                <div class="bg-white rounded-2xl shadow p-4 border border-slate-200">
                    <div class="text-xs text-slate-500">Trees</div>
                    <div class="text-2xl font-semibold" x-text="modelSummary.trees"></div>
                </div>
                <div class="bg-white rounded-2xl shadow p-4 border border-slate-200">
                    <div class="text-xs text-slate-500">Avg depth</div>
                    <div class="text-2xl font-semibold" x-text="modelSummary.avgDepth.toFixed(2)"></div>
                </div>
                <div class="bg-white rounded-2xl shadow p-4 border border-slate-200">
                    <div class="text-xs text-slate-500">Avg leaves</div>
                    <div class="text-2xl font-semibold" x-text="modelSummary.avgLeaves.toFixed(1)"></div>
                </div>
            </div>
        </div>
    </section>
<!-- Guide -->
<section id="guide" class="py-12 bg-slate-50">
  <div class="max-w-7xl mx-auto px-6">
    <div class="mb-8">
      <h2 class="text-3xl font-bold tracking-tight text-slate-900">Illustrated Guide</h2>
      <p class="mt-2 text-slate-600">
        Decision trees split the input space with rules like \(x_j \le t\).
        CART for regression minimizes MSE; for classification it reduces impurity (e.g., Gini).
        Bagging lowers variance by averaging many trees; gradient boosting lowers bias by chaining
        small trees on the residuals.
      </p>
    </div>

    <!-- Core recap -->
    <div class="grid lg:grid-cols-3 gap-6 mb-10">
      <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
        <h3 class="text-xl font-semibold">CART (Regression)</h3>
        <p class="mt-2 text-sm leading-7 text-slate-700">
          At each node, search axis-aligned splits \(x_j \le t\) that best reduce mean squared error:
\[
\begin{aligned}
\Delta \text{MSE} &= \text{MSE}(\text{parent}) \\
&\quad - \big[w_L \cdot \text{MSE}(L) + w_R \cdot \text{MSE}(R)\big].
\end{aligned}
\]

          Stop when limits hit (depth / min_leaf). Leaves predict the average \(y\) in the region.
        </p>
      </article>
      <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
        <h3 class="text-xl font-semibold">Bagging / Random Forest-like</h3>
        <p class="mt-2 text-sm leading-7 text-slate-700">
          Train many trees on bootstrapped rows and randomized feature subsets; average predictions.
          Parallel “voters” → robust to noise, strong variance reduction, little training-time coupling.
        </p>
      </article>
      <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
        <h3 class="text-xl font-semibold">Gradient Boosting (Squared Loss)</h3>
        <p class="mt-2 text-sm leading-7 text-slate-700">
          Maintain prediction \(F\). Residuals \(r = y - F\) (the negative gradient for MSE).
          Fit a small tree to \(r\), then update \(F \leftarrow F + \eta \cdot \text{tree}(x)\) with learning rate \(\eta\).
        </p>
      </article>
    </div>

    <!-- Advanced tree building: Exact vs Histogram -->
    <div class="grid lg:grid-cols-2 gap-6 mb-10">
      <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
        <h3 class="text-xl font-semibold">Exact vs. Histogram Trees</h3>
        <div class="mt-2 text-sm leading-7 text-slate-700 space-y-3">
          <div>
            <p class="font-semibold">Exact (Greedy) Split Finding</p>
            <ul class="list-disc ml-5">
              <li>Sort the feature values and scan every possible threshold \(t\).</li>
              <li>Accurate but costly: sorting &amp; scanning cost grows with samples × features.</li>
              <li>Great for small/medium data where precision matters.</li>
            </ul>
          </div>
          <div>
            <p class="font-semibold">Histogram-Based Split Finding</p>
            <ul class="list-disc ml-5">
              <li>Bin each feature value into \(B\) discrete buckets (e.g., 63/255).</li>
              <li>At each node, compute per-bin sums (and for boosting: sum of gradients \(g\) and Hessians \(h\)).</li>
              <li>Scan only \(B-1\) cut points → massive speed &amp; memory savings.</li>
              <li>Accuracy is typically close to exact if bins capture the distribution (use quantile bins).</li>
            </ul>
          </div>
          <div class="p-3 rounded-xl bg-slate-50 border border-slate-200">
            <p class="font-semibold mb-1">Pedagogical picture</p>
            <p>Exact = “check every slit on the ruler.” Histogram = “first snap numbers to nearby ticks,
              then check only the tick marks.”</p>
          </div>
          <div class="p-3 rounded-xl bg-amber-50 border border-amber-200">
            <p class="font-semibold mb-1">Math bite (boosting gain per split)</p>
            <p>
              For a candidate split, with gradient sum \(G\) and Hessian sum \(H\) in each child, a common gain is:
              \[
              \text{Gain} = \tfrac{1}{2}\!\left(
                \frac{G_L^{2}}{H_L+\lambda} + \frac{G_R^{2}}{H_R+\lambda} - \frac{G^{2}}{H+\lambda}
              \right) - \gamma,
              \]
              where \(\lambda\) (L2) and \(\gamma\) (min split gain) regularize complexity.
            </p>
          </div>
        </div>
      </article>

      <!-- Growth strategy & regularization sidebar -->
      <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
        <h3 class="text-xl font-semibold">Growth Strategy &amp; Regularization</h3>
        <div class="mt-2 text-sm leading-7 text-slate-700 space-y-3">
          <div>
            <p class="font-semibold">Level-wise vs Leaf-wise</p>
            <ul class="list-disc ml-5">
              <li><span class="font-semibold">Level-wise</span> (XGBoost default): expand all nodes at depth \(d\) → balanced, stable.</li>
              <li><span class="font-semibold">Leaf-wise</span> (LightGBM): repeatedly split the leaf
                with the biggest gain → deeper, high accuracy, may overfit without <code>min_data_in_leaf</code>.
              </li>
            </ul>
          </div>
          <div>
            <p class="font-semibold">Shrinkage &amp; Subsampling</p>
            <ul class="list-disc ml-5">
              <li><span class="font-semibold">Learning rate \(\eta\)</span>: scales each tree’s contribution
                (smaller \(\eta\) → more trees, smoother fit).</li>
              <li><span class="font-semibold">Row subsampling</span> (<code>subsample</code>) and
                <span class="font-semibold">column subsampling</span> (<code>colsample_bytree</code>) inject
                randomness → reduce variance.</li>
            </ul>
          </div>
          <div>
            <p class="font-semibold">Monotone Constraints</p>
            <p>Force prediction to increase/decrease with a chosen feature (e.g., price ↑ ⇒ risk ↑).
              Helpful for trust &amp; policy compliance.</p>
          </div>
          <div>
            <p class="font-semibold">Handling Missing &amp; Categorical</p>
            <ul class="list-disc ml-5">
              <li>Missing values: learn default direction per split (sends NaNs to the better side).</li>
              <li>Categoricals: one-hot (simple), or ordered/target-based encodings (careful: avoid leakage).</li>
            </ul>
          </div>
        </div>
      </article>
    </div>

    <!-- GOSS and DART -->
    <div class="grid lg:grid-cols-2 gap-6 mb-10">
      <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
        <h3 class="text-xl font-semibold">GOSS — Gradient-based One-Side Sampling</h3>
        <div class="mt-2 text-sm leading-7 text-slate-700 space-y-3">
          <p>
            In boosting, each iteration computes instance gradients \(g_i\).
            <span class="font-semibold">GOSS</span> keeps all examples with the largest \(|g_i|\) (the
            “hard” cases), and randomly samples from the small-\(|g|\) ones, reweighting them so totals stay unbiased.
          </p>
          <ul class="list-disc ml-5">
            <li><span class="font-semibold">Speed-accuracy trade-off</span>: much faster per iteration with minimal loss in accuracy.</li>
            <li>Choose top fraction \(a\) (keep) and random fraction \(b\) (sample) for the rest;
              rescale weights by \((1-a)/b\).</li>
          </ul>
          <div class="p-3 rounded-xl bg-amber-50 border border-amber-200">
            <p class="font-semibold mb-1">Mini-formula</p>
            <p>
              With kept set \(A\) and sampled set \(B\), use \(w_i = 1\) for \(i \in A\) and
              \(w_i = \tfrac{1-a}{b}\) for \(i \in B\) when forming histogram sums.
            </p>
          </div>
        </div>
      </article>

      <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
        <h3 class="text-xl font-semibold">DART — Dropouts meet Additive Regression Trees</h3>
        <div class="mt-2 text-sm leading-7 text-slate-700 space-y-3">
          <p>
            Boosting adds trees sequentially; later trees can over-specialize.
            <span class="font-semibold">DART</span> randomly “drops” a set of existing trees when
            fitting the new tree, forcing it to be useful on its own.
            After training the new tree, scale contributions so the total stays balanced.
          </p>
          <ul class="list-disc ml-5">
            <li>Typical knobs: drop rate, max dropped trees per iteration, normalization strategy after drop.</li>
            <li>Works best with small learning rates and moderately deep leaves.</li>
          </ul>
        </div>
      </article>
    </div>

    <!-- Cheat Sheet -->
    <div class="grid lg:grid-cols-3 gap-6">
      <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
        <h3 class="text-xl font-semibold">Cheat Sheet (Symbols)</h3>
        <ul class="mt-2 text-sm leading-7 text-slate-700 list-none space-y-1">
          <li>\(g_i\): gradient for sample \(i\)</li>
          <li>\(h_i\): Hessian (2nd derivative or approx.)</li>
          <li>\(G,H\): sums of gradients/Hessians in a node/bin</li>
          <li>\(\lambda, \gamma\): regularization (L2 and min split gain)</li>
          <li>\(\eta\): learning rate (shrinkage)</li>
          <li>\(B\): number of histogram bins</li>
        </ul>
      </article>
    </div>
  </div>
</section>


    <!-- Footer -->
    <footer class="py-10 bg-slate-900 text-slate-200">
        <div class="max-w-7xl mx-auto px-6">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <p class="text-sm">© <span id="year"></span> CART Regression Lab — Single-file</p>
                <div class="text-xs text-slate-400">Tailwind • Alpine.js • Chart.js • SVG</div>
            </div>
        </div>
    </footer>

    <!-- Logic -->
<script>
  /* ===================== Utils ===================== */
  function randn() {
    let u = 0, v = 0; while (!u) u = Math.random(); while (!v) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
  }
  function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0; [a[i], a[j]] = [a[j], a[i]]; } return a; }
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  /* =========== Data generators (1D + 2D) =========== */
  function genData(task, kind, n, noise, balance = 'balanced') {
    const X = [], y = [];
    if (task === 'reg') {
      if (kind === 'sine') {                 // 1D SINE (curve)
        for (let i = 0; i < n; i++) {
          const x = Math.random() * 4 - 2;
          const t = Math.sin(1.5 * x);
          X.push([x, 0]);                     // second feature constant => 1D
          y.push(t + noise * randn());
        }
      } else if (kind === 'sine2d') {        // old 2D “sine-like” surface
        for (let i = 0; i < n; i++) {
          const x = Math.random() * 4 - 2, z = Math.random() * 4 - 2;
          const t = Math.sin(1.5 * x) + 0.5 * Math.cos(2 * z);
          X.push([x, z]); y.push(t + noise * randn());
        }
      } else if (kind === 'plane') {
        const a = 0.8, b = -0.6, c = 0.2;
        for (let i = 0; i < n; i++) {
          const x = Math.random() * 4 - 2, z = Math.random() * 4 - 2;
          X.push([x, z]); y.push(a * x + b * z + c + noise * randn());
        }
      } else if (kind === 'peaks') {
        for (let i = 0; i < n; i++) {
          const x = Math.random() * 4 - 2, z = Math.random() * 4 - 2;
          const t = 1.5 * Math.exp(-((x - 1) ** 2 + (z - 1) ** 2)) - 1.2 * Math.exp(-((x + 1) ** 2 + (z + 1) ** 2));
          X.push([x, z]); y.push(t + 0.2 * Math.sin(3 * x) + noise * randn() * 0.3);
        }
      } else if (kind === 'friedman2d') {
        for (let i = 0; i < n; i++) {
          const x = Math.random() * 4 - 2, z = Math.random() * 4 - 2;
          X.push([x, z]); y.push(Math.sin(x * z) + 0.5 * x - 0.3 * z * z + noise * randn() * 0.2);
        }
      }
    } else { // classification
      if (kind === 'blobs') {
        const centers = balance === 'balanced' ? [[-1, -1], [1, 1]] : [[-1, -1], [1.6, 1.6]];
        const p0 = balance === 'balanced' ? 0.5 : 0.3;
        for (let i = 0; i < n; i++) {
          const c = Math.random() < p0 ? 0 : 1, mu = centers[c];
          X.push([mu[0] + noise * randn() * 2, mu[1] + noise * randn() * 2]); y.push(c);
        }
      } else if (kind === 'moons') {
        for (let i = 0; i < n; i++) {
          const t = Math.random() * Math.PI; const a = (i % 2 === 0) ? 0 : 1;
          const base = a ? [1 - Math.cos(t), 1 - Math.sin(t)] : [Math.cos(t), Math.sin(t)];
          X.push([base[0] + (a ? 0.1 : -0.1) + noise * randn() * 0.2, base[1] + noise * randn() * 0.2]);
          y.push(a);
        }
      } else if (kind === 'xor') {
        for (let i = 0; i < n; i++) {
          const u = (Math.random() * 2 - 1), v = (Math.random() * 2 - 1);
          X.push([u + noise * randn(), v + noise * randn()]);
          y.push(((u > 0) ^ (v > 0)) ? 1 : 0);
        }
      }
    }
    return { X, y };
  }

  /* ============== CART (reg + clf) ============== */
  class CARTReg {
    constructor(maxDepth = 5, minLeaf = 5, featureBag = null, logFn = null) {
      this.maxDepth = maxDepth; this.minLeaf = minLeaf; this.featureBag = featureBag; this.root = null;
      this._log = logFn || (() => { }); this.featureGain = [0, 0]; this.depth = 0; this.leafCount = 0;
    }
    _mse(y, w) {
      const sw = w.reduce((a, b) => a + b, 0) || 1e-9;
      let mu = 0; for (let i = 0; i < y.length; i++) mu += w[i] * y[i]; mu /= sw;
      let v = 0; for (let i = 0; i < y.length; i++) { const d = y[i] - mu; v += w[i] * d * d; }
      return v / sw;
    }
    _bestSplit(X, y, w) {
      const n = X.length; if (n < 2 * this.minLeaf) return null;
      const feats = this.featureBag ?? [0, 1];
      const base = this._mse(y, w);
      let best = { gain: 0, feat: null, thr: null, L: null, R: null };
      for (const f of feats) {
        let arr = X.map((xi, i) => [xi[f], y[i], w[i], i]).sort((a, b) => a[0] - b[0]);
        const Wp = [], Yp = []; let ws = 0, ys = 0;
        for (let i = 0; i < arr.length; i++) { ws += arr[i][2]; ys += arr[i][1] * arr[i][2]; Wp.push(ws); Yp.push(ys); }
        const Wtot = ws, Ytot = ys;
        for (let k = this.minLeaf; k <= n - this.minLeaf; k++) {
          if (arr[k - 1][0] === arr[k][0]) continue;
          const WL = Wp[k - 1], YL = Yp[k - 1], WR = Wtot - WL, YR = Ytot - YL;
          const muL = YL / Math.max(1e-9, WL), muR = YR / Math.max(1e-9, WR);
          let vL = 0, vR = 0;
          for (let i = 0; i < k; i++) { const d = arr[i][1] - muL; vL += arr[i][2] * d * d; }
          for (let i = k; i < n; i++) { const d = arr[i][1] - muR; vR += arr[i][2] * d * d; }
          const mse = (vL + vR) / Math.max(1e-9, (WL + WR));
          const gain = base - mse;
          if (gain > best.gain) {
            best = { gain, feat: f, thr: (arr[k - 1][0] + arr[k][0]) / 2, L: arr.slice(0, k).map(p => p[3]), R: arr.slice(k).map(p => p[3]) };
          }
        }
      }
      return best.gain > 1e-12 ? best : null;
    }
    _build(X, y, w, depth = 0) {
      this.depth = Math.max(this.depth, depth);
      const sw = w.reduce((a, b) => a + b, 0) || 1e-9;
      let mu = 0; for (let i = 0; i < y.length; i++) mu += w[i] * y[i]; mu /= sw;
      if (depth >= this.maxDepth || y.length <= this.minLeaf) {
        this.leafCount++; return { leaf: true, value: mu, n: y.length };
      }
      const sp = this._bestSplit(X, y, w);
      if (!sp) { this.leafCount++; return { leaf: true, value: mu, n: y.length }; }
      this.featureGain[sp.feat] += sp.gain;
      this._log(`split: x${sp.feat} ≤ ${sp.thr.toFixed(3)} | ΔMSE=${sp.gain.toFixed(4)}`);
      const XL = sp.L.map(i => X[i]), yL = sp.L.map(i => y[i]), wL = sp.L.map(i => w[i]);
      const XR = sp.R.map(i => X[i]), yR = sp.R.map(i => y[i]), wR = sp.R.map(i => w[i]);
      return {
        leaf: false, feat: sp.feat, thr: sp.thr,
        left: this._build(XL, yL, wL, depth + 1),
        right: this._build(XR, yR, wR, depth + 1)
      };
    }
    fit(X, y, w = null) {
      const W = w ?? new Array(y.length).fill(1);
      this.featureGain = [0, 0]; this.depth = 0; this.leafCount = 0;
      this.root = this._build(X, y, W, 0);
    }
    predictOne(x, node = this.root) {
      if (!node) return 0;
      if (node.leaf) return node.value;
      return (x[node.feat] <= node.thr) ? this.predictOne(x, node.left) : this.predictOne(x, node.right);
    }
    predict(X) { return X.map(x => this.predictOne(x)); }
  }

  class CARTClf {
    constructor(maxDepth = 5, minLeaf = 5, featureBag = null, logFn = null) {
      this.maxDepth = maxDepth; this.minLeaf = minLeaf; this.featureBag = featureBag; this.root = null;
      this._log = logFn || (() => { }); this.featureGain = [0, 0]; this.depth = 0; this.leafCount = 0;
    }
    _gini(y) { if (y.length === 0) return 0; let c1 = 0; for (const t of y) if (t === 1) c1++; const p = c1 / y.length; return 2 * p * (1 - p); }
    _bestSplit(X, y) {
      const n = X.length; if (n < 2 * this.minLeaf) return null;
      const feats = this.featureBag ?? [0, 1]; const base = this._gini(y);
      let best = { gain: 0, feat: null, thr: null, L: null, R: null };
      for (const f of feats) {
        let arr = X.map((xi, i) => [xi[f], y[i], i]).sort((a, b) => a[0] - b[0]);
        let c1L = 0, c1R = y.filter(t => t === 1).length;
        for (let k = this.minLeaf; k <= n - this.minLeaf; k++) {
          const lab = arr[k - 1][1]; if (lab === 1) { c1L++; c1R--; }
          if (arr[k - 1][0] === arr[k][0]) continue;
          const thr = (arr[k - 1][0] + arr[k][0]) / 2;
          const pL = c1L / k, pR = c1R / (n - k);
          const gL = 2 * pL * (1 - pL), gR = 2 * pR * (1 - pR);
          const gain = base - (k / n) * gL - ((n - k) / n) * gR;
          if (gain > best.gain) best = { gain, feat: f, thr, L: arr.slice(0, k).map(p => p[2]), R: arr.slice(k).map(p => p[2]) };
        }
      }
      return best.gain > 1e-12 ? best : null;
    }
    _build(X, y, depth = 0) {
      this.depth = Math.max(this.depth, depth);
      let c1 = 0; for (const t of y) if (t === 1) c1++; const proba = y.length ? c1 / y.length : 0, pred = (proba >= 0.5 ? 1 : 0);
      if (depth >= this.maxDepth || y.length <= this.minLeaf || this._gini(y) === 0) { this.leafCount++; return { leaf: true, proba, pred, n: y.length }; }
      const sp = this._bestSplit(X, y);
      if (!sp) { this.leafCount++; return { leaf: true, proba, pred, n: y.length }; }
      this.featureGain[sp.feat] += sp.gain;
      const XL = sp.L.map(i => X[i]), yL = sp.L.map(i => y[i]);
      const XR = sp.R.map(i => X[i]), yR = sp.R.map(i => y[i]);
      return {
        leaf: false, feat: sp.feat, thr: sp.thr,
        left: this._build(XL, yL, depth + 1),
        right: this._build(XR, yR, depth + 1)
      };
    }
    fit(X, y) { this.featureGain = [0, 0]; this.depth = 0; this.leafCount = 0; this.root = this._build(X, y, 0); }
    _predOne(x, node = this.root) {
      if (!node) return 0.5; if (node.leaf) return node.proba;
      return (x[node.feat] <= node.thr) ? this._predOne(x, node.left) : this._predOne(x, node.right);
    }
    predictProba(X) { return X.map(x => this._predOne(x)); }
    predict(X) { return this.predictProba(X).map(p => p >= 0.5 ? 1 : 0); }
  }

  /* ============== Ensembles ============== */
  class BaggingReg {
    constructor(n, opts, logFn) { this.n = n; this.opts = opts; this.trees = []; this._log = logFn || (() => { }); this.featureGain = [0, 0]; this.depths = []; this.leaves = []; }
    _featureBag(mode) { const all = [0, 1]; if (mode === 'all') return all; const pick = all[Math.random() < 0.5 ? 0 : 1]; return [pick]; }
    fit(X, y) {
      this.trees = []; this.featureGain = [0, 0]; this.depths = []; this.leaves = [];
      const n = X.length;
      for (let t = 0; t < this.n; t++) {
        let idx = []; if (this.opts.bootstrapRows) { for (let i = 0; i < n; i++) idx.push((Math.random() * n) | 0); }
        else { idx = [...Array(n).keys()]; shuffle(idx); }
        const Xb = idx.map(i => X[i]), yb = idx.map(i => y[i]);
        const fbag = this._featureBag(this.opts.maxFeaturesMode);
        const tr = (this.opts.task === 'reg') ? new CARTReg(this.opts.maxDepth, this.opts.minLeaf, fbag, m => this._log(`[T${t}] ${m}`))
                                             : new CARTClf(this.opts.maxDepth, this.opts.minLeaf, fbag, m => this._log(`[T${t}] ${m}`));
        tr.fit(Xb, yb);
        this.trees.push(tr);
        this.featureGain[0] += tr.featureGain[0]; this.featureGain[1] += tr.featureGain[1];
        this.depths.push(tr.depth); this.leaves.push(tr.leafCount);
      }
    }
    predict(X) {
      if (this.opts.task === 'reg') {
        const sums = new Array(X.length).fill(0);
        for (const tr of this.trees) { const p = tr.predict(X); for (let i = 0; i < p.length; i++) sums[i] += p[i]; }
        return sums.map(s => s / Math.max(1, this.trees.length));
      } else {
        const sums = new Array(X.length).fill(0);
        for (const tr of this.trees) {
          const p = tr.predict(X);
          for (let i = 0; i < p.length; i++) sums[i] += (p[i] ? 1 : 0);
        }
        return sums.map(s => s >= (this.trees.length / 2) ? 1 : 0);
      }
    }
    predictProba(X) {
      if (this.opts.task === 'clf') {
        const sums = new Array(X.length).fill(0);
        for (const tr of this.trees) {
          const p = tr.predictProba ? tr.predictProba(X) : tr.predict(X).map(v => v ? 1 : 0);
          for (let i = 0; i < p.length; i++) sums[i] += p[i];
        }
        return sums.map(s => s / Math.max(1, this.trees.length));
      }
      return null;
    }
  }

  class GBDTReg {
    constructor(n, opts, logFn) { this.n = n; this.opts = opts; this.trees = []; this.depths = []; this.leaves = []; this.featureGain = [0, 0]; this._log = logFn || (() => { }); this.flow = []; }
    fit(X, y) {
      this.trees = []; this.depths = []; this.leaves = []; this.featureGain = [0, 0]; this.flow = [];
      const n = X.length; let F = new Array(n).fill(0);
      for (let m = 0; m < this.n; m++) {
        let idx = [...Array(n).keys()];
        if (this.opts.subsample < 1.0) { shuffle(idx); idx = idx.slice(0, Math.max(1, Math.floor(this.opts.subsample * n))); }
        const Xs = idx.map(i => X[i]), ys = idx.map(i => y[i]), Fs = idx.map(i => F[i]);
        const residuals = ys.map((yi, i) => yi - Fs[i]);
        const tr = new CARTReg(this.opts.maxDepth, this.opts.minLeaf, null, m2 => this._log(`[t${m}] ${m2}`));
        tr.fit(Xs, residuals, new Array(residuals.length).fill(1));
        this.trees.push(tr); this.depths.push(tr.depth); this.leaves.push(tr.leafCount);
        this.featureGain[0] += tr.featureGain[0]; this.featureGain[1] += tr.featureGain[1];
        for (let i = 0; i < n; i++) { F[i] += this.opts.learningRate * tr.predictOne(X[i]); }
        this.flow.push({ m, usedFeat: tr.featureGain[0] >= tr.featureGain[1] ? 0 : 1 });
      }
    }
    predict(X) {
      if (this.trees.length === 0) return new Array(X.length).fill(0);
      const out = new Array(X.length).fill(0);
      for (const tr of this.trees) {
        for (let i = 0; i < X.length; i++) out[i] += this.opts.learningRate * tr.predictOne(X[i]);
      }
      return out;
    }
  }

  /* ===================== Visuals ===================== */
  function ensureCanvasSize(cvs) {
    if (!cvs) return;
    const dpr = window.devicePixelRatio || 1;
    const cssW = cvs.clientWidth || 600;
    const cssH = cvs.clientHeight || 400;
    const needW = Math.round(cssW * dpr);
    const needH = Math.round(cssH * dpr);
    if (cvs.width !== needW || cvs.height !== needH) {
      cvs.width = needW; cvs.height = needH;
    }
  }

  function regColor(v) {
    const nv = 0.5 + 0.5 * Math.tanh(v / 3);
    const r = Math.round(255 * nv);
    const g = Math.round(255 * (1 - Math.abs(nv - 0.5) * 2));
    const b = Math.round(255 * (1 - nv));
    return `rgb(${r},${g},${b})`;
  }

  /* 1D regression renderer: x horizontal, y vertical */
  function drawRegression1D(ctx, X, y, model) {
    if (!ctx) return;
    const cvs = ctx.canvas;
    ensureCanvasSize(cvs);
    const W = cvs.width, H = cvs.height;
    ctx.clearRect(0, 0, W, H);
    if (!X || X.length === 0) return;

    const xs = X.map(p => p[0]);
    const yhatPts = (model && model.predict) ? model.predict(X) : new Array(y.length).fill(0);
    const ys = y.concat(yhatPts);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const padX = 0.05 * (maxX - minX || 1), padY = 0.1 * (maxY - minY || 1);
    const loX = minX - padX, hiX = maxX + padX, loY = minY - padY, hiY = maxY + padY;

    const xPix = x => ((x - loX) / (hiX - loX)) * W;
    const yPix = yv => H - ((yv - loY) / (hiY - loY)) * H;

    // axes (light)
    ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(40, yPix(0)); ctx.lineTo(W - 10, yPix(0)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xPix(0), 10); ctx.lineTo(xPix(0), H - 20); ctx.stroke();

    // truth points
    for (let i = 0; i < X.length; i++) {
      const px = xPix(X[i][0]), py = yPix(y[i]);
      ctx.beginPath(); ctx.arc(px, py, 3.2, 0, 2 * Math.PI);
      ctx.fillStyle = regColor(y[i]); ctx.fill();
    }

    // predicted curve (dense line)
    const G = 300;
    const xsGrid = Array.from({ length: G }, (_, k) => loX + (k / (G - 1)) * (hiX - loX));
    const Xgrid = xsGrid.map(x => [x, 0]);
    const yhat = (model && model.predict) ? model.predict(Xgrid) : new Array(G).fill(0);

    ctx.strokeStyle = '#111827'; ctx.lineWidth = 2;
    ctx.beginPath();
    for (let k = 0; k < G; k++) {
      const px = xPix(xsGrid[k]), py = yPix(yhat[k]);
      if (k === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // legend
    ctx.save();
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillStyle = '#111827';
    ctx.fillText('● truth   — ŷ (predicted curve)', 12, 20);
    ctx.restore();
  }

  /* 2D renderer: background off, dots vs ring predictions (kept) */
  function drawRegression2D(ctx, X, y, model) {
    if (!ctx) return;
    const cvs = ctx.canvas;
    ensureCanvasSize(cvs);
    const W = cvs.width, H = cvs.height;
    ctx.clearRect(0, 0, W, H);
    if (!X || X.length === 0) return;

    const xs = X.map(p => p[0]), zs = X.map(p => p[1]);
    const minX = Math.min(...xs, -2), maxX = Math.max(...xs, 2);
    const minZ = Math.min(...zs, -2), maxZ = Math.max(...zs, 2);
    const pad = .2; const loX = minX - pad, hiX = maxX + pad, loZ = minZ - pad, hiZ = maxZ + pad;

    const yhat = (model && typeof model.predict === 'function') ? model.predict(X) : new Array(X.length).fill(0);

    // truth
    for (let i = 0; i < X.length; i++) {
      const x = X[i][0], z = X[i][1];
      const px = (x - loX) / (hiX - loX) * W, py = H - (z - loZ) / (hiZ - loZ) * H;
      ctx.beginPath(); ctx.arc(px, py, 3.2, 0, 2 * Math.PI);
      ctx.fillStyle = regColor(y[i]); ctx.fill();
    }
    // predicted rings
    ctx.lineWidth = 2;
    for (let i = 0; i < X.length; i++) {
      const x = X[i][0], z = X[i][1];
      const px = (x - loX) / (hiX - loX) * W, py = H - (z - loZ) / (hiZ - loZ) * H;
      ctx.beginPath(); ctx.arc(px, py, 6, 0, 2 * Math.PI);
      ctx.strokeStyle = regColor(yhat[i]); ctx.stroke();
    }
    ctx.save();
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillStyle = '#111827';
    ctx.fillText('● truth (fill)   ○ prediction (ring)', 12, 20);
    ctx.restore();
  }

  /* Classification background */
  function drawClassification(ctx, X, y, model) {
    const cvs = ctx.canvas;
    ensureCanvasSize(cvs);
    const W = cvs.width, H = cvs.height;
    ctx.clearRect(0, 0, W, H);
    if (!X || X.length === 0) return;

    const xs = X.map(p => p[0]), zs = X.map(p => p[1]);
    const minX = Math.min(...xs, -2), maxX = Math.max(...xs, 2);
    const minZ = Math.min(...zs, -2), maxZ = Math.max(...zs, 2);
    const pad = .2; const loX = minX - pad, hiX = maxX + pad, loZ = minZ - pad, hiZ = maxZ + pad;

    const grid = 4;
    const img = ctx.createImageData(W, H);
    for (let ypix = 0; ypix < H; ypix += grid) {
      for (let xpix = 0; xpix < W; xpix += grid) {
        const xx = (xpix / W) * (hiX - loX) + loX;
        const zz = ((H - ypix) / H) * (hiZ - loZ) + loZ;
        const pp = (model && model.predictProba) ? model.predictProba([[xx, zz]])[0]
                 : (model && model.predict && model.predict([[xx, zz]])[0] ? 1 : 0);
        const r = Math.round(255 * (1 - pp)), g = Math.round(255 * pp), b = 180;
        for (let dy = 0; dy < grid; dy++) for (let dx = 0; dx < grid; dx++) {
          const Xp = xpix + dx, Yp = ypix + dy; if (Xp >= W || Yp >= H) continue;
          const k = (Yp * W + Xp) * 4; img.data[k] = r; img.data[k + 1] = g; img.data[k + 2] = b; img.data[k + 3] = 48;
        }
      }
    }
    ctx.putImageData(img, 0, 0);
    // points
    for (let i = 0; i < X.length; i++) {
      const x = X[i][0], z = X[i][1];
      const px = (x - loX) / (hiX - loX) * W, py = H - (z - loZ) / (hiZ - loZ) * H;
      ctx.beginPath(); ctx.arc(px, py, 3, 0, 2 * Math.PI);
      ctx.fillStyle = y[i] ? '#166534' : '#1e3a8a';
      ctx.fill();
    }
  }

  /* ---------- Tree SVG (with render-depth cap to avoid stack blowups) ---------- */
  function renderTreeSVG(svgEl, tree, task) {
    const W = 900, H = 600;
    const MAX_RENDER_DEPTH = 12; // cap to prevent "maximum call stack size exceeded"
    if (!svgEl) return;
    svgEl.setAttribute('viewBox', `0 0 ${W} ${H}`);
    svgEl.innerHTML = '';
    if (!tree || !tree.root) return;

    const cfg = {
      leaf: { minW: 120, h: 30, rx: 10, padX: 12 },
      inner: { minW: 150, h: 34, rx: 10, padX: 12 },
      font: { innerTop: '12px', innerSub: '10px', leaf: '11px' },
      yGapMin: 80,
      xMargin: 50,
      yMargin: 30,
      baseNodeSpacing: 4.5,
      levelSpacingMultiplier: 1.6,
      minSiblingGap: 1.5,
      edgeStroke: 1.5,
      boxStroke: 1.2,
      edgeLabelFont: '10px',
    };

    function annotate(node, depth = 0) {
      if (!node) return { leaves: [], depth, nodeCount: 0 };
      node._depth = depth;
      if (node.leaf) return { leaves: [node], depth, nodeCount: 1 };
      const L = annotate(node.left, depth + 1);
      const R = annotate(node.right, depth + 1);
      if (!node.n && node.left && node.right) {
        node.n = (node.left.n || 0) + (node.right.n || 0);
      }
      return { leaves: [...L.leaves, ...R.leaves], depth: Math.max(L.depth, R.depth), nodeCount: 1 + L.nodeCount + R.nodeCount };
    }
    const info = annotate(tree.root, 0);
    const depth = info.depth;
    let minV, maxV;
    if (task === 'reg') {
      minV = Math.min(...info.leaves.map(n => n.value ?? 0));
      maxV = Math.max(...info.leaves.map(n => n.value ?? 0));
    } else { minV = 0; maxV = 1; }
    const yGap = Math.max(cfg.yGapMin, (H - 2 * cfg.yMargin) / (depth + 1));

    let nextLeaf = 0;
    function shiftSubtree(node, delta) {
      if (!node) return;
      if (typeof node._x === 'number') node._x += delta;
      shiftSubtree(node.left, delta);
      shiftSubtree(node.right, delta);
    }
    function getSubtreeWidth(node) {
      if (!node) return 0;
      if (node.leaf) return 1;
      return getSubtreeWidth(node.left) + getSubtreeWidth(node.right);
    }
    function layoutX(node, d = 0) {
      if (!node) return { min: +Infinity, max: -Infinity, center: 0 };
      if (node.leaf || d >= MAX_RENDER_DEPTH) {
        node._x = nextLeaf++;
        return { min: node._x, max: node._x, center: node._x };
      }
      const L = layoutX(node.left, d + 1);
      const R = layoutX(node.right, d + 1);
      const leftSubtreeWidth = getSubtreeWidth(node.left);
      const rightSubtreeWidth = getSubtreeWidth(node.right);
      const subtreeSizeMultiplier = Math.sqrt(Math.max(leftSubtreeWidth, rightSubtreeWidth, 1)) + 0.5;
      const depthMultiplier = Math.pow(cfg.levelSpacingMultiplier, Math.max(0, d - 1));
      const minSeparation = (cfg.baseNodeSpacing * subtreeSizeMultiplier * depthMultiplier) + cfg.minSiblingGap;
      if (isFinite(L.min) && isFinite(R.min)) {
        const currentGap = R.min - L.max;
        const need = Math.max(0, minSeparation - currentGap);
        if (need > 0) { shiftSubtree(node.right, need); R.min += need; R.max += need; R.center += need; }
        node._x = (L.center + R.center) / 2;
        return { min: Math.min(L.min, R.min), max: Math.max(L.max, R.max), center: node._x };
      } else if (isFinite(L.min)) { node._x = L.center; return L; }
      else if (isFinite(R.min)) { node._x = R.center; return R; }
      node._x = nextLeaf++; return { min: node._x, max: node._x, center: node._x };
    }
    const xb = layoutX(tree.root);

    (function assignY(node) {
      if (!node) return;
      node._y = cfg.yMargin + node._depth * yGap;
      assignY(node.left);
      assignY(node.right);
    })(tree.root);

    const NS = 'http://www.w3.org/2000/svg';
    const gZoom = document.createElementNS(NS, 'g');
    const gContent = document.createElementNS(NS, 'g');
    svgEl.appendChild(gZoom);
    gZoom.appendChild(gContent);

    const axMin = Math.min(xb.min, 0);
    const axMax = Math.max(xb.max, Math.max(1, xb.min + 1));
    const AX = x => (cfg.xMargin + ((x - axMin) / Math.max(1e-6, (axMax - axMin))) * (W - 2 * cfg.xMargin));
    const AY = node => node._y;

    const addLine = (x1, y1, x2, y2) => {
      const el = document.createElementNS(NS, 'line');
      el.setAttribute('x1', x1); el.setAttribute('y1', y1); el.setAttribute('x2', x2); el.setAttribute('y2', y2);
      el.setAttribute('stroke', '#94a3b8'); el.setAttribute('stroke-width', cfg.edgeStroke);
      el.setAttribute('vector-effect', 'non-scaling-stroke'); gContent.appendChild(el);
    };
    const addBox = (x, y, w, h, rx = 8, fillColor, isLeaf = false) => {
      const r = document.createElementNS(NS, 'rect');
      r.setAttribute('x', x - w / 2); r.setAttribute('y', y - h / 2);
      r.setAttribute('width', w); r.setAttribute('height', h); r.setAttribute('rx', rx);
      r.setAttribute('fill', fillColor);
      r.setAttribute('stroke', isLeaf ? '#cbd5e1' : '#e2e8f0');
      r.setAttribute('stroke-width', cfg.boxStroke);
      r.setAttribute('vector-effect', 'non-scaling-stroke'); gContent.appendChild(r); return r;
    };
    const addText = (x, y, text, fs = '10px', weight = 'normal') => {
      const t = document.createElementNS(NS, 'text');
      t.setAttribute('x', x); t.setAttribute('y', y);
      t.setAttribute('text-anchor', 'middle'); t.setAttribute('dominant-baseline', 'middle');
      t.setAttribute('fill', '#334155'); t.setAttribute('font-size', fs); t.setAttribute('font-weight', weight);
      t.textContent = text; gContent.appendChild(t); return t;
    };
    const estWidth = (s, pad) => Math.max(pad * 2 + 7.5 * (s?.length || 0), 0);
    function getFill(node) {
      if (!node.leaf) return '#ffffff';
      const v = (task === 'reg') ? (node.value ?? 0) : (node.proba ?? 0);
      const norm = (v - minV) / (maxV - minV || 1);
      const hue = 240 * (1 - norm);
      return `hsl(${hue}, 70%, 90%)`;
    }

    (function drawEdges(node) {
      if (!node || node.leaf || node._depth >= MAX_RENDER_DEPTH) return;
      const x = AX(node._x);
      const y = AY(node);
      const nodeHeight = cfg.inner.h;
      if (node.left) {
        const xl = AX(node.left._x), yl = AY(node.left);
        const childHeight = node.left.leaf ? cfg.leaf.h : cfg.inner.h;
        addLine(x, y + nodeHeight / 2, xl, yl - childHeight / 2);
        const xm = (x + xl) / 2 + (xl < x ? -10 : 10);
        const ym = (y + nodeHeight / 2 + yl - childHeight / 2) / 2;
        addText(xm, ym - 5, '≤', cfg.edgeLabelFont, '600');
      }
      if (node.right) {
        const xr = AX(node.right._x), yr = AY(node.right);
        const childHeight = node.right.leaf ? cfg.leaf.h : cfg.inner.h;
        addLine(x, y + nodeHeight / 2, xr, yr - childHeight / 2);
        const xm = (x + xr) / 2 + (xr > x ? 10 : -10);
        const ym = (y + nodeHeight / 2 + yr - childHeight / 2) / 2;
        addText(xm, ym - 5, '>', cfg.edgeLabelFont, '600');
      }
      drawEdges(node.left);
      drawEdges(node.right);
    })(tree.root);

    const bbox = { minX: +Infinity, minY: +Infinity, maxX: -Infinity, maxY: -Infinity };
    (function drawNodes(node) {
      if (!node) return;
      const x = AX(node._x), y = AY(node);
      const isLeafOrCap = node.leaf || node._depth >= MAX_RENDER_DEPTH;
      if (isLeafOrCap) {
        const txt = (task === 'reg')
          ? `ŷ=${(+node.value || 0).toFixed(3)} n=${node.n}`
          : `p1=${(((+node.proba) || 0) * 100).toFixed(1)}% n=${node.n}`;
        const w = Math.max(cfg.leaf.minW, estWidth(txt, cfg.leaf.padX));
        const h = cfg.leaf.h;
        addBox(x, y, w, h, cfg.leaf.rx, getFill(node), true);
        addText(x, y, txt, cfg.font.leaf, '500');
        bbox.minX = Math.min(bbox.minX, x - w / 2);
        bbox.maxX = Math.max(bbox.maxX, x + w / 2);
        bbox.minY = Math.min(bbox.minY, y - h / 2);
        bbox.maxY = Math.max(bbox.maxY, y + h / 2);
        return;
      }
      const top = `x${node.feat} ≤ ${(+node.thr).toFixed(3)}`;
      const sub = `n=${node.n}`;
      const w = Math.max(cfg.inner.minW, Math.max(estWidth(top, cfg.inner.padX), estWidth(sub, cfg.inner.padX)));
      const h = cfg.inner.h;
      addBox(x, y, w, h, cfg.inner.rx, getFill(node), false);
      addText(x, y - 8, top, cfg.font.innerTop, '600');
      addText(x, y + 8, sub, cfg.font.innerSub, '400');
      bbox.minX = Math.min(bbox.minX, x - w / 2);
      bbox.maxX = Math.max(bbox.maxX, x + w / 2);
      bbox.minY = Math.min(bbox.minY, y - h / 2);
      bbox.maxY = Math.max(bbox.maxY, y + h / 2);
      drawNodes(node.left);
      drawNodes(node.right);
    })(tree.root);

    const PAD = 30;
    const contentW = Math.max(50, (bbox.maxX - bbox.minX) + 2 * PAD);
    const contentH = Math.max(50, (bbox.maxY - bbox.minY) + 2 * PAD);
    const sx = W / contentW, sy = H / contentH;
    let scale = Math.min(sx, sy) * 0.9;
    let tx = (W - scale * (bbox.minX + bbox.maxX)) / 2;
    let ty = (H - scale * (bbox.minY + bbox.maxY)) / 2;
    const applyTransform = () => { gZoom.setAttribute('transform', `matrix(${scale},0,0,${scale},${tx},${ty})`); };
    applyTransform();

    const minScale = 0.2, maxScale = 8.0;
    svgEl.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = svgEl.getBoundingClientRect();
      const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
      const k = Math.exp(-e.deltaY * 0.002);
      const newScale = Math.min(maxScale, Math.max(minScale, scale * k));
      const ratio = newScale / scale;
      tx = cx - ratio * (cx - tx); ty = cy - ratio * (cy - ty);
      scale = newScale; applyTransform();
    }, { passive: false });

    let dragging = false, lastX = 0, lastY = 0;
    svgEl.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; svgEl.style.cursor = 'grabbing'; });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY; tx += dx; ty += dy; applyTransform();
    });
    window.addEventListener('mouseup', () => { dragging = false; svgEl.style.cursor = 'grab'; });

    svgEl.addEventListener('dblclick', () => {
      scale = Math.min(sx, sy) * 0.8;
      tx = (W - scale * (bbox.minX + bbox.maxX)) / 2;
      ty = (H - scale * (bbox.minY + bbox.maxY)) / 2;
      applyTransform();
    });

    const overlay = document.createElementNS(NS, 'rect');
    overlay.setAttribute('x', 0); overlay.setAttribute('y', 0);
    overlay.setAttribute('width', W); overlay.setAttribute('height', H);
    overlay.setAttribute('fill', 'transparent'); overlay.style.cursor = 'grab';
    svgEl.insertBefore(overlay, gZoom);
  }

  function renderEnsembleSVG(svgEl, mode, model) {
    const w = 600, h = 420; if (!svgEl) return;
    svgEl.setAttribute('viewBox', `0 0 ${w} ${h}`); svgEl.innerHTML = '';
    const NS = 'http://www.w3.org/2000/svg';
    const box = (x, y, txt) => {
      const g = document.createElementNS(NS, 'g');
      const r = document.createElementNS(NS, 'rect'); r.setAttribute('x', x - 70); r.setAttribute('y', y - 20);
      r.setAttribute('width', 140); r.setAttribute('height', 40); r.setAttribute('rx', 10);
      r.setAttribute('fill', '#fff'); r.setAttribute('stroke', '#e2e8f0'); g.appendChild(r);
      const t = document.createElementNS(NS, 'text'); t.setAttribute('x', x); t.setAttribute('y', y + 2);
      t.setAttribute('text-anchor', 'middle'); t.setAttribute('fill', '#334155'); t.setAttribute('font-size', '12px');
      t.textContent = txt; g.appendChild(t); svgEl.appendChild(g);
    };
    const arrow = (x1, y1, x2, y2) => {
      const l = document.createElementNS(NS, 'line');
      l.setAttribute('x1', x1); l.setAttribute('y1', y1); l.setAttribute('x2', x2); l.setAttribute('y2', y2);
      l.setAttribute('stroke', '#94a3b8'); l.setAttribute('stroke-width', '2'); svgEl.appendChild(l);
      const m = document.createElementNS(NS, 'polygon'); const ang = Math.atan2(y2 - y1, x2 - x1);
      const ax = x2 - 8 * Math.cos(ang), ay = y2 - 8 * Math.sin(ang);
      const p1 = [x2, y2], p2 = [ax - 4 * Math.sin(ang), ay + 4 * Math.cos(ang)], p3 = [ax + 4 * Math.sin(ang), ay - 4 * Math.cos(ang)];
      m.setAttribute('points', `${p1} ${p2} ${p3}`); m.setAttribute('fill', '#94a3b8'); svgEl.appendChild(m);
    };

    if (mode === 'bagging') {
      box(80, 210, 'Data X,y');
      const rows = 3, cols = 3, startX = 220, startY = 120, dx = 120, dy = 90;
      const n = (model?.trees?.length) || 9; let k = 0; const centers = [];
      for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
        if (k >= n) break; const x = startX + c * dx, y = startY + r * dy; box(x, y, `Tree ${k}`); arrow(150, 210, x - 80, y); centers.push([x, y]); k++;
      }
      box(520, 210, 'Averager');
      for (const [x, y] of centers) arrow(x + 70, y, 450, 210);
    } else if (mode === 'gbdt') {
      box(80, 210, 'Data X,y');
      box(220, 210, 'Init F=0'); arrow(220 + 70, 210, 320 - 80, 210);
      const n = (model?.trees?.length) || 4; let x = 320;
      for (let m = 0; m < n; m++) {
        box(x, 160, `Tree ${m} on r=y−F`); arrow(x - 120, 210, x - 70, 160);
        box(x, 260, 'F ← F + η·tree'); arrow(x, 180, x, 240);
        if (m < n - 1) arrow(x + 70, 260, x + 120, 210);
        x += 160;
      }
    } else {
      box(300, 210, 'Single CART');
    }
  }

  /* ============== Alpine component ============== */
  function lab() {
    return {
      // data & config
      task: 'reg',
      dataset: 'sine',
      balance: 'balanced',
      nSamples: 400,
      noise: 0.15,

      mode: 'cart',
      maxDepth: 5,
      minLeaf: 5,

      // ensembles
      nEstimators: 25,
      bootstrapRows: true,
      maxFeaturesMode: 'sqrt',

      learningRate: 0.2,
      subsample: 0.8,

      // runtime
      X: [], y: [],
      model: null,
      baseTree: null,
      modelSummary: { trees: 0, avgDepth: 0, avgLeaves: 0 },
      metrics: { mse: 0, r2: 0, acc: 0 },
      featChart: null,
      log: [],
      _inited: false,
      _resizeHandler: null,

      init() {
        this.regenData();
        this.initFeatChart();
        this.train(); // initial train
      },

      destroy() {
        try {
          if (this.featChart && typeof this.featChart.destroy === 'function') {
            this.featChart.destroy();
            this.featChart = null;
          }
          if (this._resizeHandler) {
            window.removeEventListener('resize', this._resizeHandler);
            this._resizeHandler = null;
          }
        } catch (e) { }
        this._inited = false;
      },

      regenData() {
        const d = genData(this.task, this.dataset, this.nSamples, this.noise, this.balance);
        this.X = d.X; this.y = d.y;
        this.log.push(`data: ${this.task}/${this.dataset}, n=${this.X.length}, noise=${this.noise}`);
        this.$nextTick(() => this._autoScroll());
        this.drawAll();
      },

      resetModel() {
        this.model = null;
        this.baseTree = null;
        this.modelSummary = { trees: 0, avgDepth: 0, avgLeaves: 0 };
        this.metrics = { mse: 0, r2: 0, acc: 0 };
        // zero the chart (no destroy/recreate here)
        this.updateFeatChart([0, 0]);

        this.log.push('model cleared');
        this.$nextTick(() => this._autoScroll());

        // wipe visuals
        try {
          const ens = document.getElementById('ensSvg'); if (ens) ens.innerHTML = '';
          const tree = document.getElementById('treeSvg'); if (tree) tree.innerHTML = '';
          const cvs = document.getElementById('dbCanvas');
          if (cvs) { const ctx = cvs.getContext('2d'); if (ctx) ctx.clearRect(0, 0, cvs.width, cvs.height); }
        } catch (e) {}

        this.drawAll(); // redraw with fallbacks
      },

      train() {
        if (this.mode === 'cart') {
          const tree = (this.task === 'reg')
            ? new CARTReg(this.maxDepth, this.minLeaf, null, m => this._pushLog(m))
            : new CARTClf(this.maxDepth, this.minLeaf, null, m => this._pushLog(m));
          tree.fit(this.X, this.y);
          this.model = tree;
          this.baseTree = tree;
          this.modelSummary = { trees: 1, avgDepth: tree.depth, avgLeaves: tree.leafCount };
          this.updateFeatChart(tree.featureGain);
          this._pushLog(`CART trained: depth=${tree.depth}, leaves=${tree.leafCount}`);
        } else if (this.mode === 'bagging') {
          const bag = new BaggingReg(this.nEstimators, {
            task: this.task, maxDepth: this.maxDepth, minLeaf: this.minLeaf,
            bootstrapRows: this.bootstrapRows, maxFeaturesMode: this.maxFeaturesMode
          }, m => this._pushLog(m));
          bag.fit(this.X, this.y);
          this.model = bag;
          const avgD = bag.depths.length ? bag.depths.reduce((a, b) => a + b, 0) / bag.depths.length : 0;
          const avgL = bag.leaves.length ? bag.leaves.reduce((a, b) => a + b, 0) / bag.leaves.length : 0;
          this.modelSummary = { trees: bag.trees.length, avgDepth: avgD, avgLeaves: avgL };
          this.updateFeatChart(bag.featureGain);
          this.baseTree = bag.trees && bag.trees.length ? bag.trees[0] : null;
          this._pushLog(`Bagging trained: trees=${bag.trees.length}`);
        } else if (this.mode === 'gbdt') {
          if (this.task === 'clf') { this._pushLog('Note: boosting demo here is regression-focused.'); }
          const gbdt = new GBDTReg(this.nEstimators, {
            maxDepth: this.maxDepth, minLeaf: this.minLeaf,
            learningRate: this.learningRate, subsample: this.subsample
          }, m => this._pushLog(m));
          gbdt.fit(this.X, this.y);
          this.model = gbdt;
          const avgD = gbdt.depths.length ? gbdt.depths.reduce((a, b) => a + b, 0) / gbdt.depths.length : 0;
          const avgL = gbdt.leaves.length ? gbdt.leaves.reduce((a, b) => a + b, 0) / gbdt.leaves.length : 0;
          this.modelSummary = { trees: gbdt.trees.length, avgDepth: avgD, avgLeaves: avgL };
          this.updateFeatChart(gbdt.featureGain);
          this.baseTree = gbdt.trees.length ? gbdt.trees[gbdt.trees.length - 1] : null;
          this._pushLog(`GBDT trained: trees=${gbdt.trees.length}, lr=${this.learningRate}`);
        }
        this.evalAndDraw();
      },

      evalAndDraw() {
        if (!this.model) { this.drawAll(); return; }
        if (this.task === 'reg') {
          const pred = this.model.predict ? this.model.predict(this.X) : new Array(this.X.length).fill(0);
          let mse = 0, ybar = 0; const n = this.y.length || 1;
          for (let i = 0; i < n; i++) { const di = (pred[i] ?? 0) - (this.y[i] ?? 0); mse += di * di; ybar += this.y[i] ?? 0; }
          mse /= Math.max(1, n); ybar /= Math.max(1, n);
          let sst = 0; for (let i = 0; i < n; i++) { const d = (this.y[i] ?? 0) - ybar; sst += d * d; }
          const r2 = (sst <= 1e-12) ? 1.0 : (1 - (mse * n) / Math.max(1e-12, sst));
          this.metrics = { ...this.metrics, mse, r2 };
        } else {
          const pred = this.model.predict ? this.model.predict(this.X) : [];
          let acc = 0; for (let i = 0; i < pred.length; i++) if ((pred[i] ?? 0) === (this.y[i] ?? 1)) acc++;
          acc /= Math.max(1, pred.length);
          this.metrics = { ...this.metrics, acc };
        }
        this.drawAll();
        this.$nextTick(() => this._autoScroll());
      },

      drawAll() {
        const cvs = document.getElementById('dbCanvas');
        const ctx = cvs ? cvs.getContext('2d') : null;

        // detect 1D (second feature constant)
        let is1D = false;
        if (this.X && this.X.length) {
          const z0 = this.X[0][1];
          is1D = this.X.every(p => Math.abs(p[1] - z0) < 1e-12);
        }

        // length-aware fallbacks to avoid NaNs/Chart churn
        const fallbackReg = { predict: (A) => new Array((A?.length || 0)).fill(0) };
        const fallbackClf = { predict: (A) => new Array((A?.length || 0)).fill(0), predictProba: (A) => new Array((A?.length || 0)).fill(0.5) };

        if (this.task === 'reg') {
          if (is1D) drawRegression1D(ctx, this.X, this.y, this.model ?? this.baseTree ?? fallbackReg);
          else drawRegression2D(ctx, this.X, this.y, this.model ?? this.baseTree ?? fallbackReg);
        } else {
          drawClassification(ctx, this.X, this.y, this.model ?? this.baseTree ?? fallbackClf);
        }

        const treeTarget = (this.mode === 'cart') ? this.model : this.baseTree;
        renderTreeSVG(document.getElementById('treeSvg'), treeTarget, this.task);

        renderEnsembleSVG(document.getElementById('ensSvg'), this.mode, this.model);
      },

      /* -------- Chart.js (feature gains) -------- */
      initFeatChart() {
        const el = document.getElementById('featChart');
        if (!el || this.featChart) return; // only init once
        if (typeof Chart === 'undefined') return;

        const ctx = el.getContext('2d');
        // Guard against detached canvas
        if (!ctx || !el.isConnected) return;

        this.featChart = new Chart(ctx, {
          type: 'bar',
          data: { labels: ['x0', 'x1'], datasets: [{ label: 'gain', data: [0, 0] }] },
          options: { responsive: true, aspectRatio: 2.2, animation: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } }
        });
      },

      updateFeatChart(g) {
        const chart = this.featChart;
        if (!chart || !chart.canvas || !chart.canvas.isConnected) return;
        const d0 = Array.isArray(g) && g.length > 0 ? (g[0] || 0) : 0;
        const d1 = Array.isArray(g) && g.length > 1 ? (g[1] || 0) : 0;
        chart.data.datasets[0].data = [d0, d1];

        // Defer update to the next frame to avoid Chart.js touching layout
        requestAnimationFrame(() => {
          if (!this.featChart || !this.featChart.canvas || !this.featChart.canvas.isConnected) return;
          try { this.featChart.update(); } catch (e) { /* swallow Chart.js internal timing issues */ }
        });
      },

      _pushLog(m) { this.log.push(m); this.$nextTick(() => this._autoScroll()); },
      _autoScroll() {
        const box = document.getElementById('logBox');
        if (!box) return;
        requestAnimationFrame(() => { box.scrollTop = box.scrollHeight; });
      },
    };
  }

  /* Footer year (optional) */
  document.addEventListener('DOMContentLoaded', () => {
    const y = document.getElementById('year'); if (y) y.textContent = new Date().getFullYear();
  });
</script>


</body>

</html>