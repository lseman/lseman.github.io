<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Recurrence Wizard</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    chtml: {
      // disable MathJax linebreaking entirely
      linebreaks: { automatic: false },
      matchFontHeight: true
    },
    options: {
      ignoreHtmlClass: 'tex2jax_ignore',
      processHtmlClass: 'tex2jax_process'
    }
  };
</script>
<!-- Use CHTML instead of SVG -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- Alpine.js -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

  <style>
    :root { color-scheme: light; }
    html { scroll-behavior: smooth; }
    /* subtle animated gradient */
    .bg-hero { background: linear-gradient(120deg, #eef2ff, #f0fdf4, #ecfeff); background-size: 200% 200%; animation: grad 18s ease infinite; }
    @keyframes grad { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    /* Prevent inline MathJax from breaking across lines */
mjx-container[jax="SVG"][display="inline"] {
  white-space: nowrap;
}

/* Make long lines with inline math still usable on small screens */
.math-nowrap {
  white-space: nowrap;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

/* Optional: keep display equations blocky and not wrapped */
mjx-container[jax="SVG"][display="true"] {
  display: block;
  overflow-x: auto; /* in case a wide display equation exceeds container */
}

  </style>
</head>
<body class="min-h-screen text-slate-800">
  <!-- Hero -->
  <header class="bg-hero">
    <div class="max-w-7xl mx-auto px-6 py-14 lg:py-20">
      <div class="flex flex-col lg:flex-row items-center gap-10">
        <div class="flex-1">
                    <img src="logo.png" alt="Recurrence Wizard Logo" class="mx-auto mb-6 w-32 h-32">

          <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900">
            The <span class="text-indigo-600">Recurrence Wizard</span> — UFSC
          </h1>
          <p class="mt-4 text-lg md:text-xl text-slate-700">The wizard aids to help students <span class="font-semibold">discover the best method</span> for their recurrence: Master Theorem, Akra–Bazzi, Subtractive, Power‑shrink, Iterated Log, Dominance, and Variable Change.</p>
          <div class="mt-6 flex flex-wrap gap-3">
            <a href="#wizard" class="px-5 py-3 rounded-xl bg-indigo-600 text-white font-semibold shadow hover:bg-indigo-700">Start the Method Recommender</a>
            <a href="#guide" class="px-5 py-3 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50">Read the Illustrated Guide</a>
          </div>
          <p class="mt-6 text-sm text-slate-500">Built with vanilla JS, Tailwind, Alpine.js, MathJax, and Chart.js — no React.</p>
                    <p class="mt-6 text-sm text-slate-500">Prof. Laio Oriel Seman, Dr.</p>

        </div>
        <div class="flex-1 w-full">
          <div class="bg-white/70 backdrop-blur rounded-2xl p-6 shadow border border-slate-100">
            <canvas id="complexityChart" height="220"></canvas>
            <p class="mt-3 text-center text-sm text-slate-600">Relative growth landscape: $1 < \log^*n < \log\log n < \log n < n < n\log n < n^2 < 2^n < n! < n^n$</p>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Method Recommender Wizard -->
  <section id="wizard" class="py-14">
    <div class="max-w-7xl mx-auto px-6" x-data="recurrenceWizard()" x-init="init()">
      <div class="mb-8">
        <h2 class="text-3xl font-bold tracking-tight text-slate-900">Method Recommender</h2>
        <p class="mt-2 text-slate-600">Paste your recurrence, and we'll suggest a method with reasoning. This is a heuristic helper — always verify with the formal criteria below.</p>
      </div>

      <div class="grid lg:grid-cols-3 gap-6">
        <!-- Input -->
        <div class="lg:col-span-2">
          <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
            <label class="block text-sm font-semibold text-slate-700" for="recurrence">Recurrence</label>
            <textarea id="recurrence" x-model="input" @input.debounce.300ms="analyze()" placeholder="Examples: T(n)=2T(n/2)+n,   T(n)=T(n-1)+n,   T(n)=3T(n/4)+n log n,   T(n)=T(√n)+1,   T(n)=T(log n)+1,   T(n)=T(n^0.6)+n^2" class="mt-2 w-full h-28 code rounded-xl border-slate-300 focus:ring-2 focus:ring-indigo-500"></textarea>

            <div class="mt-3 flex flex-wrap gap-2 text-sm">
              <button @click="setExample('master1')" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">2T(n/2)+n</button>
              <button @click="setExample('master2')" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">3T(n/4)+n log n</button>
              <button @click="setExample('akra')" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=T(n/2)+T(n/3)+n</button>
              <button @click="setExample('sub')" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=T(n-1)+n</button>
              <button @click="setExample('power')" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=2T(√n)+log n</button>
              <button @click="setExample('ilog')" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=T(log n)+1</button>
              <button @click="setExample('dom')" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=2^n T(n/2)+n^n</button>
            </div>
          </div>
        </div>

        <!-- Output / Recommendation -->
        <div class="lg:col-span-1">
          <div class="bg-white rounded-2xl shadow p-5 border border-slate-200 min-h-[16rem]">
            <h3 class="text-lg font-semibold text-slate-800">Suggested Method</h3>
            <p class="mt-1 text-xs text-slate-500">Heuristic classification based on structure.</p>
            <div class="mt-3">
              <div class="flex items-center gap-2">
                <div :class="methodPillClass" class="px-2.5 py-1 rounded-full text-xs font-semibold uppercase tracking-wide" x-text="method"></div>
                <span class="text-xs text-slate-500" x-show="confidence" x-text="'Confidence: ' + confidence"></span>
              </div>
              <div class="mt-3 text-sm" x-html="rendered"></div>
              <div class="mt-3 text-xs text-slate-500" x-show="notes" x-text="notes"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Parsed parameters -->
      <div class="mt-6 grid md:grid-cols-2 gap-6">
        <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
          <h4 class="font-semibold text-slate-800">Parsed Structure</h4>
          <table class="mt-3 w-full text-sm">
            <tbody class="divide-y divide-slate-100">
              <tr><td class="py-2 text-slate-500">Form</td><td class="py-2 code" x-text="parsed.form"></td></tr>
              <tr x-show="parsed.a !== null"><td class="py-2 text-slate-500">a</td><td class="py-2 code" x-text="parsed.a"></td></tr>
              <tr x-show="parsed.b !== null"><td class="py-2 text-slate-500">b</td><td class="py-2 code" x-text="parsed.b"></td></tr>
              <tr x-show="parsed.p !== null"><td class="py-2 text-slate-500">p = log_b a</td><td class="py-2 code" x-text="parsed.p"></td></tr>
              <tr x-show="parsed.r !== null"><td class="py-2 text-slate-500">r (power shrink)</td><td class="py-2 code" x-text="parsed.r"></td></tr>
              <tr x-show="parsed.branches && parsed.branches.length"><td class="py-2 text-slate-500 align-top">Branches (Akra–Bazzi)</td><td class="py-2 code"><div class="space-y-1" x-html="branchList()"></div></td></tr>
              <tr><td class="py-2 text-slate-500">f(n)/g(n)</td><td class="py-2 code" x-text="parsed.f"></td></tr>
            </tbody>
          </table>
        </div>
        <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
          <h4 class="font-semibold text-slate-800">Quick Verdict (asymptotic pattern)</h4>
          <p class="mt-2 text-sm" x-html="verdict"></p>
          <div class="mt-3 text-xs text-slate-500" x-show="caveats" x-text="caveats"></div>
        </div>
      </div>

    </div>
  </section>

  <!-- Illustrated Guide -->
  <section id="guide" class="py-14 bg-slate-50">
    <div class="max-w-7xl mx-auto px-6">
      <div class="mb-10">
        <h2 class="text-3xl font-bold tracking-tight text-slate-900">Illustrated Guide</h2>
        <p class="mt-2 text-slate-600">Pedagogical explanations with formulas you can expand. Click a card to toggle details.</p>
      </div>

      <div class="grid lg:grid-cols-2 gap-6">
        <!-- Master Theorem -->
        <article x-data="{open:false}" class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
          <header class="flex items-start justify-between cursor-pointer" @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
            <div>
              <h3 class="text-xl font-semibold">1) Master Theorem</h3>
              <p class="text-slate-600 text-sm mt-1">Compare $f(n)$ vs. $n^{\log_b a}$ in $T(n) = aT(n/b) + f(n)$.</p>
            </div>
            <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
          </header>
          <div x-show="open" x-transition class="mt-4 text-sm leading-7">
            <p><strong>Intuition.</strong> Recursion tree with branching factor $a$ and shrink $b$; threshold $n^{\log_b a}$.</p>
            <ul class="list-disc pl-5 mt-2">
              <li>Case 1: $f(n)=O(n^{p-\epsilon}) \Rightarrow T(n)=\Theta(n^p)$</li>
              <li>Case 2: $f(n)=\Theta(n^p\log^k n) \Rightarrow T(n)=\Theta(n^p \log^{k+1} n)$</li>
              <li>Case 3: $f(n)=\Omega(n^{p+\epsilon})$ with regularity $af(n/b)\le c f(n)$ $\Rightarrow T(n)=\Theta(f(n))$</li>
            </ul>
          </div>
        </article>

        <!-- Akra–Bazzi -->
        <article x-data="{open:false}" class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
          <header class="flex items-start justify-between cursor-pointer" @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
            <div>
              <h3 class="text-xl font-semibold">2) Akra–Bazzi</h3>
              <p class="text-slate-600 text-sm mt-1">General form $T(n)=\sum a_i T(b_i n)+g(n)$ with balance $\sum a_i b_i^p=1$.</p>
            </div>
            <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
          </header>
          <div x-show="open" x-transition class="mt-4 text-sm leading-7">
            <p>Solution: $T(n)=\Theta\big(n^p \big(1+\int_1^n g(u)/u^{p+1}\,du\big)\big)$.</p>
            <p class="mt-2">Use when branches differ or Master doesn't apply directly.</p>
          </div>
        </article>

        <!-- Subtractive -->
        <article x-data="{open:false}" class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
          <header class="flex items-start justify-between cursor-pointer" @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
            <div>
              <h3 class="text-xl font-semibold">3) Subtractive Recurrence</h3>
              <p class="text-slate-600 text-sm mt-1">$T(n)=T(n-c)+g(n)$ telescopes: $T(n)\approx const + \tfrac{1}{c}\int_0^n g(u)du$.</p>
            </div>
            <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
          </header>
          <div x-show="open" x-transition class="mt-4 text-sm leading-7">
            <p>Linear chain depth $\approx n/c$. Great for peeling‑style processes.</p>
          </div>
        </article>

        <!-- Power‑shrink -->
        <article x-data="{open:false}" class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
          <header class="flex items-start justify-between cursor-pointer" @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
            <div>
              <h3 class="text-xl font-semibold">4) Power‑shrink</h3>
              <p class="text-slate-600 text-sm mt-1">$T(n)=a(n)T(n^r)+g(n)$, depth $O(\log\log n)$ when $0<r<1$.</p>
            </div>
            <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
          </header>
          <div x-show="open" x-transition class="mt-4 text-sm leading-7">
            <p>Use substitution $n=2^{2^k}$ for $r=1/2$ to linearize depth in $k$.</p>
          </div>
        </article>

        <!-- Iterated Log -->
        <article x-data="{open:false}" class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
          <header class="flex items-start justify-between cursor-pointer" @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
            <div>
              <h3 class="text-xl font-semibold">5) Iterated Log</h3>
              <p class="text-slate-600 text-sm mt-1">$T(n)=T(\log n)+O(1) \Rightarrow T(n)=\Theta(\log^* n)$.</p>
            </div>
            <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
          </header>
          <div x-show="open" x-transition class="mt-4 text-sm leading-7">
            <p>Lazy shrinking; $\log^* n$ is $\le 5$ for any earthly $n$.</p>
          </div>
        </article>

        <!-- Dominance -->
        <article x-data="{open:false}" class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
          <header class="flex items-start justify-between cursor-pointer" @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
            <div>
              <h3 class="text-xl font-semibold">6) Dominance Analysis</h3>
              <p class="text-slate-600 text-sm mt-1">When $g(n)$ dwarfs recursive contribution: $T(n)=\Theta(g(n))$.</p>
            </div>
            <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
          </header>
          <div x-show="open" x-transition class="mt-4 text-sm leading-7">
            <p>Compare $\prod a(\cdot)$ vs. $g(n)$ growth; e.g. $n^n \gg 2^{O(n)}$.</p>
          </div>
        </article>

        <!-- Variable Change -->
        <article x-data="{open:false}" class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
          <header class="flex items-start justify-between cursor-pointer" @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
            <div>
              <h3 class="text-xl font-semibold">7) Variable Changing</h3>
              <p class="text-slate-600 text-sm mt-1">Substitute $n=h(k)$ to linearize: $\sqrt{n}, \log n, 2^k$ tricks.</p>
            </div>
            <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
          </header>
          <div x-show="open" x-transition class="mt-4 text-sm leading-7">
            <p>Turn exotic arguments into standard recurrences in $k$; back‑substitute.</p>
          </div>
        </article>
      </div>
    </div>
  </section>

  <!-- Comparison Table -->
  <section class="py-14">
    <div class="max-w-7xl mx-auto px-6">
      <h2 class="text-3xl font-bold tracking-tight text-slate-900">Method Selection Cheat‑Sheet</h2>
      <div class="mt-4 overflow-x-auto bg-white rounded-2xl shadow border border-slate-200">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-50 text-slate-600">
            <tr>
              <th class="text-left p-3 font-semibold">Pattern</th>
              <th class="text-left p-3 font-semibold">Best Method</th>
              <th class="text-left p-3 font-semibold">Complexity Pattern</th>
              <th class="text-left p-3 font-semibold">Insight</th>
            </tr>
          </thead>
          <tbody class="divide-y divide-slate-100">
            <tr>
              <td class="p-3 code">T(n)=aT(n/b)+f(n)</td>
              <td class="p-3">Master</td>
              <td class="p-3">$\Theta(n^p)$, $\Theta(n^p\log n)$, $\Theta(f(n))$</td>
              <td class="p-3">Compare $f$ vs. $n^{\log_b a}$</td>
            </tr>
            <tr>
              <td class="p-3 code">T(n)=\sum a_i T(b_i n)+g(n)</td>
              <td class="p-3">Akra–Bazzi</td>
              <td class="p-3">$\Theta(n^p(1+\int g/u^{p+1}))$</td>
              <td class="p-3">Balance $\sum a_i b_i^p=1$</td>
            </tr>
            <tr>
              <td class="p-3 code">T(n)=T(n-c)+g(n)</td>
              <td class="p-3">Subtractive</td>
              <td class="p-3">$\Theta(\int g)$</td>
              <td class="p-3">Telescopes</td>
            </tr>
            <tr>
              <td class="p-3 code">T(n)=a(n)T(n^r)+g(n)</td>
              <td class="p-3">Power‑shrink</td>
              <td class="p-3">often $\Theta(g\cdot \log\log n)$</td>
              <td class="p-3">$O(\log\log n)$ depth</td>
            </tr>
            <tr>
              <td class="p-3 code">T(n)=T(\log n)+c</td>
              <td class="p-3">Iterated log</td>
              <td class="p-3">$\Theta(\log^* n)$</td>
              <td class="p-3">Extremely slow shrink</td>
            </tr>
            <tr>
              <td class="p-3 code">super‑exp $g(n)$</td>
              <td class="p-3">Dominance</td>
              <td class="p-3">$\Theta(g(n))$</td>
              <td class="p-3">Work overwhelms recursion</td>
            </tr>
            <tr>
              <td class="p-3 code">weird argument</td>
              <td class="p-3">Variable change</td>
              <td class="p-3">depends</td>
              <td class="p-3">Linearize via substitution</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="py-10 bg-slate-900 text-slate-200">
    <div class="max-w-7xl mx-auto px-6">
      <div class="flex flex-col md:flex-row items-center justify-between gap-4">
        <p class="text-sm">© <span id="year"></span> Recurrence Wizard — Built for students. Single‑file, no React.</p>
        <div class="text-xs text-slate-400">Tailwind • Alpine.js • MathJax • Chart.js</div>
      </div>
    </div>
  </footer>

  <script>
// Footer year
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('year').textContent = new Date().getFullYear();
  
  // Initialize MathJax rendering for initial content
  if (window.MathJax) {
    MathJax.typesetPromise();
  }
});

// Complexity skyline chart (purely illustrative ordering)
document.addEventListener('DOMContentLoaded', () => {
  const ctx = document.getElementById('complexityChart');
  if (!ctx) return;
  const data = {
    labels: ['1','log* n','log log n','log n','n','n log n','n^2','2^n','n!','n^n'],
    datasets: [{
      label: 'Relative growth (log scale)',
      data: [1, 1.5, 2, 3, 6, 7, 10, 20, 30, 36],
      fill: true,
      tension: 0.3,
      backgroundColor: 'rgba(79, 70, 229, 0.1)',
      borderColor: 'rgba(79, 70, 229, 0.6)',
    }]
  };
  new Chart(ctx, { 
    type: 'line', 
    data, 
    options: { 
      responsive: true, 
      scales: { 
        y: { display: false } 
      }, 
      plugins: { 
        legend: { display: false } 
      } 
    } 
  });
});

// ---------- Heuristic Parser & Recommender ----------
function recurrenceWizard() {
  return {
    input: '',
    parsed: { form: '-', a: null, b: null, p: null, r: null, f: '-', branches: [] },
    method: '—',
    confidence: '',
    notes: '',
    verdict: '',
    caveats: '',
    rendered: '',
    
    get methodPillClass() {
      const m = this.method.toLowerCase();
      const base = 'text-xs';
      if (m.includes('master')) return base + ' bg-indigo-100 text-indigo-700';
      if (m.includes('akra')) return base + ' bg-emerald-100 text-emerald-700';
      if (m.includes('subtract')) return base + ' bg-amber-100 text-amber-800';
      if (m.includes('power')) return base + ' bg-fuchsia-100 text-fuchsia-700';
      if (m.includes('iter')) return base + ' bg-sky-100 text-sky-700';
      if (m.includes('dom')) return base + ' bg-rose-100 text-rose-700';
      if (m.includes('variable')) return base + ' bg-slate-100 text-slate-700';
      return base + ' bg-slate-100 text-slate-700';
    },
    
    init() {
      this.setExample('master1');
    },
    
    setExample(which) {
      const examples = {
        master1: 'T(n) = 2 T(n/2) + n',
        master2: 'T(n) = 3 T(n/4) + n log n',
        akra:    'T(n) = T(n/2) + T(n/3) + n',
        sub:     'T(n) = T(n-1) + n',
        power:   'T(n) = 2 T(n^(1/2)) + log n',
        ilog:    'T(n) = T(log n) + 1',
        dom:     'T(n) = 2^n T(n/2) + n^n'
      };
      this.input = examples[which] || '';
      this.analyze();
    },
    
    analyze() {
      const s = this.input.replace(/\s+/g,'');
      
      // Reset
      this.parsed = { form: '-', a: null, b: null, p: null, r: null, f: '-', branches: [] };
      this.method = '—';
      this.confidence = '';
      this.notes = '';
      this.verdict = '';
      this.caveats = '';
      this.rendered = '';

      if (!s.includes('T(')) { 
        this.notes = 'Type a recurrence like T(n)=2T(n/2)+n'; 
        return; 
      }

      // Patterns with improved regex
      const master = s.match(/^T\(n\)=([0-9]+)T\(n\/([0-9]+)\)\+(.+)$/i);
      const subtract = s.match(/^T\(n\)=T\(n-([0-9]+)\)\+(.+)$/i);
      const ilog = s.match(/^T\(n\)=T\(logn\)\+(.+)$/i);
      const power = s.match(/^T\(n\)=([0-9]+)T\(n\^\(?([0-9]*\.?[0-9]+|1\/2)\)?\)\+(.+)$/i);
      const variableSqrt = s.match(/^T\(n\)=([0-9]*)T\(√n\)\+(.+)$/i);

      // Multiple branches (Akra-Bazzi) detection
      if (s.includes(')+T(') && s.includes('n/')) {
        const parts = s.split('=')[1];
        if (parts) {
          // Extract terms more carefully
          const terms = parts.split('+').filter(t => t.includes('T('));
          const branches = [];
          
          for (const term of terms) {
            const m = term.match(/^([0-9]*\.?[0-9]+)?T\(n\/([0-9]+)\)$/);
            if (m) { 
              branches.push({ 
                a: m[1] ? parseFloat(m[1]) : 1, 
                b: parseFloat(m[2]) 
              }); 
            }
          }
          
          if (branches.length >= 2) {
            this.parsed.form = 'Σ a_i T(n/b_i) + g(n)';
            this.parsed.branches = branches;
            
            // Solve p from sum a_i * (1/b_i)^p = 1
            let p = this.solveP(branches);
            this.parsed.p = p.toFixed(4);
            this.method = 'Akra–Bazzi';
            this.confidence = 'high';
            
            const remaining = parts.split('+').filter(t => !t.includes('T(')).join('+');
            this.parsed.f = remaining || 'n';
            
            this.verdict = `Balance: $\\sum a_i b_i^{p}=1$ with $p\\approx ${this.parsed.p}$. Use integral classification on $g(n)$.`;
            this.renderLatex(`$T(n)=\\sum a_i T(n/b_i)+g(n)$ → $p$ solves $\\sum a_i b_i^p=1$.`);
            this.triggerMathJax();
            return;
          }
        }
      }

      if (master) {
        const a = parseFloat(master[1]);
        const b = parseFloat(master[2]);
        const f = master[3];
        const p = Math.log(a) / Math.log(b);
        
        this.parsed = { 
          form: 'a T(n/b) + f(n)', 
          a, b, 
          p: p.toFixed(4), 
          r: null, 
          f, 
          branches: [] 
        };
        this.method = 'Master Theorem';
        this.confidence = 'high';
        this.renderLatex(`$p=\\log_b a\\approx ${p.toFixed(3)}$. Compare $f(n)$ to $n^{${p.toFixed(3)}}$.`);
        this.quickVerdictMaster(f, p);
        this.triggerMathJax();
        return;
      }

      if (subtract) {
        const c = parseFloat(subtract[1]);
        const g = subtract[2];
        this.parsed = { 
          form: 'T(n-c)+g(n)', 
          a: null, b: null, p: null, r: null, 
          f: g, 
          branches: [] 
        };
        this.method = 'Subtractive';
        this.confidence = 'high';
        this.verdict = `Depth $\\approx n/${c}$. $T(n)\\approx const + (1/${c}) \\int_0^n g(u)\\,du$`;
        this.renderLatex(this.verdict);
        this.triggerMathJax();
        return;
      }

      if (ilog) {
        const c = ilog[1];
        this.parsed = { 
          form: 'T(log n)+c', 
          a: null, b: null, p: null, r: null, 
          f: c || '1', 
          branches: [] 
        };
        this.method = 'Iterated Log';
        this.confidence = 'high';
        this.verdict = `Typically $T(n)=\\Theta(\\log^* n)$.`;
        this.renderLatex(this.verdict);
        this.triggerMathJax();
        return;
      }

      if (power) {
        const a = parseFloat(power[1]);
        let r = power[2];
        if (r === '1/2') r = 0.5;
        else r = parseFloat(r);
        const g = power[3];
        
        this.parsed = { 
          form: 'a T(n^r)+g(n)', 
          a, b: null, p: null, 
          r: r.toFixed(3), 
          f: g, 
          branches: [] 
        };
        this.method = 'Power‑shrink';
        this.confidence = 'medium';
        this.verdict = `Depth $O(\\log\\log n)$ for $0<r<1$. Often $T(n)=\\Theta(g(n) \\cdot \\log\\log n)$ if $a$ is modest.`;
        this.renderLatex(this.verdict);
        this.triggerMathJax();
        return;
      }

      if (variableSqrt) {
        const a = variableSqrt[1] ? parseFloat(variableSqrt[1]) : 1;
        const g = variableSqrt[2];
        this.parsed = { 
          form: 'T(√n)+g(n)', 
          a, b: null, p: null, 
          r: '0.5', 
          f: g, 
          branches: [] 
        };
        this.method = 'Variable Change / Power‑shrink';
        this.confidence = 'medium';
        this.verdict = `Let $n=2^{2^k}$, then $S(k)=T(2^{2^k})$ gives linear depth in $k$ → $\\Theta(\\log\\log n)$ layers.`;
        this.renderLatex(this.verdict);
        this.triggerMathJax();
        return;
      }

      // Dominance hint: look for n^n or n! in f(n)
      if (/n\^n|n!/.test(s)) {
        this.method = 'Dominance Analysis';
        this.confidence = 'medium';
        this.verdict = `If $g(n)$ is $n^n$ or $n!$, it typically dominates → $T(n)=\\Theta(g(n))$ (verify).`;
        this.parsed.f = 'super‑exp';
        this.renderLatex(this.verdict);
        this.triggerMathJax();
        return;
      }

      // Fallback: Variable change idea
      this.method = 'Variable Change (try)';
      this.confidence = 'low';
      this.notes = 'Pattern not recognized. Try substitutions: n=2^k, n=2^{2^k}, n=exp(k), or rewrite to match Master/Akra–Bazzi.';
      this.verdict = 'No automatic verdict — inspect manually.';
    },
    
    branchList() {
      if (!this.parsed.branches || !this.parsed.branches.length) return '';
      return this.parsed.branches.map((b, i) => 
        `<div>Branch ${i+1}: a=${b.a}, b=${b.b}</div>`
      ).join('');
    },
    
    solveP(branches) {
      // Solve sum a_i * (1/b_i)^p = 1 using binary search
      let lo = -10, hi = 10;
      for (let iter = 0; iter < 100; iter++) {
        const mid = (lo + hi) / 2;
        const val = branches.reduce((s, br) => 
          s + br.a * Math.pow(1 / br.b, mid), 0
        );
        if (Math.abs(val - 1) < 1e-8) break;
        if (val > 1) {
          lo = mid;
        } else {
          hi = mid;
        }
      }
      return (lo + hi) / 2;
    },
    
    renderLatex(html) {
      this.rendered = `<div>${html}</div>`;
    },
    
    triggerMathJax() {
      // Use Alpine's $nextTick if available, otherwise setTimeout
      if (this.$nextTick) {
        this.$nextTick(() => {
          if (window.MathJax) {
            MathJax.typesetPromise();
          }
        });
      } else {
        setTimeout(() => {
          if (window.MathJax) {
            MathJax.typesetPromise();
          }
        }, 0);
      }
    },
    
    // Heuristic Master theorem verdict
    quickVerdictMaster(f, p) {
      const clean = f.replace(/\s+/g, '');
      const poly = clean.match(/^n\^([0-9]*\.?[0-9]+)$/);
      const polylog = clean.match(/^n\^?([0-9]*\.?[0-9]+)?log\^?([0-9]+)?n$/);
      const justlog = clean.match(/^log\^?([0-9]+)?n$/);
      const justN = clean.match(/^n$/);
      
      if (justN) {
        // f(n) = n, compare with n^p
        if (1 < p - 0.01) {
          this.verdict = `Case 1: $f(n)=n=O(n^{${p.toFixed(3)}-\\epsilon})$ → $T(n)=\\Theta(n^{${p.toFixed(3)}})$`;
        } else if (Math.abs(1 - p) < 0.01) {
          this.verdict = `Case 2: $f(n)=n=\\Theta(n^{p})$ → $T(n)=\\Theta(n\\log n)$`;
        } else {
          this.verdict = `Case 3: $f(n)=n=\\Omega(n^{${p.toFixed(3)}+\\epsilon})$ → likely $T(n)=\\Theta(n)$ (check regularity)`;
        }
        return;
      }
      
      if (poly) {
        const k = parseFloat(poly[1]);
        if (k < p - 0.01) {
          this.verdict = `Case 1: $f(n)=O(n^{${k}})$ with $k<p$ → $T(n)=\\Theta(n^{${p.toFixed(3)}})$`;
        } else if (Math.abs(k - p) < 0.01) {
          this.verdict = `Case 2: $f(n)=\\Theta(n^{p})$ → $T(n)=\\Theta(n^{p} \\log n)$`;
        } else {
          this.verdict = `Case 3: $f(n)=\\Omega(n^{${k}})$ with $k>p$ → likely $T(n)=\\Theta(f(n))$ (check regularity)`;
        }
        return;
      }
      
      if (polylog) {
        const k = polylog[1] ? parseFloat(polylog[1]) : 1;
        const m = parseInt(polylog[2] || '1');
        if (k < p - 0.01) {
          this.verdict = `Case 1: $f(n)=O(n^{${k}}\\log^{${m}} n)$ with $k<p$ → $T(n)=\\Theta(n^{${p.toFixed(3)}})$`;
        } else if (Math.abs(k - p) < 0.01) {
          this.verdict = `Case 2: $f(n)=\\Theta(n^{p}\\log^{${m}} n)$ → $T(n)=\\Theta(n^{p}\\log^{${m+1}} n)$`;
        } else {
          this.verdict = `Case 3: $f(n)=\\Omega(n^{${k}}\\log^{${m}} n)$ → likely $T(n)=\\Theta(f(n))$ (check regularity)`;
        }
        return;
      }
      
      if (justlog) {
        const m = parseInt(justlog[1] || '1');
        this.verdict = `Since $f(n)=\\log^{${m}} n$ grows slower than any $n^{\\epsilon}$ for $\\epsilon>0$, expect Case 1 → $\\Theta(n^{${p.toFixed(3)}})$.`;
        return;
      }
      
      this.caveats = 'f(n) parsing is limited; compare against n^{log_b a} manually (see guide).';
      this.verdict = 'Undetermined — inspect $f(n)$ vs. $n^{p}$ manually.';
    }
  }
}
  </script>
</body>
</html>