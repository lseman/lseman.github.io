<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Recurrence Wizard</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      chtml: {
        // disable MathJax linebreaking entirely
        linebreaks: { automatic: false },
        matchFontHeight: true
      },
      options: {
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      }
    };
  </script>
  <!-- Use CHTML instead of SVG -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>


  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- D3.js for tree layout -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

  <!-- Alpine.js -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

  <style>
    /* Recursion Tree sketch styles */
    .tree-node {
      fill: #fff;
      stroke: #cbd5e1;
      /* slate-300 */
      stroke-width: 1.2px;
      rx: 10;
      ry: 10;
      filter: drop-shadow(0 1px 1px rgba(2, 6, 23, 0.06));
    }

    .tree-label {
      font-size: 12px;
      fill: #0f172a;
      /* slate-900 */
    }

    .tree-sub {
      font-size: 11px;
      fill: #475569;
      /* slate-600 */
    }

    .tree-link {
      stroke: #e2e8f0;
      /* slate-200 */
      stroke-width: 1.2px;
    }


    :root {
      color-scheme: light;
    }

    html {
      scroll-behavior: smooth;
    }

    /* subtle animated gradient */
    .bg-hero {
      background: linear-gradient(120deg, #eef2ff, #f0fdf4, #ecfeff);
      background-size: 200% 200%;
      animation: grad 18s ease infinite;
    }

    @keyframes grad {
      0% {
        background-position: 0% 50%
      }

      50% {
        background-position: 100% 50%
      }

      100% {
        background-position: 0% 50%
      }
    }

    .code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Prevent inline MathJax from breaking across lines */
    mjx-container[display="inline"] {
      white-space: nowrap;
    }

    /* Make long lines with inline math still usable on small screens */
    .math-nowrap {
      white-space: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* Optional: keep display equations blocky and not wrapped */
    mjx-container[display="true"] {
      display: block;
      overflow-x: auto;
      /* in case a wide display equation exceeds container */
    }
  </style>
</head>

<body class="min-h-screen text-slate-800">
  <!-- Hero -->
  <header class="bg-hero">
    <div class="max-w-7xl mx-auto px-6 py-14 lg:py-20">
      <div class="flex flex-col lg:flex-row items-center gap-10">
        <div class="flex-1">
          <img src="logo.png" alt="Recurrence Wizard Logo" class="mx-auto mb-6 w-32 h-32">

          <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900">
            The <span class="text-indigo-600">Recurrence Wizard</span> — UFSC
          </h1>
          <p class="mt-4 text-lg md:text-xl text-slate-700">The wizard aids to help students <span
              class="font-semibold">discover the best method</span> for their recurrence: Master Theorem, Akra–Bazzi,
            Subtractive, Power‑shrink, Iterated Log, Dominance, and Variable Change.</p>
          <div class="mt-6 flex flex-wrap gap-3">
            <a href="#wizard"
              class="px-5 py-3 rounded-xl bg-indigo-600 text-white font-semibold shadow hover:bg-indigo-700">Start the
              Method Recommender</a>
            <a href="#guide"
              class="px-5 py-3 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50">Read
              the Illustrated Guide</a>
          </div>
          <p class="mt-6 text-sm text-slate-500">Built with vanilla JS, Tailwind, Alpine.js, MathJax, and Chart.js — no
            React.</p>
          <p class="mt-6 text-sm text-slate-500">Prof. Laio Oriel Seman, Dr.</p>

        </div>
        <div class="flex-1 w-full">
          <div class="bg-white/70 backdrop-blur rounded-2xl p-6 shadow border border-slate-100">
            <canvas id="complexityChart" height="220"></canvas>
            <p class="mt-3 text-center text-sm text-slate-600">Relative growth landscape: $1 < \log^*n < \log\log n <
                \log n < n < n\log n < n^2 < 2^n < n! < n^n$</p>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Method Recommender Wizard -->
  <section id="wizard" class="py-14">
    <div class="max-w-7xl mx-auto px-6" x-data="recurrenceWizard()" x-init="init()">
      <div class="mb-8">
        <h2 class="text-3xl font-bold tracking-tight text-slate-900">Method Recommender</h2>
        <p class="mt-2 text-slate-600">Paste your recurrence, and we'll suggest a method with reasoning. This is a
          heuristic helper — always verify with the formal criteria below.</p>
      </div>

      <div class="grid lg:grid-cols-3 gap-6">
        <!-- Input -->
        <div class="lg:col-span-2">
          <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
            <label class="block text-sm font-semibold text-slate-700" for="recurrence">Recurrence</label>
            <textarea id="recurrence" x-model="input" @input.debounce.300ms="analyze()"
              placeholder="Examples: T(n)=2T(n/2)+n,   T(n)=T(n-1)+n,   T(n)=3T(n/4)+n log n,   T(n)=T(√n)+1,   T(n)=T(log n)+1,   T(n)=T(n^0.6)+n^2"
              class="mt-2 w-full h-28 code rounded-xl border-slate-300 focus:ring-2 focus:ring-indigo-500"></textarea>

            <div class="mt-3 flex flex-wrap gap-2 text-sm">
              <button @click="setExample('master1')"
                class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">2T(n/2)+n</button>
              <button @click="setExample('master2')"
                class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">3T(n/4)+n log n</button>
              <button @click="setExample('akra')"
                class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=T(n/2)+T(n/3)+n</button>
              <button @click="setExample('sub')"
                class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=T(n-1)+n</button>
              <button @click="setExample('power')"
                class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=2T(√n)+log n</button>
              <button @click="setExample('ilog')"
                class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=T(log n)+1</button>
              <button @click="setExample('dom')" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200">T(n)=2^n
                T(n/2)+n^n</button>
            </div>
          </div>
        </div>

        <!-- Output / Recommendation -->
        <div class="lg:col-span-1">
          <div class="bg-white rounded-2xl shadow p-5 border border-slate-200 min-h-[16rem]">
            <h3 class="text-lg font-semibold text-slate-800">Suggested Method</h3>
            <p class="mt-1 text-xs text-slate-500">Heuristic classification based on structure.</p>
            <div class="mt-3">
              <div class="flex items-center gap-2">
                <div :class="methodPillClass"
                  class="px-2.5 py-1 rounded-full text-xs font-semibold uppercase tracking-wide" x-text="method"></div>
                <span class="text-xs text-slate-500" x-show="confidence" x-text="'Confidence: ' + confidence"></span>
              </div>
              <div class="mt-3 text-sm" x-html="rendered"></div>
              <div class="mt-3 text-sm" x-html="derivation"></div>
              <div class="mt-3 text-xs text-slate-500" x-show="notes" x-text="notes"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Parsed parameters -->
      <div class="mt-6 grid md:grid-cols-2 gap-6">
        <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
          <h4 class="font-semibold text-slate-800">Parsed Structure</h4>
          <table class="mt-3 w-full text-sm">
            <tbody class="divide-y divide-slate-100">
              <tr>
                <td class="py-2 text-slate-500">Form</td>
                <td class="py-2 code" x-text="parsed.form"></td>
              </tr>
              <tr x-show="parsed.a !== null">
                <td class="py-2 text-slate-500">a</td>
                <td class="py-2 code" x-text="parsed.a"></td>
              </tr>
              <tr x-show="parsed.b !== null">
                <td class="py-2 text-slate-500">b</td>
                <td class="py-2 code" x-text="parsed.b"></td>
              </tr>
              <tr x-show="parsed.p !== null">
                <td class="py-2 text-slate-500">p = log_b a</td>
                <td class="py-2 code" x-text="parsed.p"></td>
              </tr>
              <tr x-show="parsed.r !== null">
                <td class="py-2 text-slate-500">r (power shrink)</td>
                <td class="py-2 code" x-text="parsed.r"></td>
              </tr>
              <tr x-show="parsed.branches && parsed.branches.length">
                <td class="py-2 text-slate-500 align-top">Branches (Akra–Bazzi)</td>
                <td class="py-2 code">
                  <div class="space-y-1" x-html="branchList()"></div>
                </td>
              </tr>
              <tr>
                <td class="py-2 text-slate-500">f(n)/g(n)</td>
                <td class="py-2 code" x-text="`$${parsed.f}$`"></td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="bg-white rounded-2xl shadow p-5 border border-slate-200">
          <h4 class="font-semibold text-slate-800">Quick Verdict (asymptotic pattern)</h4>
          <p class="mt-2 text-sm" x-html="verdict"></p>
          <div class="mt-3 text-sm" x-html="levelTableHTML"></div>

          <div class="mt-3 text-xs text-slate-500" x-show="caveats" x-text="caveats"></div>
        </div>
      </div>

    </div>

    <!-- Recursion Tree Sketch -->
    <section id="tree" class="py-14" x-data="recurrenceWizard()" x-init="init()">
      <div class="max-w-7xl mx-auto px-6">
        <div class="mb-6 flex items-center justify-between">
          <div>
            <h2 class="text-3xl font-bold tracking-tight text-slate-900">Recursion Tree Sketch</h2>
            <p class="mt-1 text-slate-600 text-sm">
              Visual sketch of the generated recursion: branching, split sizes, and per-level work.
            </p>
          </div>
          <div class="flex items-center gap-3">
            <label class="text-sm text-slate-600">Depth</label>
            <input x-model.number="treeDepth" type="range" min="2" max="8" step="1" class="w-36 accent-indigo-600"
              @input="updateTree()" />
            <span class="text-sm text-slate-700 w-6 text-right" x-text="treeDepth"></span>
          </div>
        </div>

        <div class="bg-white rounded-2xl shadow p-4 border border-slate-200">
          <div class="flex flex-wrap gap-3 text-xs text-slate-600 mb-3">

            <template x-if="parsed.branches && parsed.branches.length">
              <span class="px-2 py-1 rounded-full bg-amber-50 text-amber-800"
                x-text="'branches='+parsed.branches.length"></span>
            </template>
          </div>
          <div class="overflow-x-auto">
            <svg id="recursionTree" class="w-full min-w-[720px]" style="height: 420px;"></svg>
          </div>
          <p class="mt-3 text-xs text-slate-500">
            Labels: <span class="font-mono">size</span> of subproblem (e.g., <span class="font-mono">n/b</span>, <span
              class="font-mono">αn</span>, <span class="font-mono">n−c</span>)
            and per-node work from <span class="font-mono">g(n)</span> (when easily inferred).
          </p>
        </div>
      </div>
    </section>



    <!-- Illustrated Guide -->
    <section id="guide" class="py-14 bg-slate-50">
      <div class="max-w-7xl mx-auto px-6">
        <div class="mb-10">
          <h2 class="text-3xl font-bold tracking-tight text-slate-900">Illustrated Guide to Solving Recurrence Relations
          </h2>
          <p class="mt-2 text-slate-600">Explore common recurrence relation patterns with intuitive explanations,
            formulas, and examples. Click a card to reveal detailed steps and insights.</p>
        </div>
        <div class="grid lg:grid-cols-2 gap-6">
          <!-- Master Theorem -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">1) Master Theorem</h3>
                <p class="text-slate-600 text-sm mt-1">Solves recurrences of the form $T(n) = aT(n/b) + f(n)$ by
                  comparing $f(n)$ to $n^{\log_b a}$.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> Imagine a recursion tree where each node splits into $a$ subproblems, each
                of size $n/b$. The term $f(n)$ represents the work done at each level. The threshold $n^{\log_b a}$
                determines whether the recursive cost or $f(n)$ dominates.</p>
              <p class="mt-2"><strong>Formula.</strong> For $T(n) = aT(n/b) + f(n)$:</p>
              <ul class="list-disc pl-5 mt-2">
                <li><strong>Case 1:</strong> If $f(n) = O(n^{\log_b a - \epsilon})$ for some $\epsilon > 0$, then $T(n)
                  = \Theta(n^{\log_b a})$.</li>
                <li><strong>Case 2:</strong> If $f(n) = \Theta(n^{\log_b a} \log^k n)$, then $T(n) = \Theta(n^{\log_b a}
                  \log^{k+1} n)$.</li>
                <li><strong>Case 3:</strong> If $f(n) = \Omega(n^{\log_b a + \epsilon})$ and $af(n/b) \leq c f(n)$ for
                  some $c < 1$, then $T(n)=\Theta(f(n))$.</li>
              </ul>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = 4T(n/2) + n$ (e.g., merge sort with linear work):
              </p>
              <ul class="list-disc pl-5 mt-1">
                <li>Here, $a=4$, $b=2$, so $\log_b a = \log_2 4 = 2$. Compare $f(n) = n$ to $n^2$.</li>
                <li>Since $n = O(n^{2 - \epsilon})$, Case 1 applies: $T(n) = \Theta(n^2)$.</li>
              </ul>
            </div>
          </article>
          <!-- Akra–Bazzi -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">2) Akra–Bazzi Method</h3>
                <p class="text-slate-600 text-sm mt-1">Generalizes Master Theorem for $T(n) = \sum a_i T(b_i n) + g(n)$
                  by solving $\sum a_i b_i^p = 1$.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> Handles recurrences with unequal splits (e.g., different $b_i$). The
                exponent $p$ balances the recursive terms, and the integral accounts for the non-recursive work $g(n)$.
              </p>
              <p class="mt-2"><strong>Formula.</strong> Solve for $p$ where $\sum a_i b_i^p = 1$. Then: $$T(n) =
                \Theta\left(n^p \left(1 + \int_1^n \frac{g(u)}{u^{p+1}}\,du\right)\right).$$</p>
              <p class="mt-2"><strong>When to Use.</strong> Use when branches have different sizes or Master Theorem
                fails.</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = T(n/3) + T(2n/3) + n$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Solve $(1/3)^p + (2/3)^p = 1$ to find $p \approx 1$.</li>
                <li>Compute integral: $\int_1^n \frac{u}{u^2}\,du = \ln n$.</li>
                <li>Thus, $T(n) = \Theta(n \cdot (1 + \ln n)) = \Theta(n \log n)$.</li>
              </ul>
            </div>
          </article>
          <!-- Subtractive -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">3) Subtractive Recurrence</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = T(n-c) + g(n)$ approximates to $T(n) \approx \text{const}
                  + \frac{1}{c} \int_0^n g(u) \, du$.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> Each recursive call reduces the problem size by a fixed $c$, forming a
                linear chain of depth $\approx n/c$. The solution accumulates $g(n)$ over these steps.</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = T(n-1) + n$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Unroll: $T(n) = T(n-1) + n = T(n-2) + (n-1) + n = \cdots = T(0) + \sum_{k=1}^n k$.</li>
                <li>Summation: $\sum_{k=1}^n k = \frac{n(n+1)}{2}$, so $T(n) = \Theta(n^2)$.</li>
              </ul>
              <p class="mt-2"><strong>When to Use.</strong> Ideal for algorithms that "peel off" a fixed amount each
                step, like linear search with decrements.</p>
            </div>
          </article>
          <!-- Power-shrink -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">4) Power-Shrink Recurrence</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = a T(n^r) + g(n)$, with depth $O(\log \log n)$ for $0 < r
                    < 1$.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> The problem size shrinks exponentially (e.g., $n^{1/2}$), leading to a very
                shallow recursion tree.</p>
              <p class="mt-2"><strong>Method.</strong> Use substitution like $n = 2^{2^k}$ for $r = 1/2$ to transform
                into a linear recurrence in $k$.</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = T(\sqrt{n}) + 1$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Let $n = 2^k$, so $T(2^k) = T(2^{k/2}) + 1$.</li>
                <li>Define $S(k) = T(2^k)$, then $S(k) = S(k/2) + 1$.</li>
                <li>Solve $S(k) = \Theta(\log k)$, so $T(n) = \Theta(\log \log n)$.</li>
              </ul>
            </div>
          </article>
          <!-- Iterated Log -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">5) Iterated Log Recurrence</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = T(\log n) + O(1) \Rightarrow T(n) = \Theta(\log^* n)$.
                </p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> The problem size shrinks logarithmically each step, and $\log^* n$
                (iterated logarithm) counts how many times you can take $\log n$ until $n \leq 1$. It grows extremely
                slowly (e.g., $\log^* n \leq 5$ for practical $n$).</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = T(\log n) + 1$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Each step reduces $n$ to $\log n$, then $\log \log n$, etc.</li>
                <li>The depth is $\log^* n$, so $T(n) = \Theta(\log^* n)$.</li>
              </ul>
            </div>
          </article>
          <!-- Dominance -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">6) Dominance Analysis</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = \Theta(g(n))$ when $g(n)$ dominates recursive terms.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> If the non-recursive work $g(n)$ grows much faster than the recursive
                terms, it dictates the overall runtime.</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = 2T(n/2) + n^n$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Recursive part: $2T(n/2) = \Theta(n \log n)$ (Master Theorem, Case 2).</li>
                <li>Since $n^n \gg n \log n$, $T(n) = \Theta(n^n)$.</li>
              </ul>
            </div>
          </article>
          <!-- Variable Change -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">7) Variable Change</h3>
                <p class="text-slate-600 text-sm mt-1">Transform $n = h(k)$ (e.g., $\sqrt{n}$, $\log n$, $2^k$) to
                  simplify recurrences.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> Change the variable to make the recurrence easier to solve, then
                back-substitute to get $T(n)$.</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = T(\sqrt{n}) + n$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Let $n = 2^k$, so $T(2^k) = T(2^{k/2}) + 2^k$.</li>
                <li>Define $S(k) = T(2^k)$, then $S(k) = S(k/2) + 2^k$.</li>
                <li>Solve $S(k) = \Theta(2^k)$, so $T(n) = \Theta(n)$.</li>
              </ul>
            </div>
          </article>
          <!-- Linear Homogeneous -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">8) Linear Homogeneous (Characteristic Equation)</h3>
                <p class="text-slate-600 text-sm mt-1">For $T(n) = \sum_{i=1}^k a_i T(n-i) + g(n)$, solve via
                  characteristic polynomial.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> The homogeneous part gives the growth rate via roots of a polynomial, and
                $g(n)$ adds a particular solution.</p>
              <p class="mt-2"><strong>Method.</strong> Solve $\lambda^k = a_1 \lambda^{k-1} + \cdots + a_k$. If roots
                $\lambda_i$ are distinct, $T_h(n) = \sum c_i \lambda_i^n$. Add particular solution for $g(n)$.</p>
              <p class="mt-2"><strong>Example.</strong> Fibonacci: $T(n) = T(n-1) + T(n-2)$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Characteristic equation: $\lambda^2 = \lambda + 1 \Rightarrow \lambda = \frac{1 \pm \sqrt{5}}{2}$.
                </li>
                <li>Solution: $T(n) = c_1 \left(\frac{1+\sqrt{5}}{2}\right)^n + c_2 \left(\frac{1-\sqrt{5}}{2}\right)^n
                  = \Theta(\varphi^n)$, where $\varphi = \frac{1+\sqrt{5}}{2}$.</li>
              </ul>
            </div>
          </article>
          <!-- Unequal Splits -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">9) Unequal Splits (Akra–Bazzi)</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = T(\alpha n) + T((1-\alpha)n) + f(n)$, with $0 < \alpha <
                    1$.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> Handles recurrences with uneven splits, like Quicksort’s average case.</p>
              <p class="mt-2"><strong>Formula.</strong> Find $p$ such that $\alpha^p + (1-\alpha)^p = 1$. Then: $$T(n) =
                \Theta\left(n^p \left(1 + \int_1^n \frac{f(u)}{u^{p+1}}\,du\right)\right).$$</p>
              <p class="mt-2"><strong>Example.</strong> Quicksort: $T(n) = T(n/2) + T(n/2) + \Theta(n)$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>For $\alpha = 1/2$, solve $(1/2)^p + (1/2)^p = 2 \cdot (1/2)^p = 1 \Rightarrow p = 1$.</li>
                <li>Integral: $\int_1^n \frac{u}{u^2}\,du = \ln n$.</li>
                <li>Thus, $T(n) = \Theta(n \log n)$.</li>
              </ul>
            </div>
          </article>
          <!-- Factorial Growth -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">10) Factorial Growth</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = n T(n-1) + g(n)$ typically yields $\Theta(n!)$ up to
                  factors from $g(n)$.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> Each step multiplies the previous result by $n$, leading to factorial
                growth.</p>
              <p class="mt-2"><strong>Formula.</strong> Unroll: $$T(n) = n(n-1)\cdots 1 T(0) + \sum_{k=1}^n
                \left(n(n-1)\cdots(k+1)\right) g(k).$$</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = n T(n-1) + 1$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Unroll: $T(n) = n! T(0) + n! \sum_{k=1}^n \frac{1}{k!}$.</li>
                <li>The sum $\sum_{k=1}^n \frac{1}{k!} \approx e$, so $T(n) = \Theta(n!)$.</li>
              </ul>
              <p class="mt-2">Use Stirling’s approximation ($n! \approx \sqrt{2\pi n} (n/e)^n$) for precise asymptotics.
              </p>
            </div>
          </article>
          <!-- Full Recurrence -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">11) Full (Cumulative) Recurrence</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = \sum_{i=1}^{n-1} T(i) + g(n)$ often yields $\Theta(2^n)$.
                </p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> Summing all previous $T(i)$ creates exponential growth due to the
                cumulative effect.</p>
              <p class="mt-2"><strong>Method.</strong> Use difference: $T(n) - T(n-1) = \sum_{i=1}^{n-1} T(i-1) + g(n) -
                g(n-1)$, or guess $T(n) = \Theta(2^n)$ and verify.</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = \sum_{i=1}^{n-1} T(i) + 1$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Difference: $T(n) - T(n-1) = T(n-1) + 1 \Rightarrow T(n) = 2T(n-1) + 1$.</li>
                <li>Solve to get $T(n) = \Theta(2^n)$.</li>
              </ul>
            </div>
          </article>
          <!-- Nested Recurrences -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">12) Nested Recurrences</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = T(T(n/2)) + g(n)$ requires iterative bounding.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> The inner $T(n/2)$ makes this tricky; bound the inner term and iterate.</p>
              <p class="mt-2"><strong>Method.</strong> Assume $T(n) \leq h(n)$, substitute, and refine bounds.
                Alternatively, use a change of variables like $n = 2^{2^k}$.</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = T(T(n/2)) + 1$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Bound $T(n/2) \leq c \log n$, so $T(n) \leq T(c \log n) + 1$.</li>
                <li>Iterate or use problem-specific analysis to approximate growth.</li>
              </ul>
            </div>
          </article>
          <!-- Exponential Step -->
          <article x-data="{open:false}"
            class="bg-white border border-slate-200 rounded-2xl p-6 shadow hover:shadow-md transition-shadow">
            <header class="flex items-start justify-between cursor-pointer"
              @click="open=!open; $nextTick(() => MathJax.typesetPromise())">
              <div>
                <h3 class="text-xl font-semibold">13) Exponential Step</h3>
                <p class="text-slate-600 text-sm mt-1">$T(n) = a T(n-1) + g(n)$ with $a > 1$ gives $\Theta(a^n)$ plus a
                  particular solution.</p>
              </div>
              <span class="text-slate-500 text-sm" x-text="open ? 'Hide' : 'Show'"></span>
            </header>
            <div x-show="open" x-transition class="mt-4 text-sm leading-7">
              <p><strong>Intuition.</strong> The factor $a > 1$ amplifies each step, leading to exponential growth.</p>
              <p class="mt-2"><strong>Formula.</strong> Homogeneous solution: $T_h(n) = C a^n$. Full solution: $$T(n) =
                a^n \left(C + \sum_{k=1}^n \frac{g(k)}{a^k}\right).$$</p>
              <p class="mt-2"><strong>Example.</strong> For $T(n) = 2 T(n-1) + n$:</p>
              <ul class="list-disc pl-5 mt-1">
                <li>Homogeneous: $T_h(n) = C \cdot 2^n$.</li>
                <li>Particular solution: Sum $\sum_{k=1}^n \frac{k}{2^k} \approx 2$, so $T(n) = \Theta(2^n)$.</li>
              </ul>
            </div>
          </article>
        </div>
      </div>
    </section>

    <!-- Comparison Table -->
    <section class="py-14">
      <div class="max-w-7xl mx-auto px-6">
        <h2 class="text-3xl font-bold tracking-tight text-slate-900">Method Selection Cheat-Sheet</h2>

        <div class="mt-4 overflow-x-auto bg-white rounded-2xl shadow border border-slate-200">
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50 text-slate-600">
              <tr class="[&>th]:text-left [&>th]:p-3 [&>th]:font-semibold">
                <th>Pattern</th>
                <th>Best Method</th>
                <th>Complexity Pattern</th>
                <th>Insight</th>
              </tr>
            </thead>

            <tbody class="divide-y divide-slate-100 [&_td.code]:font-mono [&_td.code]:text-xs [&_td]:align-top">
              <!-- Master Theorem -->
              <tr>
                <td class="p-3 code">T(n)=aT(n/b)+f(n)</td>
                <td class="p-3">Master</td>
                <td class="p-3">
                  Case 1: $Θ(n^p)$; Case 2: $Θ(n^p\log n)$; Case 3: $Θ(f(n))$
                </td>
                <td class="p-3">Compare $f(n)$ to $n^{p}$ with $p=\log_b a$; regularity for Case 3.</td>
              </tr>

              <!-- Extended Master boundary cases -->
              <tr>
                <td class="p-3 code">f(n)=Θ(n^p \log^k n)</td>
                <td class="p-3">Extended Master</td>
                <td class="p-3">$T(n)=Θ\!\big(n^p\log^{k+1} n\big)$</td>
                <td class="p-3">“Exactly-on-threshold” adds one log power.</td>
              </tr>
              <tr>
                <td class="p-3 code">f(n)=Θ\!\big(n^p / \log^k n\big)</td>
                <td class="p-3">Extended Master</td>
                <td class="p-3">
                  $T(n)=Θ\!\big(n^p \log^{1-k} n\big)$ &nbsp;(e.g. $n/\log n \Rightarrow Θ(n\log\log n)$)
                </td>
                <td class="p-3">“Slightly below threshold” reduces a log power (special $k{=}1$ gives $\log\log n$).
                </td>
              </tr>

              <!-- Akra–Bazzi (general) -->
              <tr>
                <td class="p-3 code">T(n)=\sum a_i T(b_i n)+g(n)</td>
                <td class="p-3">Akra–Bazzi</td>
                <td class="p-3">$Θ\!\Big(n^p\big(1+\int_1^n \frac{g(u)}{u^{p+1}}\,du\big)\Big)$</td>
                <td class="p-3">Find $p$ via $\sum a_i b_i^p=1$; handles unequal splits.</td>
              </tr>

              <!-- Unequal split (Quicksort-style) -->
              <tr>
                <td class="p-3 code">T(n)=T(\alpha n)+T((1-\alpha)n)+f(n)</td>
                <td class="p-3">Akra–Bazzi (weighted)</td>
                <td class="p-3">
                  $p$ solves $\alpha^p+(1-\alpha)^p=1$;
                  with $f(n)=Θ(n)$ ⇒ $Θ(n\log n)$
                </td>
                <td class="p-3">Quicksort‐like; Master doesn’t fit due to unequal branch sizes.</td>
              </tr>

              <!-- Subtractive -->
              <tr>
                <td class="p-3 code">T(n)=T(n-c)+g(n)</td>
                <td class="p-3">Subtractive</td>
                <td class="p-3">$Θ\!\Big(\sum_{i\le n} g(i)\Big)$ or $Θ\!\big(\int_0^n g(u)\,du\big)$</td>
                <td class="p-3">Depth ≈ $n/c$; telescopes by unrolling.</td>
              </tr>

              <!-- Power-shrink -->
              <tr>
                <td class="p-3 code">T(n)=a(n)T(n^r)+g(n),\ 0&lt;r&lt;1</td>
                <td class="p-3">Power-shrink</td>
                <td class="p-3">Often $Θ\!\big(g(n)\log\log n\big)$</td>
                <td class="p-3">Depth $Θ(\log\log n)$; try $n=2^{2^k}$ substitution.</td>
              </tr>

              <!-- Iterated log -->
              <tr>
                <td class="p-3 code">T(n)=T(\log n)+O(1)</td>
                <td class="p-3">Iterated log</td>
                <td class="p-3">$Θ(\log^* n)$</td>
                <td class="p-3">Extremely slow shrink; $\log^* n\le5$ in practice.</td>
              </tr>

              <!-- Dominance -->
              <tr>
                <td class="p-3 code">super-exp g(n)\ (e.g.\ n!,\ n^n)</td>
                <td class="p-3">Dominance</td>
                <td class="p-3">$Θ(g(n))$ if recursion is asymptotically smaller</td>
                <td class="p-3">Work term dwarfs the recursion tree.</td>
              </tr>

              <!-- Variable change -->
              <tr>
                <td class="p-3 code">“weird” argument (sqrt, logs, towers)</td>
                <td class="p-3">Variable change</td>
                <td class="p-3">Depends on substitution</td>
                <td class="p-3">Linearize via $n=h(k)$ then solve in $k$; back-substitute.</td>
              </tr>

              <!-- Linear homogeneous / characteristic -->
              <tr>
                <td class="p-3 code">T(n)=\sum_{j=1}^k a_j T(n-j)+g(n)</td>
                <td class="p-3">Characteristic Eq. (+ particular)</td>
                <td class="p-3">$Θ(\lambda_{\max}^n)$ for homogeneous; add particular from $g$</td>
                <td class="p-3">Solve $\lambda^k=a_1\lambda^{k-1}+\cdots+a_k$; Fibonacci is the classic case.</td>
              </tr>

              <!-- Exponential step -->
              <tr>
                <td class="p-3 code">T(n)=a\,T(n-1)+g(n),\ a&gt;1</td>
                <td class="p-3">Homogeneous + summation</td>
                <td class="p-3">$Θ(a^n)$ (plus contribution of $\sum g(k)/a^k$)</td>
                <td class="p-3">Unroll and compare series to $a^n$.</td>
              </tr>

              <!-- Factorial -->
              <tr>
                <td class="p-3 code">T(n)=n\,T(n-1)+g(n)</td>
                <td class="p-3">Unroll / product form</td>
                <td class="p-3">$Θ(n!)$ (up to factors from $g$)</td>
                <td class="p-3">Use Stirling for asymptotics; super-polynomial blow-up.</td>
              </tr>

              <!-- Full (cumulative) -->
              <tr>
                <td class="p-3 code">T(n)=\sum_{i=1}^{n-1} T(i)+g(n)</td>
                <td class="p-3">Cumulative / difference trick</td>
                <td class="p-3">Often $Θ(2^n)$ if $g$ is poly/log</td>
                <td class="p-3">Past terms dominate; check $T(n)-T(n-1)$.</td>
              </tr>

              <!-- Nested -->
              <tr>
                <td class="p-3 code">T(n)=T(T(n/2))+g(n)</td>
                <td class="p-3">Bounding & substitution</td>
                <td class="p-3">Problem-dependent</td>
                <td class="p-3">Bound inner $T(\cdot)$, iterate; often needs custom arguments.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Tiny legend -->
        <p class="mt-3 text-xs text-slate-500">
          Here $p=\log_b a$. “Extended Master” rows cover boundary/sub-boundary cases like $f(n)=Θ(n^p \log^k n)$ or
          $Θ(n^p/\log^k n)$.
        </p>
      </div>
    </section>

    <!-- Footer -->
    <footer class="py-10 bg-slate-900 text-slate-200">
      <div class="max-w-7xl mx-auto px-6">
        <div class="flex flex-col md:flex-row items-center justify-between gap-4">
          <p class="text-sm">© <span id="year"></span> Recurrence Wizard — Built for students. Single‑file, no React.
          </p>
          <div class="text-xs text-slate-400">Tailwind • Alpine.js • MathJax • Chart.js</div>
        </div>
      </div>
    </footer>

    <script>
      // Enhanced Recurrence Relations Wizard - Complete Implementation

      // Footer year
      document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('year').textContent = new Date().getFullYear();

        // Initialize MathJax rendering for initial content
        if (window.MathJax) {
          MathJax.typesetPromise();
        }
      });

      // Complexity skyline chart (purely illustrative ordering)
      document.addEventListener('DOMContentLoaded', () => {
        const ctx = document.getElementById('complexityChart');
        if (!ctx) return;
        const data = {
          labels: ['1', 'log* n', 'log log n', 'log n', 'n', 'n log n', 'n^2', '2^n', 'n!', 'n^n'],
          datasets: [{
            label: 'Relative growth (log scale)',
            data: [1, 1.5, 2, 3, 6, 7, 10, 20, 30, 36],
            fill: true,
            tension: 0.3,
            backgroundColor: 'rgba(79, 70, 229, 0.1)',
            borderColor: 'rgba(79, 70, 229, 0.6)',
          }]
        };
        new Chart(ctx, {
          type: 'line',
          data,
          options: {
            responsive: true,
            scales: {
              y: { display: false }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });
      });

      // ---------- Enhanced Heuristic Parser & Recommender ----------

      function recurrenceWizard() {
        return {
          // State for user input and analysis output
          input: '', // User-provided recurrence relation (e.g., "T(n) = 2 T(n/2) + n")
          parsed: {
            form: '-', // Parsed recurrence form
            a: null, // Coefficient for recursive term(s)
            b: null, // Division factor (e.g., n/2 -> b=2)
            p: null, // Critical exponent (log_b a for Master, solved for Akra-Bazzi)
            r: null, // Power for power-shrink (e.g., n^r)
            f: '-', // Non-recursive term f(n) or g(n)
            branches: [], // For Akra-Bazzi: array of {a, b} pairs
            coeffs: [] // For Fibonacci-like: array of coefficients
          },
          method: '—', // Analysis method (e.g., "Master Theorem")
          confidence: 0, // Confidence score for method selection (0 to 0.95)
          confidenceText: '', // Displayable confidence percentage
          notes: '', // Notes for user (e.g., parsing issues)
          verdict: '', // Final complexity result (e.g., "T(n) = Θ(n log n)")
          caveats: '', // Warnings or limitations of analysis
          rendered: '', // LaTeX-rendered output for display
          suggestions: [], // Suggestions for fixing input errors
          treeDepth: 4, // Depth of recursion tree visualization
          derivation: '', // Step-by-step derivation explanation
          levelTableHTML: '', // HTML for recursion tree ledger table

          // CSS class for method display pill (color-coded by method)
          get methodPillClass() {
            const m = this.method.toLowerCase();
            const base = 'text-xs px-2 py-1 rounded-full font-medium';
            const methodStyles = {
              'master': 'bg-indigo-100 text-indigo-700',
              'akra': 'bg-emerald-100 text-emerald-700',
              'subtract': 'bg-amber-100 text-amber-800',
              'power': 'bg-fuchsia-100 text-fuchsia-700',
              'iter': 'bg-sky-100 text-sky-700',
              'dom': 'bg-rose-100 text-rose-700',
              'fibonacci': 'bg-purple-100 text-purple-700',
              'exponential': 'bg-red-100 text-red-700',
              'full': 'bg-orange-100 text-orange-700',
              'nested': 'bg-cyan-100 text-cyan-700',
              'variable': 'bg-slate-100 text-slate-700'
            };
            for (const [key, style] of Object.entries(methodStyles)) {
              if (m.includes(key)) return `${base} ${style}`;
            }
            return `${base} bg-slate-100 text-slate-700`;
          },

          // CSS class for confidence score display
          get confidenceClass() {
            if (this.confidence >= 0.8) return 'text-green-600 font-semibold';
            if (this.confidence >= 0.6) return 'text-yellow-600 font-medium';
            return 'text-red-500 font-medium';
          },

          // Initialize with a default example and set up tree watcher
          init() {
            this.setExample('master1');
            this.$nextTick(() => this.updateTree());
            this.$watch('treeDepth', () => this.updateTree());
          },

          // Load predefined example recurrences for testing
          setExample(which) {
            const examples = {
              master1: 'T(n) = 2 T(n/2) + n', // Merge sort
              master2: 'T(n) = 3 T(n/4) + n log n', // Slower branching
              master3: 'T(n) = 2 T(n/2) + n/log n', // Extended Master case
              akra: 'T(n) = T(n/2) + T(n/3) + n', // Uneven splits
              akra2: 'T(n) = 2 T(n/4) + 3 T(n/8) + n^2', // Multi-branch
              sub: 'T(n) = T(n-1) + n', // Linear reduction
              sub2: 'T(n) = 2 T(n-1) + n', // Exponential with c=2
              fib: 'T(n) = T(n-1) + T(n-2) + n', // Fibonacci with work
              fib2: 'T(n) = T(n-1) + T(n-2) + 1', // Fibonacci with constant
              power: 'T(n) = 2 T(n^(1/2)) + log n', // Power-shrink
              power2: 'T(n) = T(sqrt(n)) + n', // Sqrt reduction
              ilog: 'T(n) = T(log n) + 1', // Iterated logarithm
              factorial: 'T(n) = n T(n-1) + 1', // Factorial growth
              dom: 'T(n) = 2^n T(n/2) + n^n', // Dominance by n^n
              full: 'T(n) = sum(i=1 to n-1) T(i) + n', // Full history
              nested: 'T(n) = T(T(n/2)) + n' // Nested recurrence
            };
            this.input = examples[which] || '';
            this.analyze();
          },

          // Parse coefficient from string (handles '2', '', '-', etc.)
          parseCoefficient(str) {
            if (!str || str.trim() === '' || str.trim() === '+') return 1;
            if (str.trim() === '-') return -1;
            str = str.replace(/^\+\s*/, '').replace(/^\*\s*/, '');
            const num = parseFloat(str.trim());
            return isNaN(num) ? 1 : num;
          },

          // Normalize input for consistent parsing
          normalizeInput(input) {
            return input
              .replace(/\s+/g, ' ') // Collapse multiple spaces
              .replace(/([0-9])\s+(?=T\()/g, '$1*') // Add * before T (e.g., "2 T" -> "2*T")
              .replace(/([+\-])\s+([0-9]+)\s+(?=T\()/g, '$1 $2*') // Handle "+ 2 T"
              .replace(/T\s*\(\s*/g, 'T(') // Normalize T( spacing
              .replace(/\s*\)\s*/g, ')') // Normalize ) spacing
              .replace(/\s*\+\s*/g, '+') // Canonicalize +
              .replace(/\s*-\s*/g, '-') // Canonicalize -
              .replace(/\s*=\s*/g, '=') // Canonicalize =
              .replace(/sqrt\s*\(\s*n\s*\)/gi, 'n^0.5') // Normalize sqrt(n)
              .replace(/n\s+log\s*n/gi, 'n*log n') // Add * for n log n
              .replace(/log\s*n/gi, 'logn') // Normalize log n
              .replace(/ln\s*n/gi, 'logn') // Normalize ln(n)
              .replace(/\*\s*/g, '*') // Clean stray *
              .trim();
          },


          // Analyze non-recursive function f(n) or g(n)
          analyzeFunction(f) {
            if (!f) return { type: 'constant', complexity: 'simple', value: 1, latex: '1' };
            f = f.toLowerCase().replace(/\s+/g, '');
            let mathNode, latex = f;

            // Parse with Math.js for LaTeX rendering
            if (typeof math !== 'undefined') {
              try {
                mathNode = math.parse(f.replace('logn', 'log(n)').replace('loglogn', 'log(log(n))').replace(/n\^([0-9]*\.?[0-9]+)/, 'n^($1)'));
                f = mathNode.toString({ parenthesis: 'keep' });
                latex = mathNode.toTex();
              } catch (e) {
                console.warn('Math.js parse error:', e);
                this.notes = 'Failed to parse f(n) with Math.js. Using string-based analysis.';
              }
            } else {
              this.notes = 'Math.js not available. Using string-based analysis.';
            }

            // Patterns for common function types
            const patterns = {
              constant: /^([0-9]*\.?[0-9]+|1)$/,
              linear: /^([0-9]*\.?[0-9]*)\*?n$/,
              polynomial: /^([0-9]*\.?[0-9]*)\*?n\^([0-9]+\.?[0-9]*)$/,
              polylog: /^([0-9]*\.?[0-9]*)\*?n\^?([0-9]*\.?[0-9]*)\*?log\^?([0-9]+)?\*?n$/,
              logonly: /^([0-9]*\.?[0-9]*)\*?log\^?([0-9]+)?\*?n$/,
              logdiv: /^([0-9]*\.?[0-9]*)\*?n\/log\^?([0-9]+)?n$/,
              loglog: /^([0-9]*\.?[0-9]*)\*?loglogn$/,
              complex: /^([0-9]*\.?[0-9]*)\*?n\^?([0-9]*\.?[0-9]*)\+([0-9]*\.?[0-9]*)\*?n\*?logn$/,
              factorial: /n!/,
              exponential: /(2\^n|e\^n)/,
              superexp: /n\^n/
            };

            for (const [type, pattern] of Object.entries(patterns)) {
              const match = f.match(pattern);
              if (match) {
                const coeff = this.parseCoefficient(match[1]);
                switch (type) {
                  case 'constant':
                    return { type, complexity: 'simple', value: coeff, latex: coeff.toString(), mathNode };
                  case 'linear':
                    return { type, complexity: 'simple', value: coeff, latex: coeff === 1 ? 'n' : `${coeff}n`, mathNode };
                  case 'polynomial':
                    const exp = parseFloat(match[2]);
                    return { type, complexity: 'medium', power: exp, value: coeff, latex: `${coeff === 1 ? '' : coeff}n^{${exp}}`, mathNode };
                  case 'polylog':
                    const base = match[2] ? parseFloat(match[2]) : 1;
                    const logPower = match[3] ? parseInt(match[3]) : 1;
                    return { type, complexity: 'complex', power: base, logPower, value: coeff, latex: `${coeff === 1 ? '' : coeff}n^{${base}}\\log^{${logPower}} n`, mathNode };
                  case 'logonly':
                    const lp = match[2] ? parseInt(match[2]) : 1;
                    return { type, complexity: 'simple', logPower: lp, value: coeff, latex: `${coeff === 1 ? '' : coeff}\\log^{${lp}} n`, mathNode };
                  case 'logdiv':
                    const lp2 = match[2] ? parseInt(match[2]) : 1;
                    return { type, complexity: 'complex', logPower: lp2, value: coeff, latex: `${coeff === 1 ? '' : coeff}\\frac{n}{\\log^{${lp2}} n}`, mathNode };
                  case 'loglog':
                    return { type, complexity: 'complex', value: coeff, latex: `${coeff === 1 ? '' : coeff}\\log \\log n`, mathNode };
                  case 'complex':
                    const c1 = this.parseCoefficient(match[1]);
                    const p1 = parseFloat(match[2]);
                    const c2 = this.parseCoefficient(match[3]);
                    return { type, complexity: 'complex', latex: `${c1 === 1 ? '' : c1}n^{${p1}} + ${c2 === 1 ? '' : c2}n \\log n`, mathNode };
                  default:
                    return { type, complexity: 'high', latex, mathNode };
                }
              }
            }
            return { type: 'unknown', complexity: 'unknown', latex, mathNode, note: 'Complex expression - simplify for better analysis.' };
          },

          // Calculate confidence score for the selected method
          calculateConfidence(method, parsed, fAnalysis) {
            let confidence = 0.5; // Base confidence
            switch (method) {
              case 'Master Theorem':
                if (parsed.a && parsed.b && parsed.p !== null) {
                  confidence = 0.85;
                  if (fAnalysis.complexity === 'simple') confidence += 0.1;
                  if (Math.abs(parsed.p - Math.round(parsed.p)) < 0.001) confidence += 0.05;
                  if (fAnalysis.type === 'complex') confidence -= 0.1;
                }
                break;
              case 'Extended Master Theorem':
                confidence = 0.75;
                if (fAnalysis.type === 'logdiv') confidence += 0.1;
                break;
              case 'Akra–Bazzi':
                if (parsed.branches.length >= 2) {
                  confidence = 0.8;
                  if (parsed.branches.length <= 4) confidence += 0.05;
                  const pVal = this.solveP(parsed.branches);
                  const sum = parsed.branches.reduce((s, br) => s + br.a * Math.pow(1 / br.b, pVal), 0);
                  if (Math.abs(sum - 1) > 1e-6) confidence -= 0.1;
                }
                break;
              case 'Fibonacci-like':
                confidence = 0.8;
                if (fAnalysis.complexity === 'simple') confidence += 0.1;
                if (parsed.coeffs.length === 2) confidence += 0.05;
                break;
              case 'Subtractive':
                confidence = 0.85;
                if (fAnalysis.type === 'complex') confidence -= 0.05;
                break;
              case 'Exponential Growth':
                confidence = 0.9;
                break;
              case 'Power-shrink':
                confidence = 0.7;
                if (parsed.r && parsed.r < 1 && parsed.r > 0) confidence += 0.1;
                break;
              case 'Iterated Log':
                confidence = 0.8;
                if (fAnalysis.type === 'constant') confidence += 0.1;
                break;
              case 'Full Recurrence':
                confidence = 0.6;
                break;
              case 'Nested Recurrence':
                confidence = 0.4;
                break;
              default:
                confidence = 0.3;
            }
            if (method.includes('Master') && parsed.p !== null) {
              if (Math.abs(parsed.p - 1) < 0.01) confidence -= 0.1; // Edge case for p ≈ 1
              if (Math.abs(parsed.p) < 0.01) confidence -= 0.05; // Edge case for p ≈ 0
            }
            if (fAnalysis.note) confidence -= 0.05; // Reduce confidence for parsing issues
            confidence = Math.round(confidence * 100) / 100;
            this.confidenceText = `${(confidence * 100).toFixed(0)}%`;
            return Math.min(Math.max(confidence, 0.1), 0.95);
          },

          // Check regularity condition for Master Theorem Case 3
          checkRegularity(a, b, fAnalysis) {
            const regularTypes = ['polynomial', 'polylog', 'linear', 'constant'];
            const irregularTypes = ['factorial', 'exponential', 'superexp'];
            if (regularTypes.includes(fAnalysis.type)) {
              if (typeof math !== 'undefined' && fAnalysis.mathNode) {
                try {
                  const expr = fAnalysis.mathNode;
                  const nOverB = `n/${b}`;
                  const f_n = expr.evaluate({ n: 'n' });
                  const f_nOverB = expr.evaluate({ n: nOverB });
                  const ratio = a * f_nOverB / f_n;
                  if (ratio < 1) {
                    return { regular: true, note: `Regularity holds: a * f(n/b) ≈ ${ratio.toFixed(3)} * f(n) < f(n).` };
                  }
                  return { regular: false, note: `Regularity may fail: a * f(n/b) ≈ ${ratio.toFixed(3)} * f(n) ≥ f(n). Verify manually.` };
                } catch (e) {
                  console.warn('Regularity check failed:', e);
                }
              }
              return { regular: true, note: 'Likely satisfies regularity condition.' };
            }
            if (irregularTypes.includes(fAnalysis.type)) {
              return { regular: false, note: 'May violate regularity condition due to fast-growing f(n). Verify manually.' };
            }
            return { regular: null, note: 'Regularity unclear. Manual verification needed.' };
          },

          // Levenshtein distance for fuzzy matching
          levenshtein(a, b) {
            const matrix = Array(b.length + 1).fill().map(() => Array(a.length + 1).fill(0));
            for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
            for (let j = 1; j <= b.length; j++) {
              for (let i = 1; i <= a.length; i++) {
                const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
                matrix[j][i] = Math.min(
                  matrix[j][i - 1] + 1, // Deletion
                  matrix[j - 1][i] + 1, // Insertion
                  matrix[j - 1][i - 1] + indicator // Substitution
                );
              }
            }
            return matrix[b.length][a.length];
          },

          // Fuzzy match input against expected patterns
          fuzzyMatch(input, pattern) {
            const cleanInput = input.replace(/\s/g, '');
            const cleanPattern = pattern.replace(/\s/g, '');
            const distance = this.levenshtein(cleanInput, cleanPattern);
            const similarity = 1 - distance / Math.max(cleanInput.length, cleanPattern.length);
            return similarity > 0.85 ? { similarity, pattern } : null;
          },

          // Generate suggestions for fixing input errors
          generateSuggestions(input) {
            const suggestions = [];
            const clean = input.replace(/\s+/g, '');
            const expectedPatterns = [
              'T(n)=a*T(n/b)+f(n)',
              'T(n)=T(n-1)+T(n-2)+f(n)',
              'T(n)=a*T(n-1)+f(n)',
              'T(n)=T(n/b)+T(n/c)+f(n)',
              'T(n)=T(log n)+f(n)'
            ];
            for (const pattern of expectedPatterns) {
              const match = this.fuzzyMatch(clean, pattern.replace(/\s/g, ''));
              if (match) {
                suggestions.push(`Input resembles "${pattern}". Try: ${pattern.replace('a', '2').replace('b', '2').replace('c', '3').replace('f(n)', 'n')}.`);
              }
            }
            if (clean.includes('T(n-1)T(n-2)')) {
              suggestions.push('Did you mean T(n-1) + T(n-2)? Multiplication of T terms is not supported.');
            }
            if (clean.includes('nlogn') && !clean.includes('n*logn') && !clean.includes('n+logn')) {
              suggestions.push('Did you mean n*log(n) or n + log(n)? Use * for multiplication.');
            }
            if (clean.includes('T(n)') && !clean.includes('T(n)=')) {
              suggestions.push('Use format T(n) = ... for the recurrence relation.');
            }
            if (clean.includes('log(n)') || clean.includes('ln(n)')) {
              suggestions.push('Use "log n" instead of "log(n)" or "ln(n)" for better parsing.');
            }
            if (clean.match(/T\([^n]/)) {
              suggestions.push('Only variable "n" is supported in T(...).');
            }
            if (clean.match(/T\(n\/[0-9]+\)/g)?.length >= 3) {
              suggestions.push('Multiple branches detected. Consider Akra-Bazzi method.');
            }
            if (clean.includes('loglogn') || clean.includes('T(logn)')) {
              suggestions.push('Try substitution n = 2^k for iterated logarithm recurrences.');
            }
            if (clean.includes('n^2+n') || clean.includes('n*logn')) {
              suggestions.push('Complex f(n) detected. Simplify terms or verify dominance.');
            }
            if (clean.includes('2*T(n/2)+n')) {
              suggestions.push('Resembles merge sort: T(n) = 2T(n/2) + n → Θ(n log n).');
            }
            return suggestions;
          },

          // Main analysis function
          analyze() {
            // Reset state
            this.parsed = { form: '-', a: null, b: null, p: null, r: null, f: '-', branches: [], coeffs: [] };
            this.method = '—';
            this.confidence = 0;
            this.confidenceText = '';
            this.notes = '';
            this.verdict = '';
            this.caveats = '';
            this.rendered = '';
            this.suggestions = [];
            this.derivation = '';
            this.levelTableHTML = '';

            // Validate input
            if (!this.input.trim()) {
              this.notes = 'Please enter a recurrence relation, e.g., T(n) = 2T(n/2) + n';
              return;
            }

            const s = this.normalizeInput(this.input);
            this.suggestions = this.generateSuggestions(s);

            if (!s.includes('T(') || !s.includes('T(n)=')) {
              this.notes = 'Invalid format. Use T(n) = ... with at least one recursive term.';
              return;
            }

            // Define patterns for recurrence types
            const patterns = {
              iterLog: s.match(/^T\(n\)=([0-9]*\.?[0-9]*)\*?T\(log.?\(n\)\)\+(.+)$/i) ||
                s.match(/^T\(n\)=([0-9]*\.?[0-9]*)\*?T\(logn\)\+(.+)$/i),
              master: s.match(/^T\(\s*n\s*\)\s*=\s*([0-9]*\.?[0-9]*)\s*\*?\s*T\(\s*n\s*\/\s*([0-9]*\.?[0-9]+)\s*\)\s*\+\s*(.+)$/i),
              extendedMaster: s.match(/^T\(\s*n\s*\)\s*=\s*([0-9]*\.?[0-9]*)\s*\*?\s*T\(\s*n\s*\/\s*([0-9]*\.?[0-9]+)\s*\)\s*\+\s*(.+\/\s*log.*)$/i),
              fibonacci: s.match(/^T\(n\)=([0-9]*\.?[0-9]*)\*?T\(n-([0-9]+)\)\+([0-9]*\.?[0-9]*)\*?T\(n-([0-9]+)\)\+(.+)$/i),
              exponential: s.match(/^T\(n\)=([0-9]*\.?[0-9]*)\*?T\(n-([0-9]+)\)\+(.+)$/i),
              factorial: s.match(/^T\(n\)=n\*?T\(n-([0-9]+)\)\+(.+)$/i),
              power: s.match(/^T\(n\)=([0-9]*\.?[0-9]*)\*?T\(n\^?\(?([0-9]*\.?[0-9]+|1\/2|0\.5)\)?\)\+(.+)$/i),
              sqrt: s.match(/^T\(n\)=([0-9]*\.?[0-9]*)\*?T\(sqrt\(n\)\)\+(.+)$/i) ||
                s.match(/^T\(n\)=([0-9]*\.?[0-9]*)\*?T\(n\^0\.5\)\+(.+)$/i),
              full: s.match(/^T\(n\)=sum.*T\(i\).*\+(.+)$/i),
              nested: s.match(/^T\(n\)=T\(T\((.+?)\)\)\+(.+)$/i),
              multibranch: s.match(/^T\(n\)=\s*([0-9]*\.?[0-9]*)\*?T\(n\/([0-9]*\.?[0-9]+)\)\+([0-9]*\.?[0-9]*)\*?T\(n\/([0-9]*\.?[0-9]+)\)\+([0-9]*\.?[0-9]*)\*?T\(n\/([0-9]*\.?[0-9]+)\)\+(.+)$/i)
            };

            // Match and analyze recurrence type
            if (patterns.iterLog) {
              this.analyzeIteratedLog(patterns.iterLog);
            } else if (s.includes(')+T(') && s.includes('n/')) {
              if (this.analyzeAkraBazzi(s)) {
                this.updateTree();
                return;
              }
            } else if (patterns.multibranch) {
              this.analyzeMultiBranch(patterns.multibranch);
            } else if (patterns.factorial) {
              this.analyzeFactorial(patterns.factorial);
            } else if (patterns.fibonacci) {
              this.analyzeFibonacci(patterns.fibonacci);
            } else if (patterns.extendedMaster) {
              this.analyzeExtendedMaster(patterns.extendedMaster);
            } else if (patterns.master) {
              this.analyzeMaster(patterns.master);
            } else if (patterns.exponential) {
              this.analyzeExponential(patterns.exponential);
            } else if (patterns.sqrt || patterns.power) {
              this.analyzePower(patterns.sqrt || patterns.power);
            } else if (patterns.full) {
              this.analyzeFull(patterns.full);
            } else if (patterns.nested) {
              this.analyzeNested(patterns.nested);
            } else if (/n\^n|n!|2\^n/.test(s)) {
              this.analyzeDominance(s);
            } else {
              this.analyzeUnknown(s);
            }

            this.updateTree();
          },

          // Analyze Akra-Bazzi recurrence (multiple branches)
          analyzeAkraBazzi(s) {
            const parts = s.split('=')[1];
            if (!parts) return false;
            const terms = parts.split('+').filter(t => t.includes('T('));
            const branches = [];
            for (const term of terms) {
              const m = term.match(/^([0-9]*\.?[0-9]*)?\*?T\(\s*n\s*\/\s*([0-9]*\.?[0-9]+)\s*\)$/);
              if (m) {
                branches.push({
                  a: this.parseCoefficient(m[1]),
                  b: parseFloat(m[2])
                });
              }
            }
            if (branches.length >= 2) {
              this.parsed.form = 'Σ a_i T(n/b_i) + g(n)';
              this.parsed.branches = branches;
              const p = this.solveP(branches);
              this.parsed.p = p.toFixed(4);
              this.method = 'Akra–Bazzi';
              const remaining = parts.split('+').filter(t => !t.includes('T(')).join('+').trim();
              const fAnalysis = this.analyzeFunction(remaining);
              this.parsed.f = fAnalysis.latex;
              this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
              this.verdict = `Solve for $p$ where $\\sum a_i b_i^{-p} = 1$. Here, $p \\approx ${p.toFixed(3)}$. Compare $g(n) = ${fAnalysis.latex}$ with $n^p$ to determine $T(n)$.`;
              this.renderLatex(`$T(n) = \\sum_{i} ${branches.map(b => `${b.a}T(n/${b.b})`).join('+')} + ${fAnalysis.latex}$, with $p \\approx ${p.toFixed(3)}$`);
              this.derivation = `<div class="mt-3 p-3 bg-emerald-50 rounded border border-emerald-200">
                    <div class="font-semibold">Step-by-Step (Akra–Bazzi)</div>
                    <ol class="list-decimal ml-5 leading-6">
                        <li>Identify branches: ${branches.map((b, i) => `a_${i + 1} = ${b.a}, b_${i + 1} = ${b.b}`).join('; ')}.</li>
                        <li>Solve $\\sum a_i b_i^{-p} = 1$ → $p \\approx ${p.toFixed(3)}$.</li>
                        <li>Evaluate integral: $1 + \\int_1^n \\frac{g(u)}{u^{p+1}}\\,du$ for $g(n) = ${fAnalysis.latex}$.</li>
                        <li>Conclude: $T(n) = \\Theta(n^p \\cdot (1 + \\text{integral}))$.</li>
                    </ol>
                </div>`;
              this.triggerMathJax();
              return true;
            }
            return false;
          },

          // Analyze Master Theorem recurrence
          analyzeMaster(match) {
            const a = this.parseCoefficient(match[1]);
            const b = parseFloat(match[2]);
            const f = match[3];
            const p = Math.log(a) / Math.log(b);
            this.parsed = { form: 'aT(n/b) + f(n)', a, b, p: p.toFixed(4), r: null, f, branches: [] };
            this.method = 'Master Theorem';
            const fAnalysis = this.analyzeFunction(f);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.masterVerdictDetailed(fAnalysis, p, a, b);
            this.renderLatex(`$T(n) = ${a}T(n/${b}) + ${fAnalysis.latex}$, with $p = \\log_{${b}} ${a} \\approx ${p.toFixed(3)}$`);
            this.triggerMathJax();
          },

          // Analyze Extended Master Theorem recurrence
          analyzeExtendedMaster(match) {
            const a = this.parseCoefficient(match[1]);
            const b = parseFloat(match[2]);
            const f = match[3];
            const p = Math.log(a) / Math.log(b);
            this.parsed = { form: 'aT(n/b) + f(n)', a, b, p: p.toFixed(4), r: null, f, branches: [] };
            this.method = 'Extended Master Theorem';
            const fAnalysis = this.analyzeFunction(f);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.verdict = `For $f(n) = ${fAnalysis.latex}$ (e.g., $n/\\log^k n$), often $T(n) = \\Theta(n^p \\log \\log n)$.`;
            this.caveats = 'Extended Master Theorem requires careful analysis of logarithmic factors.';
            this.derivation = `<div class="mt-3 p-3 bg-indigo-50 rounded border border-indigo-200">
                <div class="font-semibold">Step-by-Step (Extended Master Theorem)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Compute $p = \\log_b a = \\log_{${b}} ${a} \\approx ${p.toFixed(3)}$.</li>
                    <li>Analyze $f(n) = ${fAnalysis.latex}$ against $n^p$.</li>
                    <li>Apply extended case: Likely $T(n) = \\Theta(n^p \\log \\log n)$ for logarithmic denominators.</li>
                </ol>
            </div>`;
            this.renderLatex(`$T(n) = ${a}T(n/${b}) + ${fAnalysis.latex}$`);
            this.triggerMathJax();
          },

          // Analyze Fibonacci-like recurrence
          analyzeFibonacci(match) {
            const a1 = this.parseCoefficient(match[1]);
            const c1 = parseInt(match[2]);
            const a2 = this.parseCoefficient(match[3]);
            const c2 = parseInt(match[4]);
            const g = match[5];
            this.parsed = { form: `${a1}T(n-${c1}) + ${a2}T(n-${c2}) + g(n)`, a: null, b: null, p: null, r: null, f: g, branches: [], coeffs: [a1, a2] };
            this.method = 'Fibonacci-like';
            const fAnalysis = this.analyzeFunction(g);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            const discriminant = (a1 + a2) * (a1 + a2) + 4 * a2;
            const lambda1 = ((a1 + a2) + Math.sqrt(discriminant)) / 2;
            const lambda2 = ((a1 + a2) - Math.sqrt(discriminant)) / 2;
            this.verdict = `Solve characteristic equation: $\\lambda^2 = ${a1}\\lambda + ${a2}$. Roots: $\\lambda_1 \\approx ${lambda1.toFixed(3)}, \\lambda_2 \\approx ${lambda2.toFixed(3)}. Growth: $\\Theta(\\lambda_1^n)$ if $|\\lambda_1| > 1$.`;
            this.derivation = `<div class="mt-3 p-3 bg-purple-50 rounded border border-purple-200">
                <div class="font-semibold">Step-by-Step (Fibonacci-like)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Form equation: $\\lambda^2 = ${a1}\\lambda + ${a2}$.</li>
                    <li>Solve roots: $\\lambda_1 \\approx ${lambda1.toFixed(3)}, \\lambda_2 \\approx ${lambda2.toFixed(3)}$.</li>
                    <li>Homogeneous solution: $T_h(n) = c_1 \\lambda_1^n + c_2 \\lambda_2^n$.</li>
                    <li>Add particular solution for $g(n) = ${fAnalysis.latex}$.</li>
                </ol>
            </div>`;
            this.renderLatex(this.verdict);
            this.triggerMathJax();
          },

          // Analyze exponential recurrence
          analyzeExponential(match) {
            const c = this.parseCoefficient(match[1]);
            const step = parseInt(match[2]);
            const g = match[3];
            if (c > 1) {
              this.parsed = { form: `${c}T(n-${step}) + g(n)`, a: c, b: null, p: null, r: null, f: g, branches: [] };
              this.method = 'Exponential Growth';
              const fAnalysis = this.analyzeFunction(g);
              this.parsed.f = fAnalysis.latex;
              this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
              this.verdict = `Coefficient $c = ${c} > 1$ → $T(n) = \\Theta(${c}^{n/${step}})$ plus particular solution for $g(n) = ${fAnalysis.latex}$.`;
              this.derivation = `<div class="mt-3 p-3 bg-red-50 rounded border border-red-200">
                    <div class="font-semibold">Step-by-Step (Exponential Growth)</div>
                    <ol class="list-decimal ml-5 leading-6">
                        <li>Homogeneous solution: $T_h(n) = C \\cdot ${c}^n$.</li>
                        <li>Sum particular solution: $\\sum_{k=1}^n \\frac{g(k)}{${c}^k}$ for $g(n) = ${fAnalysis.latex}$.</li>
                        <li>Combine: $T(n) = ${c}^n \\cdot (C + \\text{sum})$.</li>
                    </ol>
                </div>`;
              this.renderLatex(this.verdict);
              this.triggerMathJax();
            } else {
              this.analyzeSubtractive(c, step, g);
            }
          },

          // Analyze factorial growth recurrence
          analyzeFactorial(match) {
            const step = parseInt(match[1]);
            const g = match[2];
            this.parsed = { form: `nT(n-${step}) + g(n)`, a: null, b: null, p: null, r: null, f: g, branches: [] };
            this.method = 'Factorial Growth';
            const fAnalysis = this.analyzeFunction(g);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.verdict = `Coefficient $n$ leads to factorial growth: $T(n) = \\Theta(n! \\cdot \\text{factor})$ for $g(n) = ${fAnalysis.latex}$.`;
            this.derivation = `<div class="mt-3 p-3 bg-orange-50 rounded border border-orange-200">
                <div class="font-semibold">Step-by-Step (Factorial Growth)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Unroll: $T(n) = n \\cdot (n-1) \\cdot \\ldots \\cdot 1 \\cdot T(0) + \\sum_{k=1}^n (n \\cdot (n-1) \\cdot \\ldots \\cdot (k+1)) \\cdot g(k)$.</li>
                    <li>Leading term: $n! \\cdot T(0)$.</li>
                    <li>Evaluate sum for $g(n) = ${fAnalysis.latex}$ to adjust factor.</li>
                </ol>
            </div>`;
            this.renderLatex(this.verdict);
            this.triggerMathJax();
          },

          // Analyze subtractive recurrence
          analyzeSubtractive(c, step, g) {
            this.parsed = { form: `T(n-${step}) + g(n)`, a: c || 1, b: null, p: null, r: null, f: g, branches: [] };
            this.method = 'Subtractive';
            const fAnalysis = this.analyzeFunction(g);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.verdict = `Linear recursion with depth $\\approx n/${step}$. Solution: $T(n) \\approx T(0) + \\frac{1}{${step}} \\sum_{i=0}^{n-1} g(i)$.`;
            if (fAnalysis.type === 'linear') {
              this.verdict += ` For $g(n) = ${fAnalysis.latex}$, $T(n) = \\Theta(n^2)$.`;
            } else if (fAnalysis.type === 'constant') {
              this.verdict += ` For $g(n) = ${fAnalysis.latex}$, $T(n) = \\Theta(n)$.`;
            }
            this.derivation = `<div class="mt-3 p-3 bg-amber-50 rounded border border-amber-200">
                <div class="font-semibold">Step-by-Step (Subtractive)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Unroll: $T(n) = T(n-${step}) + g(n) = \\ldots = T(0) + \\sum g(n-k\\cdot${step})$.</li>
                    <li>Depth: $\\approx n/${step}$ steps.</li>
                    <li>Sum $g(n) = ${fAnalysis.latex}$ to get $T(n)$.</li>
                </ol>
            </div>`;
            this.renderLatex(this.verdict);
            this.triggerMathJax();
          },

          // Analyze power-shrink recurrence
          analyzePower(match) {
            const a = this.parseCoefficient(match[1]);
            let r = match[2] === '1/2' ? 0.5 : parseFloat(match[2]) || 0.5;
            const g = match[3];
            this.parsed = { form: `${a}T(n^${r}) + g(n)`, a, b: null, p: null, r: r.toFixed(3), f: g, branches: [] };
            this.method = 'Power-shrink';
            const fAnalysis = this.analyzeFunction(g);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.verdict = r < 1 && r > 0
              ? `Power $r = ${r} < 1$ → depth $\\Theta(\\log \\log n)$. Often $T(n) = \\Theta(g(n) \\cdot \\log \\log n)$ for $g(n) = ${fAnalysis.latex}$.`
              : `Unusual power $r = ${r}$. Requires specialized analysis.`;
            this.derivation = `<div class="mt-3 p-3 bg-fuchsia-50 rounded border border-fuchsia-200">
                <div class="font-semibold">Step-by-Step (Power-shrink)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Substitute $n = 2^k$ → $T(2^k) = ${a}T(2^{k \\cdot ${r}}) + g(2^k)$.</li>
                    <li>Depth: $\\Theta(\\log \\log n)$ due to exponential size reduction.</li>
                    <li>Analyze $g(n) = ${fAnalysis.latex}$ to find $T(n)$.</li>
                </ol>
            </div>`;
            this.renderLatex(this.verdict);
            this.triggerMathJax();
          },

          // Analyze iterated log recurrence
          analyzeIteratedLog(match) {
            const a = this.parseCoefficient(match[1] || '1');
            const g = match[2];
            this.parsed = { form: `${a}T(log n) + g(n)`, a, b: null, p: null, r: null, f: g, branches: [] };
            this.method = 'Iterated Log';
            const fAnalysis = this.analyzeFunction(g);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.verdict = `Iterated log: $T(n) = ${a}T(\\log n) + ${fAnalysis.latex}$. Typically $T(n) = \\Theta(\\log^* n)$, where $\\log^* n$ counts repeated logarithms.`;
            if (fAnalysis.type === 'constant') {
              this.verdict += ` For $g(n) = ${fAnalysis.latex}$, $T(n) = \\Theta(\\log^* n)$.`;
            }
            this.derivation = `<div class="mt-3 p-3 bg-sky-50 rounded border border-sky-200">
                <div class="font-semibold">Step-by-Step (Iterated Log)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Each step reduces to $\\log n$, then $\\log \\log n$, etc.</li>
                    <li>Depth: $\\log^* n$ (number of logs to reach $\\leq 1$).</li>
                    <li>Accumulate $g(n) = ${fAnalysis.latex}$ over $\\log^* n$ steps.</li>
                </ol>
            </div>`;
            this.renderLatex(this.verdict);
            this.triggerMathJax();
          },

          // Analyze multi-branch recurrence
          analyzeMultiBranch(match) {
            const branches = [
              { a: this.parseCoefficient(match[1]), b: parseFloat(match[2]) },
              { a: this.parseCoefficient(match[3]), b: parseFloat(match[4]) },
              { a: this.parseCoefficient(match[5]), b: parseFloat(match[6]) }
            ];
            const f = match[7];
            this.parsed = { form: 'a1T(n/b1) + a2T(n/b2) + a3T(n/b3) + f(n)', branches, f, a: null, b: null, p: null, r: null };
            this.method = 'Akra–Bazzi';
            const fAnalysis = this.analyzeFunction(f);
            this.parsed.f = fAnalysis.latex;
            const p = this.solveP(branches);
            this.parsed.p = p.toFixed(4);
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.verdict = `Solve $\\sum a_i b_i^{-p} = 1$ → $p \\approx ${p.toFixed(3)}. Compare $f(n) = ${fAnalysis.latex}$ with $n^p$.`;
            this.derivation = `<div class="mt-3 p-3 bg-emerald-50 rounded border border-emerald-200">
                <div class="font-semibold">Step-by-Step (Akra–Bazzi)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Branches: ${branches.map((b, i) => `a_${i + 1} = ${b.a}, b_${i + 1} = ${b.b}`).join('; ')}.</li>
                    <li>Solve $\\sum a_i b_i^{-p} = 1$ → $p \\approx ${p.toFixed(3)}$.</li>
                    <li>Evaluate integral for $f(n) = ${fAnalysis.latex}$.</li>
                    <li>Conclude: $T(n) = \\Theta(n^p \\cdot (1 + \\text{integral}))$.</li>
                </ol>
            </div>`;
            this.renderLatex(`$T(n) = ${branches.map(b => `${b.a}T(n/${b.b})`).join('+')} + ${fAnalysis.latex}$, with $p \\approx ${p.toFixed(3)}$`);
            this.triggerMathJax();
          },

          // Analyze full recurrence
          analyzeFull(match) {
            const g = match[1];
            this.parsed = { form: 'Σ T(i) + g(n)', a: null, b: null, p: null, r: null, f: g, branches: [] };
            this.method = 'Full Recurrence';
            const fAnalysis = this.analyzeFunction(g);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.verdict = `Full history: $T(n) = \\sum_{i=1}^{n-1} T(i) + ${fAnalysis.latex}$. Typically $T(n) = \\Theta(2^n)$.`;
            this.caveats = 'Exact growth depends on $g(n)$ and base cases.';
            this.derivation = `<div class="mt-3 p-3 bg-orange-50 rounded border border-orange-200">
                <div class="font-semibold">Step-by-Step (Full Recurrence)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Recognize: $T(n) = \\sum_{i=1}^{n-1} T(i) + g(n)$.</li>
                    <li>Use difference: $T(n) - T(n-1) = T(n-1) + g(n)$.</li>
                    <li>Solve for $g(n) = ${fAnalysis.latex}$, often yielding $\\Theta(2^n)$.</li>
                </ol>
            </div>`;
            this.renderLatex(this.verdict);
            this.triggerMathJax();
          },

          // Analyze nested recurrence
          analyzeNested(match) {
            const inner = match[1];
            const g = match[2];
            this.parsed = { form: `T(T(${inner})) + g(n)`, a: null, b: null, p: null, r: null, f: g, branches: [] };
            this.method = 'Nested Recurrence';
            const fAnalysis = this.analyzeFunction(g);
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            this.verdict = `Nested recurrence with inner $T(${inner})$. Requires iterative bounding or substitution.`;
            this.caveats = 'Nested recurrences are complex and may need numerical analysis.';
            this.derivation = `<div class="mt-3 p-3 bg-cyan-50 rounded border border-cyan-200">
                <div class="font-semibold">Step-by-Step (Nested Recurrence)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Recognize: $T(n) = T(T(${inner})) + ${fAnalysis.latex}$.</li>
                    <li>Bound inner $T(${inner})$ with an assumed form.</li>
                    <li>Iterate or use substitution (e.g., $n = 2^{2^k}$) to estimate growth.</li>
                </ol>
            </div>`;
            this.renderLatex(this.verdict);
            this.triggerMathJax();
          },

          // Analyze dominance-based recurrence
          analyzeDominance(s) {
            this.method = 'Dominance Analysis';
            const fAnalysis = this.analyzeFunction(s.split('+').pop() || 'unknown');
            this.parsed.f = fAnalysis.latex;
            this.confidence = this.calculateConfidence(this.method, this.parsed, fAnalysis);
            if (s.includes('n^n')) {
              this.verdict = `Super-exponential $n^n$ dominates → $T(n) = \\Theta(n^n)$.`;
            } else if (s.includes('n!')) {
              this.verdict = `Factorial $n!$ dominates → $T(n) = \\Theta(n!)$.`;
            } else if (s.includes('2^n')) {
              this.verdict = `Exponential $2^n$ likely dominates → $T(n) = \\Theta(2^n)$.`;
            }
            this.derivation = `<div class="mt-3 p-3 bg-rose-50 rounded border border-rose-200">
                <div class="font-semibold">Step-by-Step (Dominance Analysis)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Identify dominant term: ${fAnalysis.latex}.</li>
                    <li>Compare recursive terms vs. ${fAnalysis.latex}.</li>
                    <li>Conclude $T(n) = \\Theta(${fAnalysis.latex})$ if dominant.</li>
                </ol>
            </div>`;
            this.renderLatex(this.verdict);
            this.triggerMathJax();
          },

          // Handle unrecognized patterns
          analyzeUnknown(s) {
            this.method = 'Pattern Recognition Failed';
            this.confidence = 0.2;
            this.notes = 'Could not recognize recurrence pattern. Try these steps:';
            this.suggestions = [
              'Use standard form: T(n) = ...',
              'Try substitution: n = 2^k or n = 2^(2^k)',
              'Check for Master, Akra-Bazzi, or subtractive forms',
              'Verify large terms for dominance analysis',
              'Ensure correct syntax: T(n/2), not T(n/2.0)'
            ];
            this.verdict = 'Manual analysis required. See suggestions for help.';
            this.renderLatex('Unrecognized recurrence: $' + s.replace(/=/g, '=') + '$');
            this.triggerMathJax();
          },

          // Detailed verdict for Master Theorem
          masterVerdictDetailed(fAnalysis, p, a, b) {
            const pRounded = p.toFixed(3);
            const comparison = this.compare_g_vs_np(fAnalysis, p);
            const caseTxt = comparison.rel === 'smaller' ? 'Case 1' :
              comparison.rel === 'equal' ? 'Case 2' :
                comparison.rel === 'larger' ? 'Case 3' : 'Case ?';
            this.derivation = `<div class="mt-3 p-3 bg-indigo-50 rounded border border-indigo-200">
                <div class="font-semibold">Step-by-Step (Master Theorem)</div>
                <ol class="list-decimal ml-5 leading-6">
                    <li>Compute threshold: $n^{\\log_b a} = n^{\\log_{${b}} ${a}} \\approx n^{${pRounded}}$.</li>
                    <li>Compare $f(n) = ${fAnalysis.latex}$ vs. $n^{${pRounded}}$: ${comparison.note}.</li>
                    <li>Determine case: ${caseTxt}.</li>
                    <li>Apply case rule to find $T(n)$.</li>
                </ol>
            </div>`;

            if (fAnalysis.type === 'constant') {
              this.verdict = `$f(n) = ${fAnalysis.latex}$ is $O(n^{${pRounded} - \\epsilon})$ → Case 1: $T(n) = \\Theta(n^{${pRounded}})$.`;
            } else if (fAnalysis.type === 'linear') {
              if (1 < p - 0.01) {
                this.verdict = `Case 1: $f(n) = ${fAnalysis.latex} = O(n^{${pRounded} - \\epsilon})$ → $T(n) = \\Theta(n^{${pRounded}})$.`;
              } else if (Math.abs(1 - p) < 0.01) {
                this.verdict = `Case 2: $f(n) = ${fAnalysis.latex} = \\Theta(n^{${pRounded}})$ → $T(n) = \\Theta(n^{${pRounded}} \\log n)$.`;
              } else {
                const reg = this.checkRegularity(a, b, fAnalysis);
                this.verdict = `Case 3: $f(n) = ${fAnalysis.latex} = \\Omega(n^{${pRounded} + \\epsilon})$ → $T(n) = \\Theta(n)$ if ${reg.note}`;
                this.caveats = reg.note;
              }
            } else if (fAnalysis.type === 'polynomial') {
              const k = fAnalysis.power;
              if (k < p - 0.01) {
                this.verdict = `Case 1: $f(n) = ${fAnalysis.latex}$ with $k = ${k} < p = ${pRounded}$ → $T(n) = \\Theta(n^{${pRounded}})$.`;
              } else if (Math.abs(k - p) < 0.01) {
                this.verdict = `Case 2: $f(n) = ${fAnalysis.latex}$ with $k = p = ${pRounded}$ → $T(n) = \\Theta(n^{${pRounded}} \\log n)$.`;
              } else {
                const reg = this.checkRegularity(a, b, fAnalysis);
                this.verdict = `Case 3: $f(n) = ${fAnalysis.latex}$ with $k = ${k} > p = ${pRounded}$ → $T(n) = \\Theta(n^{${k}})$ if ${reg.note}`;
                this.caveats = reg.note;
              }
            } else if (fAnalysis.type === 'polylog') {
              const k = fAnalysis.power || 1;
              const m = fAnalysis.logPower || 1;
              if (k < p - 0.01) {
                this.verdict = `Case 1: $f(n) = ${fAnalysis.latex}$ with $k = ${k} < p = ${pRounded}$ → $T(n) = \\Theta(n^{${pRounded}})$.`;
              } else if (Math.abs(k - p) < 0.01) {
                this.verdict = `Case 2: $f(n) = ${fAnalysis.latex}$ → $T(n) = \\Theta(n^{${pRounded}} \\log^{${m + 1}} n)$.`;
              } else {
                const reg = this.checkRegularity(a, b, fAnalysis);
                this.verdict = `Case 3: $f(n) = ${fAnalysis.latex}$ → $T(n) = \\Theta(${fAnalysis.latex})$ if ${reg.note}`;
                this.caveats = reg.note;
              }
            } else if (fAnalysis.type === 'logonly') {
              this.verdict = `$f(n) = ${fAnalysis.latex}$ grows slower than $n^{${pRounded}}$ → Case 1: $T(n) = \\Theta(n^{${pRounded}})$.`;
            } else if (fAnalysis.type === 'logdiv') {
              if (Math.abs(p - 1) < 0.01) {
                this.verdict = `$f(n) = ${fAnalysis.latex}$ → likely $T(n) = \\Theta(n \\log \\log n)$.`;
                this.caveats = 'Requires extended Master Theorem analysis.';
              } else if (p > 1) {
                this.verdict = `$f(n) = ${fAnalysis.latex} = o(n^{${pRounded}})$ → Case 1: $T(n) = \\Theta(n^{${pRounded}})$.`;
              } else {
                this.verdict = `$f(n) = ${fAnalysis.latex}$ with $p < 1$ needs careful analysis.`;
              }
            } else {
              this.verdict = `$f(n) = ${fAnalysis.latex}$ - compare with $n^{${pRounded}}$ to determine case.`;
              this.caveats = 'Complex $f(n)$ requires manual verification of Master Theorem conditions.';
            }
          },

          // Solve for p in Akra-Bazzi: Σ a_i (1/b_i)^p = 1
          solveP(branches) {
            let lo = -10, hi = 10;
            for (let iter = 0; iter < 100; iter++) {
              const mid = (lo + hi) / 2;
              const val = branches.reduce((s, br) => s + br.a * Math.pow(1 / br.b, mid), 0);
              if (Math.abs(val - 1) < 1e-8) break;
              if (val > 1) lo = mid; else hi = mid;
            }
            return (lo + hi) / 2;
          },

          // Render LaTeX output in a styled container
          renderLatex(html) {
            this.rendered = `<div class="mt-2 p-3 bg-blue-50 rounded-lg border-l-4 border-blue-400">${html}</div>`;
          },

          // Trigger MathJax to render LaTeX
          triggerMathJax() {
            if (this.$nextTick) {
              this.$nextTick(() => {
                if (window.MathJax) MathJax.typesetPromise();
              });
            } else {
              setTimeout(() => {
                if (window.MathJax) MathJax.typesetPromise();
              }, 50);
            }
          },

          // Generate HTML for branch list
          branchList() {
            if (!this.parsed.branches.length) return '';
            return this.parsed.branches.map((b, i) =>
              `<div class="text-sm"><strong>Branch ${i + 1}:</strong> a=${b.a}, b=${b.b}</div>`
            ).join('');
          },

          // Generate HTML for suggestions list
          suggestionsList() {
            if (!this.suggestions.length) return '';
            return this.suggestions.map(s =>
              `<li class="text-sm text-gray-600">• ${s}</li>`
            ).join('');
          },

          // Export analysis as JSON file
          exportAnalysis() {
            const analysis = {
              input: this.input,
              method: this.method,
              confidence: this.confidence,
              parsed: this.parsed,
              verdict: this.verdict,
              caveats: this.caveats,
              suggestions: this.suggestions,
              timestamp: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(analysis, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `recurrence-analysis-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
          },

          // Estimate recursion tree depth based on method
          estimateTreeDepth() {
            if (this.method.includes('Master') && this.parsed.b) {
              return Math.ceil(Math.log(100) / Math.log(this.parsed.b)) + 2;
            }
            if (this.method.includes('Subtractive')) return 5;
            if (this.method.includes('Power') || this.method.includes('Iterated')) return 3;
            return this.treeDepth || 4;
          },

          // Build logical tree structure for visualization
          buildLogicalTree() {
            const depth = Math.max(2, Math.min(10, this.treeDepth || this.estimateTreeDepth()));
            const root = { name: 'n', sub: this.parsed.f ? `f(n)≈${this.parsed.f}` : '', children: [] };
            const pushLevel = (parent, labels, workFn = null) => {
              parent.children = labels.map(lbl => {
                const node = { name: lbl, sub: '', children: [] };
                if (workFn && this.parsed.f) {
                  try {
                    const expr = math.parse(this.parsed.f.replace('logn', 'log(n)').replace('loglogn', 'log(log(n))'));
                    const val = expr.evaluate({ n: lbl.includes('/') ? `n/${lbl.split('/')[1]}` : lbl });
                    node.sub = `f(${lbl})≈${val.toString()}`;
                  } catch (e) {
                    node.sub = `f(${lbl})≈${this.parsed.f.replace(/n/g, lbl)}`;
                  }
                }
                return node;
              });
            };

            // Generate derivation and level table for relevant methods
            if (this.method.includes('Master') || this.method.includes('Akra')) {
              //this.buildDerivationCard();
              this.levelTableHTML = this.buildLevelTable();
            }

            // Master Theorem tree
            if (this.method.includes('Master') && this.parsed.a && this.parsed.b) {
              const a = Number(this.parsed.a), b = Number(this.parsed.b);
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              const perLevel = (node, level) => {
                if (level >= depth) return;
                const lbl = level === 0 ? `n/${b}` : `n/${Math.pow(b, level + 1)}`;
                const children = Array.from({ length: a }, () => lbl);
                pushLevel(node, children, fAnalysis.mathNode);
                node.children.forEach(ch => perLevel(ch, level + 1));
              };
              perLevel(root, 0);
              return root;
            }

            // Akra-Bazzi tree
            if (this.method.includes('Akra') && this.parsed.branches?.length) {
              const branches = this.parsed.branches.map(br => ({ a: Number(br.a) || 1, b: Number(br.b) || 2 }));
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              const expand = (node, level, sizeLabel) => {
                if (level >= depth) return;
                const childLabels = [];
                branches.forEach(br => {
                  for (let i = 0; i < br.a; i++) childLabels.push(`${sizeLabel}/${br.b}`);
                });
                pushLevel(node, childLabels, fAnalysis.mathNode);
                node.children.forEach(ch => expand(ch, level + 1, ch.name));
              };
              root.sub = `p≈${Number(this.parsed.p).toFixed(3)}, f(n)≈${this.parsed.f || '-'}`;
              expand(root, 0, 'n');
              return root;
            }

            // Subtractive tree
            if (this.method.includes('Subtractive')) {
              const step = 1;
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              let cur = root;
              for (let i = 1; i < depth; i++) {
                const child = { name: `n-${i * step}`, sub: '', children: [] };
                if (i === 1 && this.parsed.f) {
                  try {
                    const expr = math.parse(this.parsed.f.replace('logn', 'log(n)').replace('loglogn', 'log(log(n))'));
                    const val = expr.evaluate({ n: `n-${i}` });
                    child.sub = `f(n-${i})≈${val.toString()}`;
                  } catch (e) {
                    child.sub = `f(n-${i})≈${this.parsed.f.replace(/n/g, `n-${i}`)}`;
                  }
                }
                cur.children = [child];
                cur = child;
              }
              return root;
            }

            // Power-shrink tree
            if (this.method.includes('Power')) {
              const a = this.parsed.a ? Number(this.parsed.a) : 1;
              const r = this.parsed.r ? Number(this.parsed.r) : 0.5;
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              const powerLabel = lvl => `n^${(Math.pow(r, lvl + 1)).toFixed(3)}`;
              const perLevel = (node, level) => {
                if (level >= depth) return;
                pushLevel(node, Array.from({ length: a }, () => powerLabel(level)), fAnalysis.mathNode);
                node.children.forEach(ch => perLevel(ch, level + 1));
              };
              perLevel(root, 0);
              return root;
            }

            // Iterated log tree
            if (this.method.includes('Iterated')) {
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              let cur = root;
              const steps = ['log n', 'log log n', 'log log log n', '…'];
              for (let i = 0; i < Math.min(depth - 1, steps.length); i++) {
                const child = { name: steps[i], sub: '', children: [] };
                if (i === 0 && this.parsed.f) {
                  try {
                    const expr = math.parse(this.parsed.f.replace('logn', 'log(n)').replace('loglogn', 'log(log(n))'));
                    const val = expr.evaluate({ n: steps[i] });
                    child.sub = `f(${steps[i]})≈${val.toString()}`;
                  } catch (e) {
                    child.sub = `f(${steps[i]})≈${this.parsed.f.replace(/n/g, steps[i])}`;
                  }
                }
                cur.children = [child];
                cur = child;
              }
              return root;
            }

            // Exponential tree
            if (this.method.includes('Exponential')) {
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              let cur = root;
              for (let i = 1; i < depth; i++) {
                const child = { name: `n-${i}`, sub: i === 1 ? `~a^n, f(n)≈${this.parsed.f}` : '', children: [] };
                cur.children = [child];
                cur = child;
              }
              return root;
            }

            // Factorial tree
            if (this.method.includes('Factorial')) {
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              let cur = root;
              for (let i = 1; i < depth; i++) {
                const child = { name: `n-${i}`, sub: i === 1 ? `~n!, f(n)≈${this.parsed.f}` : '', children: [] };
                cur.children = [child];
                cur = child;
              }
              return root;
            }

            // Full recurrence tree
            if (this.method.includes('Full')) {
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              const perLevel = (node, level, fanout) => {
                if (level >= depth) return;
                pushLevel(node, Array.from({ length: fanout }, (_, i) => `≈level${level + 1}`), fAnalysis.mathNode);
                node.children.forEach(ch => perLevel(ch, level + 1, Math.min(6, fanout * 2)));
              };
              perLevel(root, 0, 2);
              return root;
            }

            // Nested recurrence tree
            if (this.method.includes('Nested')) {
              const fAnalysis = this.analyzeFunction(this.parsed.f);
              let cur = root;
              for (let i = 1; i < Math.min(depth, 4); i++) {
                const child = { name: i === 1 ? 'T(n/2)' : 'T(…)', sub: i === 1 && this.parsed.f ? `+ ${this.parsed.f}` : '', children: [] };
                cur.children = [child];
                cur = child;
              }
              return root;
            }

            // Fallback for unrecognized patterns
            const clean = this.normalizeInput(this.input).replace(/\s+/g, '');
            const fuzzyPatterns = [
              {
                pattern: 'T(n)=a*T(n/b)+f(n)',
                method: 'Master',
                structure: (node, level) => {
                  if (level >= depth) return;
                  const b = this.parsed.b || 2;
                  const a = this.parsed.a || 2;
                  const lbl = level === 0 ? `n/${b}` : `n/${Math.pow(b, level + 1)}`;
                  const children = Array.from({ length: a }, () => lbl);
                  pushLevel(node, children);
                  node.children.forEach(ch => this.structure(ch, level + 1));
                }
              },
              {
                pattern: 'T(n)=T(n-1)+T(n-2)+f(n)',
                method: 'Fibonacci-like',
                structure: (node, level) => {
                  if (level >= depth) return;
                  const children = [`n-${level + 1}`, `n-${level + 2}`];
                  pushLevel(node, children);
                  node.children.forEach(ch => this.structure(ch, level + 1));
                }
              },
              {
                pattern: 'T(n)=T(log n)+f(n)',
                method: 'Iterated Log',
                structure: (node, level) => {
                  if (level >= depth) return;
                  const steps = ['log n', 'log log n', 'log log log n', '…'];
                  const child = { name: steps[level] || '…', sub: '', children: [] };
                  node.children = [child];
                  this.structure(child, level + 1);
                }
              }
            ];
            for (const { pattern, structure } of fuzzyPatterns) {
              if (this.fuzzyMatch(clean, pattern.replace(/\s/g, ''))) {
                const fAnalysis = this.analyzeFunction(this.parsed.f);
                structure(root, 0);
                if (this.parsed.f) root.sub = `f(n)≈${this.parsed.f}`;
                return root;
              }
            }

            // Default tree for unrecognized patterns
            let cur = root;
            for (let i = 1; i < depth; i++) {
              const child = { name: `n_${i}`, sub: '', children: [] };
              cur.children = [child];
              cur = child;
            }
            return root;
          },

          // Draw recursion tree using D3.js
          drawTree(treeData) {
            const svg = d3.select('#recursionTree');
            const { width } = svg.node().getBoundingClientRect();
            const height = 400;
            svg.attr('width', width).attr('height', height);
            svg.selectAll('*').remove();
            const g = svg.append('g').attr('transform', 'translate(24,16)');
            const root = d3.hierarchy(treeData);
            const treeLayout = d3.tree().size([width - 48, height - 48]);
            treeLayout(root);
            g.selectAll('.link')
              .data(root.links())
              .enter()
              .append('path')
              .attr('class', 'tree-link')
              .attr('fill', 'none')
              .attr('d', d3.linkVertical().x(d => d.x).y(d => d.y));
            const node = g.selectAll('.node')
              .data(root.descendants())
              .enter()
              .append('g')
              .attr('transform', d => `translate(${d.x},${d.y})`);
            const padX = 10, padY = 6;
            node.each(function (d) {
              const group = d3.select(this);
              const label = group.append('text').attr('class', 'tree-label').text(d.data.name);
              const sub = d.data.sub ? group.append('text').attr('class', 'tree-sub').attr('y', 14).text(d.data.sub) : null;
              const bbox1 = label.node().getBBox();
              const bbox2 = sub ? sub.node().getBBox() : { width: 0, height: 0 };
              const w = Math.max(bbox1.width, bbox2.width) + 2 * padX;
              const h = bbox1.height + (sub ? (bbox2.height + 4) : 0) + 2 * padY;
              const x = -w / 2, y = -h / 2;
              group.insert('rect', ':first-child')
                .attr('class', 'tree-node')
                .attr('x', x).attr('y', y)
                .attr('width', w).attr('height', h);
              label.attr('x', -bbox1.width / 2).attr('y', -h / 2 + padY + bbox1.height);
              if (sub) sub.attr('x', -bbox2.width / 2).attr('y', -h / 2 + padY + bbox1.height + 4 + bbox2.height);
            });
          },

          updateTree() {
            const data = this.buildLogicalTree();
            this.$nextTick(() => this.drawTree(data));
          },
          compare_g_vs_np(fAnalysis, p) {
            if (['factorial', 'exponential', 'superexp'].includes(fAnalysis.type)) {
              return { rel: 'larger', note: 'g(n) grows faster than any n^p.' };
            }
            if (!fAnalysis.mathNode) {
              return { rel: 'unknown', note: 'Unable to compare due to parsing failure.' };
            }
            try {
              const n = 100; // Evaluate at a large n for stability
              const g_n = fAnalysis.mathNode.evaluate({ n });
              const n_p = math.pow(n, p);
              const ratio = g_n / n_p;
              if (ratio < 0.1) return { rel: 'smaller', note: `g(n) ≈ ${ratio.toFixed(3)} * n^${p.toFixed(3)} at n=${n}` };
              if (Math.abs(ratio - 1) < 0.2) return { rel: 'equal', note: `g(n) ≈ n^${p.toFixed(3)} at n=${n}` };
              return { rel: 'larger', note: `$g(n) ≈ ${ratio.toFixed(3)} \\cdot n^{${p.toFixed(3)}}$ at n=$${n} $` };
            } catch (e) {
              console.warn('Comparison failed:', e);
              return { rel: 'unknown', note: 'Complex g(n), manual comparison needed.' };
            }
          },

          // Replace standalone 'n' tokens in TeX, but skip \ln, \log, and any \command
          safeReplaceNInTeX(tex, replacement) {
            if (!tex) return tex;
            // 1) Protect known commands that are followed by a space + n (e.g., "\log n")
            //    We'll replace " \log n" -> " \log __N__" first, then put replacement later.
            const SENTINEL = '__N__';
            tex = tex.replace(/(\\log)\s+n\b/g, `$1 ${SENTINEL}`);

            // 2) Replace standalone n that is not part of a command or an identifier:
            //    - not preceded by a backslash (so not \n from \ln, \min, etc.)
            //    - not adjacent to letters (so not part of "n^2 + nlog n" identifiers)
            tex = tex.replace(/(?<!\\)(?<![A-Za-z])n(?![A-Za-z])/g, replacement);

            // 3) Restore protected \log n occurrences
            tex = tex.replace(new RegExp(SENTINEL, 'g'), replacement);

            return tex;
          },

          buildLevelTable() {
            const rows = [];

            if (this.method.includes('Master') && this.parsed.a && this.parsed.b) {
              const a = Number(this.parsed.a), b = Number(this.parsed.b);
              const fA = this.analyzeFunction(this.parsed.f);
              const L = Math.max(2, Math.min(6, this.treeDepth || 4));
              for (let lvl = 0; lvl < L; lvl++) {
                const count = Math.pow(a, lvl);
                const size = `\\frac{n}{${Math.pow(b, lvl)}}`;   // LaTeX fraction
                const fStr = fA.latex
                  ? this.safeReplaceNInTeX(fA.latex, size)
                  : `f(${size})`;
                rows.push({ lvl, count, size, work: `${count}\\cdot ${fStr}` });
              }

            } else if (this.method.includes('Akra') && this.parsed.branches?.length) {
              const L = Math.max(2, Math.min(6, this.treeDepth || 4));
              let labels = ['n'];
              for (let lvl = 0; lvl < L; lvl++) {
                const next = [];
                for (const lab of labels) {
                  for (const br of this.parsed.branches) next.push(`\\tfrac{${lab}}{${br.b}}`);
                }
                const count = next.length || labels.length;
                const size = next[0] || `${labels[0]}/b`;
                const fStr = this.parsed.f
                  ? this.safeReplaceNInTeX(this.parsed.f, labels[0])
                  : `g(${labels[0]})`;
                rows.push({ lvl, count, size, work: `${count}\\cdot ${fStr}` });
                labels = next;
              }

            } else return '';

            const head = `<thead class="bg-slate-50 text-slate-600"><tr>
                  <th class="text-left p-2">Level</th>
                  <th class="text-left p-2">#Nodes</th>
                  <th class="text-left p-2">Subproblem size</th>
                  <th class="text-left p-2">Work (per level)</th>
                </tr></thead>`;

            const body = rows.map(r => `<tr class="border-t">
          <td class="p-2">${r.lvl}</td>
          <td class="p-2">\\(${r.count}\\)</td>
          <td class="p-2">\\(${r.size}\\)</td>
          <td class="p-2">\\(${r.work}\\)</td>
        </tr>`).join('');

            return `<div class="mt-3 bg-white rounded-xl shadow border">
      <div class="px-3 py-2 font-semibold text-slate-800">Recursion tree ledger (first levels)</div>
      <table class="w-full text-sm">${head}<tbody>${body}</tbody></table>
    </div>`;
          },

        };

      }


      // Additional test cases for validation
      const testRecurrences = [
        // Basic Master Theorem
        'T(n) = 2T(n/2) + n',
        'T(n) = 4T(n/2) + n',
        'T(n) = T(n/2) + 1',

        // Extended cases
        'T(n) = 2T(n/2) + n log n',
        'T(n) = 2T(n/2) + n/log n',
        'T(n) = 3T(n/4) + n^1.5',

        // Akra-Bazzi
        'T(n) = T(n/2) + T(n/3) + n',
        'T(n) = 2T(n/4) + 3T(n/8) + n^2',

        // Fibonacci-like
        'T(n) = T(n-1) + T(n-2) + 1',
        'T(n) = T(n-1) + T(n-2) + n',
        'T(n) = 2T(n-1) + T(n-2) + n^2',

        // Subtractive
        'T(n) = T(n-1) + n',
        'T(n) = T(n-2) + n^2',
        'T(n) = 3T(n-1) + n',

        // Power shrinking
        'T(n) = T(sqrt(n)) + 1',
        'T(n) = 2T(n^0.5) + log n',
        'T(n) = T(n^0.75) + n',

        // Special cases
        'T(n) = nT(n-1) + 1',
        'T(n) = T(log n) + 1',
        'T(n) = T(T(n/2)) + n',
        'T(n) = 2^n T(n/2) + n^n'
      ];

      // Validation function
      function validateImplementation() {
        console.log('Testing recurrence wizard with test cases...');
        const wizard = recurrenceWizard();

        let passed = 0;
        let total = testRecurrences.length;

        testRecurrences.forEach((test, i) => {
          wizard.input = test;
          wizard.analyze();

          const hasMethod = wizard.method !== '—' && wizard.method !== 'Pattern Recognition Failed';
          const hasConfidence = wizard.confidence > 0.3;
          const hasVerdict = wizard.verdict && wizard.verdict !== 'Manual analysis required - see suggestions above.';

          if (hasMethod && hasConfidence && hasVerdict) {
            passed++;
            console.log(`✓ Test ${i + 1}: ${test} → ${wizard.method} (${Math.round(wizard.confidence * 100)}%)`);
          } else {
            console.log(`✗ Test ${i + 1}: ${test} → Failed analysis`);
          }
        });

        console.log(`\nValidation Results: ${passed}/${total} tests passed (${Math.round(100 * passed / total)}%)`);
        return { passed, total, percentage: Math.round(100 * passed / total) };
      }

      // Auto-validation on load (optional)
      if (typeof window !== 'undefined') {
        window.validateRecurrenceWizard = validateImplementation;
      }

    </script>
</body>

</html>