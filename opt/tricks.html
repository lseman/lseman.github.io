<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DAS-410049 • Integer Programming — Tips & Tricks (Academic Indigo)</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50: '#eef2ff', 100: '#e0e7ff', 200: '#c7d2fe', 300: '#a5b4fc',
              400: '#818cf8', 500: '#6366f1', 600: '#4f46e5', 700: '#4338ca',
              800: '#3730a3', 900: '#312e81'
            }
          }
        }
      }
    }
  </script>

  <!-- MathJax (v3) -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]], displayMath: [["$$", "$$"], ["\\[", "\\]"]] },
      chtml: { linebreaks: { automatic: false }, matchFontHeight: true },
      options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" defer></script>

  <!-- Prism (core + LaTeX component) -->
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.min.css" as="style"
        onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.min.css"></noscript>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-latex.min.js" defer></script>

  <!-- Theme styles -->
  <style>
    :root{
      /* Semantic tokens for quick retheme */
      --bg-soft:        #f8fafc;   /* slate-50 */
      --bg-card:        rgba(255,255,255,.78);
      --ink-strong:     #0f172a;   /* slate-900 */
      --ink-soft:       #475569;   /* slate-600 */
      --ring:           #e2e8f0;   /* slate-200 */
      --grid-stroke:    rgba(15, 23, 42, .06);

      /* Accents */
      --pri-50:#eef2ff; --pri-100:#e0e7ff; --pri-200:#c7d2fe; --pri-300:#a5b4fc;
      --pri-400:#818cf8; --pri-500:#6366f1; --pri-600:#4f46e5; --pri-700:#4338ca;

      --ok-50:#ecfdf5;  --ok-200:#a7f3d0;  --ok-600:#059669;  /* emerald family */
      --warn-50:#fffbeb;--warn-200:#fde68a;--warn-600:#d97706;/* amber family  */
      --err-50:#fff1f2; --err-200:#fecdd3; --err-600:#e11d48; /* rose family   */
    }

    html { scroll-behavior: smooth; }
    body { color: var(--ink-strong); background: linear-gradient(140deg, #f8fafc 0%, #eef2ff 70%); }

    /* Cards */
    .card {
      background: var(--bg-card);
      backdrop-filter: saturate(120%) blur(6px);
      border: 1px solid var(--ring);
      border-radius: 1rem;
    }

    /* Note styles */
    .theorem, .def, .warn, .insight {
      padding: .75rem 1rem;
      border-radius: .6rem;
      border: 1px solid var(--ring);
      box-shadow: 0 1px 0 rgba(15,23,42,.02);
    }
    .theorem { background: var(--pri-50);  border-left: 4px solid var(--pri-400); }
    .def     { background: var(--ok-50);   border-left: 4px solid var(--ok-600); }
    .warn    { background: var(--err-50);  border-left: 4px solid var(--err-600); }
    .insight { background: var(--warn-50); border-left: 4px solid var(--warn-600); }

    /* Subtle grid + vignette for hero */
    .bg-grid {
      background-image:
        linear-gradient(to right, var(--grid-stroke) 1px, transparent 1px),
        linear-gradient(to bottom, var(--grid-stroke) 1px, transparent 1px);
      background-size: 24px 24px;
      mask-image: radial-gradient(ellipse at 50% 28%, rgba(0,0,0,.9), rgba(0,0,0,.16) 60%, transparent 76%);
    }
    /* Gentle glow in brand hue */
    .glow {
      position:absolute; inset:-15% -10% auto -10%; height:52vh;
      background: radial-gradient(60% 60% at 50% 40%,
        rgba(99,102,241,.22), rgba(129,140,248,.14) 42%, rgba(203,213,225,.10) 70%, transparent 75%);
      filter: blur(40px); pointer-events:none;
    }
    .fade-up { opacity:0; transform:translateY(12px); animation:fadeUp .7s ease forwards .1s; }
    @keyframes fadeUp { to { opacity:1; transform:none; } }

    /* Watermark math (very subtle) */
    .math-watermark {
      position:absolute; inset:10% auto auto 55%;
      transform: translateX(-20%);
      opacity:.06; font-weight:700; letter-spacing:.02em;
      color:#0f172a;
      pointer-events:none; user-select:none;
    }

    /* Print styles (A4) */
    @media print {
      @page { size: A4; margin: 10mm; }
      .no-print { display: none !important; }
      .print-grid { columns: 2; column-gap: 12mm; }
      section { break-inside: avoid; }
      .tip { break-inside: avoid; border: 1px solid var(--ring); }
    }
  </style>

  <!-- Prism line-numbers styling (harmonized) -->
  <style>
    pre[class*="language-"].line-numbers {
      position: relative; padding-left: 3.5em; counter-reset: linenumber;
      background: #0b1220;
      border: 1px solid #1f2937; border-radius: .75rem;
    }
    pre[class*="language-"].line-numbers > code { position: relative; white-space: inherit; }
    .line-numbers .line-numbers-rows {
      position: absolute; pointer-events: none; top: 0; left: 0;
      width: 3em; border-right: 1px solid #334155; user-select: none;
    }
    .line-numbers-rows > span { display: block; counter-increment: linenumber; }
    .line-numbers-rows > span:before {
      content: counter(linenumber);
      color: #64748b; display: block; padding-right: .6em; text-align: right;
      font-variant-numeric: tabular-nums;
    }
    pre code { color: #e5e7eb; }
  </style>
   <style>
        .formula-container {
            animation: float 20s ease-in-out infinite;
        }
        
        .formula-container:nth-child(odd) {
            animation-delay: -10s;
        }
        
        .formula-container:nth-child(3n) {
            animation-delay: -5s;
        }
        
        .formula-container:nth-child(4n) {
            animation-delay: -15s;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-10px) rotate(1deg); }
            50% { transform: translateY(5px) rotate(-0.5deg); }
            75% { transform: translateY(-5px) rotate(0.5deg); }
        }
        
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .blur-effect {
            filter: blur(0.5px);
        }
    </style>
</head>

<body class="min-h-screen text-slate-800">

  <!-- ======= Hero ======= -->
     <header class="relative h-[100svh] flex items-center">

    <div aria-hidden="true" class="absolute inset-0 bg-grid"></div>
    <div aria-hidden="true" class="glow"></div>

    <div class="relative mx-auto max-w-7xl px-6 py-12 lg:py-20">
      <div class="grid lg:grid-cols-1 gap-10 items-start">

        <!-- Left: Title + Lead + TOC -->
        <div class="fade-up">
          <header>
            <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900 leading-[1.05]">
              Mixed-Integer Programming Cheat-Sheet
            </h1>
            <p class="mt-4 text-lg text-slate-700 max-w-2xl">
              Concise formulas and modeling idioms for MILP: logical relations, Big-M, conditional constraints,
              linearization, min/max gadgets, and McCormick envelopes. MathJax-ready, classroom-friendly, and printable.
            </p>
          </header>

          <!-- TOC -->
          <nav class="mt-8 grid sm:grid-cols-2 md:grid-cols-3 gap-3 text-sm">
            <a href="#logic"
               class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Logical Statements</a>
            <a href="#bigm"
               class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Big-M</a>
            <a href="#conditional"
               class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Conditional</a>
            <a href="#precedence"
               class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Precedence</a>
            <a href="#linearization"
               class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Linearization</a>
            <a href="#minmax"
               class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Min / Max</a>
            <a href="#mccormick"
               class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition md:col-span-1 col-span-2">McCormick</a>
          </nav>

          <!-- Actions -->
          <div class="mt-6 flex flex-wrap gap-3">
            <a href="#piecewise-mccormick"
               class="px-5 py-2.5 rounded-xl bg-brand-600 text-white font-semibold shadow hover:bg-brand-700">Jump to Piecewise McCormick</a>
            <a id="printBtn"
               class="px-5 py-2.5 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50 cursor-pointer">Print / PDF</a>
          </div>
        </div>

      </div>
    </div>
      <!-- Watermark formula -->
<!-- Watermark formulas -->
<div class="pointer-events-none select-none text-slate-900/5 font-bold tracking-tight">
     <!-- Linear Programming - Top Left -->
        <div class="formula-container absolute top-[8%] left-[5%] text-2xl md:text-4xl">
            <span class="gradient-text">\(\min\; c^\top x \;\; \text{s.t.}\;\; Ax \leq b,\; x \geq 0\)</span>
        </div>
        
        <!-- Integer Programming - Top Right -->
        <div class="formula-container absolute top-[12%] right-[8%] text-3xl md:text-5xl rotate-[-8deg] opacity-80">
            <span>\(x \in \{0,1\}^n\)</span>
        </div>
        
        <!-- Lagrangian - Upper Middle -->
        <div class="formula-container absolute top-[18%] left-[35%] text-xl md:text-3xl rotate-[5deg] blur-effect">
            <span>\(\mathcal{L}(x,\lambda) = f(x) + \lambda^\top g(x)\)</span>
        </div>
        
        <!-- Quadratic Programming - Center Left -->
        <div class="formula-container absolute top-[30%] left-[12%] text-3xl md:text-5xl rotate-[-3deg]">
            <span>\(\min\; \frac{1}{2}x^\top Qx + c^\top x\)</span>
        </div>
        
        <!-- KKT Conditions - Center -->
        <div class="formula-container absolute top-[35%] left-[45%] text-lg md:text-2xl opacity-60">
            <span>\(\nabla f(x^*) + \sum_i \lambda_i \nabla g_i(x^*) = 0\)</span>
        </div>
        
        <!-- Semidefinite Programming - Center Right -->
        <div class="formula-container absolute top-[28%] right-[10%] text-2xl md:text-4xl rotate-[12deg]">
            <span>\(X \succeq 0,\; \text{tr}(CX) \to \min\)</span>
        </div>
        
        <!-- Convex Optimization - Mid Left -->
        <div class="formula-container absolute top-[45%] left-[8%] text-xl md:text-3xl rotate-[8deg] blur-effect">
            <span>\(\min_{x \in \mathcal{C}} f(x)\)</span>
        </div>
        
        <!-- Dual Problem - Large Center -->
        <div class="formula-container absolute top-[50%] left-[25%] text-4xl md:text-6xl rotate-[-5deg] opacity-8">
            <span>\(\max\; \sum_i p_i y_i \;\; \text{s.t.}\;\; \sum_j a_{ij} y_j \leq b_i\)</span>
        </div>
        
        <!-- Robust Optimization - Mid Right -->
        <div class="formula-container absolute top-[48%] right-[15%] text-2xl md:text-4xl rotate-[-10deg]">
            <span>\(\min_x \max_{\xi \in \mathcal{U}} f(x,\xi)\)</span>
        </div>
        
        <!-- Stochastic Programming - Lower Left -->
        <div class="formula-container absolute top-[65%] left-[6%] text-xl md:text-3xl rotate-[6deg]">
            <span>\(\min\; \mathbb{E}[Q(x,\omega)]\)</span>
        </div>
        
        <!-- Non-linear Programming - Lower Center -->
        <div class="formula-container absolute top-[62%] left-[40%] text-2xl md:text-4xl rotate-[-8deg] opacity-70">
            <span>\(\min\; f(x) \;\; \text{s.t.}\;\; g_i(x) \leq 0\)</span>
        </div>
        
        <!-- Dynamic Programming - Lower Right -->
        <div class="formula-container absolute top-[68%] right-[12%] text-xl md:text-3xl rotate-[10deg]">
            <span>\(V_t(s) = \max_a \{r(s,a) + \gamma V_{t+1}(s')\}\)</span>
        </div>
        
        <!-- L1 Norm Minimization - Bottom Left -->
        <div class="formula-container absolute bottom-[18%] left-[10%] text-2xl md:text-4xl blur-effect">
            <span>\(\min\; \|Ax - b\|_1\)</span>
        </div>
        
        <!-- Network Flow - Bottom Center -->
        <div class="formula-container absolute bottom-[15%] left-[35%] text-xl md:text-3xl rotate-[4deg]">
            <span>\(\sum_{j} x_{ij} - \sum_{k} x_{jk} = b_i\)</span>
        </div>
        
        <!-- Multi-objective - Bottom Right -->
        <div class="formula-container absolute bottom-[12%] right-[8%] text-xl md:text-3xl rotate-[-6deg]">
            <span>\(\min\; (f_1(x), f_2(x), \ldots, f_k(x))\)</span>
        </div>
        
        <!-- Gradient Descent - Very Bottom -->
        <div class="formula-container absolute bottom-[8%] left-[20%] text-lg md:text-2xl rotate-[8deg] opacity-50">
            <span>\(x_{k+1} = x_k - \alpha_k \nabla f(x_k)\)</span>
        </div>
        
        <!-- Newton's Method - Bottom Far Right -->
        <div class="formula-container absolute bottom-[6%] right-[25%] text-lg md:text-2xl rotate-[-12deg] opacity-60">
            <span>\(x_{k+1} = x_k - [\nabla^2 f(x_k)]^{-1} \nabla f(x_k)\)</span>
        </div>
        
        <!-- Barrier Method - Top Far Right -->
        <div class="formula-container absolute top-[5%] right-[25%] text-lg md:text-2xl rotate-[15deg] opacity-40">
            <span>\(f(x) - \mu \sum_i \log(-g_i(x))\)</span>
        </div>
        
        <!-- Duality Gap - Upper Left -->
        <div class="formula-container absolute top-[25%] left-[2%] text-lg md:text-2xl rotate-[-15deg] opacity-50">
            <span>\(p^* - d^* = 0\)</span>
        </div>
        
        <!-- Complementary Slackness - Far Right -->
        <div class="formula-container absolute top-[55%] right-[2%] text-lg md:text-2xl rotate-[18deg] opacity-45">
            <span>\(\lambda_i g_i(x^*) = 0\)</span>
        </div>
        
        <!-- Primal-Dual Interior Point -->
        <div class="formula-container absolute top-[75%] left-[45%] text-lg md:text-2xl rotate-[-4deg] opacity-55">
            <span>\(\mu = \frac{x^\top s}{n}\)</span>
        </div>
    </div>
  </header>

  <!-- ======= McCormick (single-box) ======= -->
  <section id="mccormick" class="py-12 bg-gradient-to-tr from-slate-50 via-brand-50 to-slate-100 border-b border-slate-200">
    <div class="max-w-7xl mx-auto px-6">
      <h2 class="text-3xl font-extrabold tracking-tight text-slate-900 mb-6">McCormick Envelopes</h2>

      <div class="grid lg:grid-cols-2 gap-6">
        <!-- Derivation -->
        <article class="card p-5">
          <h3 class="text-xl font-bold mb-3">Derivation (bounded bilinear: \(w=xy\))</h3>
          <p class="text-slate-700 mb-2">
            Bounds: \(x\in[x_L,x_U],\; y\in[y_L,y_U]\). Using nonnegativity of products, we obtain two convex lower planes and two concave upper planes:
          </p>
          <div class="theorem text-sm space-y-1">
            <div><strong>Lower:</strong>
              $$\begin{aligned}
                w &\ge x_L y + x y_L - x_L y_L\\[-2pt]
                w &\ge x_U y + x y_U - x_U y_U
              \end{aligned}$$
            </div>
            <div><strong>Upper:</strong>
              $$\begin{aligned}
                w &\le x_U y + x y_L - x_U y_L\\[-2pt]
                w &\le x y_U + x_L y - x_L y_U
              \end{aligned}$$
            </div>
          </div>
          <p class="text-slate-700 mt-3">
            These four inequalities form the tightest convex relaxation over the rectangle, touching \(w=xy\) at the four corners.
          </p>
          <div class="insight text-sm mt-3"><strong>Tip:</strong> Refining bounds or partitioning the box yields tighter relaxations (piecewise McCormick).</div>

          <details class="warn mt-3">
            <summary class="font-semibold cursor-pointer">Step-by-step factorization proof</summary>
            <div class="mt-2 text-sm space-y-2">
              <div><em>Lower 1:</em> \((x-x_L)(y-y_L)\ge 0 \Rightarrow w \ge x_L y + x y_L - x_L y_L\)</div>
              <div><em>Lower 2:</em> \((x_U-x)(y_U-y)\ge 0 \Rightarrow w \ge x_U y + x y_U - x_U y_U\)</div>
              <div><em>Upper 1:</em> \((x_U-x)(y-y_L)\ge 0 \Rightarrow w \le x_U y + x y_L - x_U y_L\)</div>
              <div><em>Upper 2:</em> \((x-x_L)(y_U-y)\ge 0 \Rightarrow w \le x y_U + x_L y - x_L y_U\)</div>
            </div>
          </details>
        </article>

        <!-- Interactive slice -->
        <article class="card p-5">
          <h3 class="text-xl font-bold mb-3">Interactive 2D Slice (fix \(y\))</h3>
          <div class="grid sm:grid-cols-2 gap-3 text-sm">
            <label class="def flex items-center justify-between rounded-lg">x_L
              <input id="xL" type="number" step="0.1" value="0.0" class="ml-3 w-24 px-2 py-1 border rounded-md">
            </label>
            <label class="def flex items-center justify-between rounded-lg">x_U
              <input id="xU" type="number" step="0.1" value="1.0" class="ml-3 w-24 px-2 py-1 border rounded-md">
            </label>
            <label class="def flex items-center justify-between rounded-lg">y_L
              <input id="yL" type="number" step="0.1" value="0.0" class="ml-3 w-24 px-2 py-1 border rounded-md">
            </label>
            <label class="def flex items-center justify-between rounded-lg">y_U
              <input id="yU" type="number" step="0.1" value="1.0" class="ml-3 w-24 px-2 py-1 border rounded-md">
            </label>
            <label class="insight rounded-lg col-span-full">y (slice)
              <input id="yFix" type="range" min="0" max="1" value="0.5" step="0.01" class="w-full">
              <div class="text-xs text-slate-600 mt-1">y = <span id="yVal">0.50</span></div>
            </label>
          </div>

          <div class="mt-4 bg-white rounded-xl border border-slate-200 p-3">
            <svg id="mcPlot" viewBox="0 0 640 420" class="w-full h-auto">
              <defs>
                <linearGradient id="envShade" x1="0" x2="0" y1="0" y2="1">
                  <stop offset="0%" stop-opacity="0.25" stop-color="#94a3b8" />
                  <stop offset="100%" stop-opacity="0.1" stop-color="#94a3b8" />
                </linearGradient>
              </defs>
              <!-- Axes -->
              <g id="axes"></g>
              <!-- Shaded envelope -->
              <path id="shade" fill="url(#envShade)" stroke="none" />
              <!-- Curves -->
              <path id="trueW" fill="none" stroke="#0f172a" stroke-width="2" />
              <path id="u1" fill="none" stroke="#a16207" stroke-dasharray="5,5" stroke-width="1.5" />
              <path id="u2" fill="none" stroke="#b91c1c" stroke-dasharray="5,5" stroke-width="1.5" />
              <path id="o1" fill="none" stroke="#3b82f6" stroke-dasharray="5,5" stroke-width="1.5" />
              <path id="o2" fill="none" stroke="#22c55e" stroke-dasharray="5,5" stroke-width="1.5" />
            </svg>
            <div class="text-xs text-slate-600 mt-2">
              Black: true \(w=xy\) (slice). Dashed: McCormick bounds. Shaded band: feasible envelope for this \(y\).
            </div>
          </div>
        </article>
      </div>
    </div>
  </section>

  <!-- ======= Piecewise McCormick ======= -->
  <section id="piecewise-mccormick" class="py-12 bg-gradient-to-tr from-slate-50 via-brand-50 to-slate-100 border-y border-slate-200">
    <div class="max-w-7xl mx-auto px-6">
      <header class="mb-6">
        <h2 class="text-3xl font-extrabold tracking-tight text-slate-900">Piecewise McCormick Envelopes</h2>
        <p class="text-slate-700 max-w-3xl mt-2">
          Approximate the bilinear term \(w=xy\) by partitioning the domain into smaller rectangles and applying McCormick locally.
          Increasing the number of partitions tightens the relaxation and shrinks the envelope gap. Use the controls to change partitions
          and view a slice (fixing \(y\)).
        </p>
      </header>

      <div class="mt-8 grid lg:grid-cols-3 gap-4">
        <div class="card p-5">
          <h3 class="text-lg font-semibold text-slate-800">Why piecewise?</h3>
          <p class="text-sm text-slate-700 mt-2">
            Standard McCormick relaxes \(w=xy\) over the whole box with four inequalities—simple but often loose on large domains.
            Partitioning the box into \(N_x\times N_y\) rectangles and applying McCormick locally yields a much tighter convex envelope.
          </p>
          <h4 class="mt-4 font-semibold text-slate-800 text-sm">Geometric intuition</h4>
          <ul class="list-disc pl-5 text-sm text-slate-700 mt-1 space-y-1">
            <li>Tile the curved surface \(w=xy\) with small rectangles (cells).</li>
            <li>Each cell has its own linear bounds (local McCormick).</li>
            <li>Summing these bounds forms a tight global relaxation.</li>
          </ul>
        </div>

        <div class="card p-5">
          <h3 class="text-lg font-semibold text-slate-800">Multiple-Choice Disaggregated (MCD)</h3>
          <p class="text-sm text-slate-700 mt-2">
            Split the x-interval into \(\{[x^L_n,x^U_n]\}\) and the y-interval into \(\{[y^L_m,y^U_m]\}\).
            Create binary cell selectors \(z_{nm}\in\{0,1\}\) with exactly one active cell:
          </p>
          <p class="text-sm font-mono bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 mt-2">
            \(\textstyle \sum_{n=1}^{N_x}\sum_{m=1}^{N_y} z_{nm} = 1.\)
          </p>
          <p class="text-sm text-slate-700 mt-3">
            Disaggregate variables per cell \((\hat{x}_{nm},\hat{y}_{nm},\hat{w}_{nm})\) and link with
            \(x=\sum_{n,m}\hat{x}_{nm},\ y=\sum_{n,m}\hat{y}_{nm},\ w=\sum_{n,m}\hat{w}_{nm}\).
          </p>
        </div>

        <div class="card p-5">
          <h3 class="text-lg font-semibold text-slate-800">Local McCormick in each cell</h3>
          <p class="text-sm text-slate-700 mt-2">
            Within cell \((n,m)\), apply McCormick to \((\hat{x}_{nm},\hat{y}_{nm},\hat{w}_{nm})\) over
            \([x^L_n,x^U_n]\times[y^L_m,y^U_m]\) scaled by \(z_{nm}\):
          </p>
          <p class="text-sm font-mono bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 mt-2">
            \(\begin{aligned}
            \hat{w}_{nm} &\ge x^L_n\,\hat{y}_{nm} + y^L_m\,\hat{x}_{nm} - x^L_n y^L_m\,z_{nm},\\
            \hat{w}_{nm} &\ge x^U_n\,\hat{y}_{nm} + y^U_m\,\hat{x}_{nm} - x^U_n y^U_m\,z_{nm},\\
            \hat{w}_{nm} &\le x^U_n\,\hat{y}_{nm} + y^L_m\,\hat{x}_{nm} - x^U_n y^L_m\,z_{nm},\\
            \hat{w}_{nm} &\le x^L_n\,\hat{y}_{nm} + y^U_m\,\hat{x}_{nm} - x^L_n y^U_m\,z_{nm}.
            \end{aligned}\)
          </p>
        </div>
      </div>

      <div class="mt-6 grid md:grid-cols-3 gap-4 text-sm">
        <div class="card p-4">
          <div class="font-semibold text-slate-700 mb-2">Domain</div>
          <label class="flex items-center justify-between gap-2 mb-2">x_L
            <input id="pw_xL" type="number" step="0.1" value="0" class="w-28 px-2 py-1 border rounded-md">
          </label>
          <label class="flex items-center justify-between gap-2 mb-2">x_U
            <input id="pw_xU" type="number" step="0.1" value="1" class="w-28 px-2 py-1 border rounded-md">
          </label>
          <label class="flex items-center justify-between gap-2 mb-2">y_L
            <input id="pw_yL" type="number" step="0.1" value="0" class="w-28 px-2 py-1 border rounded-md">
          </label>
          <label class="flex items-center justify-between gap-2">y_U
            <input id="pw_yU" type="number" step="0.1" value="1" class="w-28 px-2 py-1 border rounded-md">
          </label>
        </div>

        <div class="card p-4">
          <div class="font-semibold text-slate-700 mb-2">Partitions</div>
          <label class="flex items-center justify-between gap-2 mb-2">N<sub>x</sub> (x partitions)
            <div class="flex items-center gap-2">
              <button id="pw_decNx" type="button" class="px-2 py-1 border rounded-md">–</button>
              <input id="pw_Nx" type="number" min="1" step="1" value="3" class="w-20 px-2 py-1 border rounded-md">
              <button id="pw_incNx" type="button" class="px-2 py-1 border rounded-md">+</button>
            </div>
          </label>
          <label class="flex items-center justify-between gap-2">N<sub>y</sub> (y partitions)
            <div class="flex items-center gap-2">
              <button id="pw_decNy" type="button" class="px-2 py-1 border rounded-md">–</button>
              <input id="pw_Ny" type="number" min="1" step="1" value="1" class="w-20 px-2 py-1 border rounded-md">
              <button id="pw_incNy" type="button" class="px-2 py-1 border rounded-md">+</button>
            </div>
          </label>
          <p class="text-xs text-slate-600 mt-3">Uniform partitions; non-uniform grids can be added with custom breakpoints.</p>
        </div>

        <div class="card p-4">
          <div class="font-semibold text-slate-700 mb-2">Slice</div>
          <label class="block">Fix y
            <input id="pw_yFix" type="range" min="0" max="1" step="0.01" value="0.5" class="w-full mt-2">
          </label>
          <div class="text-xs text-slate-600 mt-2">y = <span id="pw_yVal">0.50</span></div>
          <div class="text-xs text-slate-600 mt-2">Error bound (uniform): <span id="pw_errBound">–</span></div>
        </div>
      </div>

      <div class="mt-6 bg-white rounded-xl border border-slate-200 p-3">
        <svg id="pw_plot" viewBox="0 0 720 440" class="w-full h-auto">
          <defs>
            <linearGradient id="pw_envShade" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0%" stop-opacity="0.25" stop-color="#94a3b8" />
              <stop offset="100%" stop-opacity="0.1" stop-color="#94a3b8" />
            </linearGradient>
          </defs>
          <!-- Axes -->
          <g id="pw_axes"></g>
          <!-- Partition verticals -->
          <g id="pw_partitions"></g>
          <!-- Shade -->
          <path id="pw_shade" fill="url(#pw_envShade)" stroke="none" />
          <!-- Curves -->
          <path id="pw_true"  fill="none" stroke="#0f172a" stroke-width="2" />
          <path id="pw_under" fill="none" stroke="#f59e0b" stroke-dasharray="6,6" stroke-width="1.5" />
          <path id="pw_over"  fill="none" stroke="#60a5fa" stroke-dasharray="6,6" stroke-width="1.5" />
        </svg>
        <div class="text-xs text-slate-600 mt-2">
          Black: \(w=xy\) (slice). Orange/Blue: piecewise McCormick lower/upper bound for the active row.
          Shaded band: feasible envelope. Light grid lines show x-partitions; row is chosen by the y-slider.
        </div>
      </div>
    </div>
  </section>

  <!-- ======= 1D Piecewise Linear Interpolation (SOS2) ======= -->
<section id="pwl1d" class="py-12 bg-gradient-to-tr from-slate-50 via-brand-50 to-slate-100 border-y border-slate-200">
  <div class="max-w-7xl mx-auto px-6">
    <header class="mb-6">
      <h2 class="text-3xl font-extrabold tracking-tight text-slate-900">1D Piecewise Linear Interpolation</h2>
      <p class="text-slate-700 max-w-3xl mt-2">
        Approximate a scalar function \(f(x)\) on a grid \(x_0&lt;x_1&lt;\dots&lt;x_n\) by connecting consecutive breakpoints.
        This yields a continuous piecewise-linear surrogate that integrates cleanly with convex optimization or MIP using SOS2.
      </p>
    </header>

    <!-- Formulation cards -->
    <div class="grid lg:grid-cols-3 gap-4">
      <article class="card p-5">
        <h3 class="text-lg font-semibold text-slate-800">1) Grid & Values</h3>
        <p class="text-sm text-slate-700 mt-2">
          Choose breakpoints \(\{x_i\}_{i=0}^n\) and sample \(f_i=f(x_i)\).
        </p>
        <div class="theorem text-sm mt-3">
          \[
            x_0 &lt; x_1 &lt; \cdots &lt; x_n,\qquad f_i=f(x_i)
          \]
        </div>
      </article>

      <article class="card p-5">
        <h3 class="text-lg font-semibold text-slate-800">2) Local Interpolation</h3>
        <p class="text-sm text-slate-700 mt-2">
          If \(x\in[x_i,x_{i+1}]\) and \(u=\dfrac{x-x_i}{x_{i+1}-x_i}\), then
        </p>
        <div class="theorem text-sm mt-3">
          \[
            f(x)\approx (1-u)f_i + u f_{i+1}.
          \]
        </div>
      </article>

      <article class="card p-5">
        <h3 class="text-lg font-semibold text-slate-800">3) MIP (SOS2) Model</h3>
        <p class="text-sm text-slate-700 mt-2">With convex combination weights \(\{\lambda_i\}\):</p>
        <div class="theorem text-sm mt-3 space-y-2">
          <div>\(\lambda_i\ge 0,\ \sum_i \lambda_i = 1,\ \lambda\ \text{is SOS2 on the ordered } \{x_i\}\).</div>
          <div>\(x=\sum_i \lambda_i x_i,\qquad \hat f=\sum_i \lambda_i f_i.\)</div>
        </div>
        <p class="text-xs text-slate-600 mt-2">
          SOS2 enforces that at most two adjacent \(\lambda_i\) are nonzero, selecting the active segment.
        </p>
      </article>
    </div>

    <!-- Controls -->
    <div class="mt-8 grid md:grid-cols-3 gap-4 text-sm">
      <div class="card p-4">
        <div class="font-semibold text-slate-700 mb-2">Function & Domain</div>
        <label class="flex items-center justify-between gap-2 mb-2">f(x)
          <select id="pwl_fun" class="w-40 px-2 py-1 border rounded-md">
            <option value="sin" selected>sin(x)</option>
            <option value="quad">0.2(x-1)^2 + 0.3</option>
            <option value="abs">|x-1.5|</option>
          </select>
        </label>
        <label class="flex items-center justify-between gap-2 mb-2">a (left)
          <input id="pwl_a" type="number" step="0.1" value="0" class="w-28 px-2 py-1 border rounded-md">
        </label>
        <label class="flex items-center justify-between gap-2">b (right)
          <input id="pwl_b" type="number" step="0.1" value="3.1415926535" class="w-28 px-2 py-1 border rounded-md">
        </label>
        <p class="text-xs text-slate-600 mt-2">Default \([0,\pi]\) for \(\sin x\).</p>
      </div>

      <div class="card p-4">
        <div class="font-semibold text-slate-700 mb-2">Breakpoints</div>
        <label class="block">Number of points \(n{+}1\)
          <input id="pwl_pts" type="range" min="2" max="25" step="1" value="5" class="w-full mt-2">
        </label>
        <div class="text-xs text-slate-600 mt-2">Points: <span id="pwl_pts_val">5</span></div>
        <div class="text-xs text-slate-600 mt-1">Segments: <span id="pwl_segs_val">4</span></div>
      </div>

      <div class="card p-4">
        <div class="font-semibold text-slate-700 mb-2">Quality</div>
        <div class="text-xs text-slate-600">Max abs error (dense): <span id="pwl_err">–</span></div>
        <div class="text-xs text-slate-600 mt-1">Mean abs error (dense): <span id="pwl_mae">–</span></div>
        <div class="text-xs text-slate-600 mt-1">Note: uniform grid; nonuniform can reduce error further.</div>
      </div>
    </div>

    <!-- Plot -->
    <div class="mt-6 bg-white rounded-xl border border-slate-200 p-3">
      <svg id="pwl_plot" viewBox="0 0 720 440" class="w-full h-auto">
        <defs>
          <linearGradient id="pwl_shade" x1="0" x2="0" y1="0" y2="1">
            <stop offset="0%" stop-opacity="0.22" stop-color="#94a3b8" />
            <stop offset="100%" stop-opacity="0.08" stop-color="#94a3b8" />
          </linearGradient>
        </defs>
        <!-- Axes -->
        <g id="pwl_axes"></g>
        <!-- Shade between true & approx (optional aesthetic) -->
        <path id="pwl_band" fill="url(#pwl_shade)" stroke="none"/>
        <!-- Curves -->
        <path id="pwl_true" fill="none" stroke="#0f172a" stroke-width="2"/>
        <path id="pwl_lin"  fill="none" stroke="#4338ca" stroke-width="2.25"/>
        <!-- Breakpoint markers -->
        <g id="pwl_pts_g"></g>
      </svg>
      <div class="text-xs text-slate-600 mt-2">
        Black: true \(f(x)\). Indigo: piecewise-linear interpolation. Dots: breakpoints. Use the slider to increase points.
      </div>
    </div>
  </div>
</section>

<script>
(function(){
  const svg   = document.getElementById('pwl_plot');
  if (!svg) return;

  // --- DOM refs
  const axesG = document.getElementById('pwl_axes');
  const band  = document.getElementById('pwl_band');
  const pTrue = document.getElementById('pwl_true');
  const pLin  = document.getElementById('pwl_lin');
  const ptsG  = document.getElementById('pwl_pts_g');

  const funSel = document.getElementById('pwl_fun');
  const aIn    = document.getElementById('pwl_a');
  const bIn    = document.getElementById('pwl_b');
  const nIn    = document.getElementById('pwl_pts');
  const nLab   = document.getElementById('pwl_pts_val');
  const sLab   = document.getElementById('pwl_segs_val');
  const errLab = document.getElementById('pwl_err');
  const maeLab = document.getElementById('pwl_mae');

  // --- Geometry
  const PAD = { l: 60, r: 20, t: 20, b: 50 };
  const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
  const plotW = W - PAD.l - PAD.r, plotH = H - PAD.t - PAD.b;

  function fFactory(kind){
    if (kind === 'quad') return x => 0.2*(x-1)*(x-1) + 0.3;
    if (kind === 'abs')  return x => Math.abs(x-1.5);
    return x => Math.sin(x);
  }

  function linspace(a,b,n){
    if (n<=1) return [a];
    const out=new Array(n);
    const h=(b-a)/(n-1);
    for(let i=0;i<n;i++) out[i]=a+h*i;
    return out;
  }

  function niceTicks(min,max,count=6){
    const span = Math.max(1e-12, max-min);
    const raw  = span / count;
    const p10  = Math.pow(10, Math.floor(Math.log10(raw)));
    const steps = [1,2,2.5,5,10].map(k=>k*p10);
    const step = steps.reduce((a,b)=>Math.abs(raw-a)<Math.abs(raw-b)?a:b);
    const lo = Math.floor(min/step)*step, hi = Math.ceil(max/step)*step;
    const ticks=[]; for(let v=lo; v<=hi+1e-12; v+=step) ticks.push(+v.toFixed(12));
    return {ticks,lo,hi};
  }

  function buildAxes(a,b,f){
    // Sample dense to estimate y-range
    const xd = linspace(a,b,1000);
    const yd = xd.map(f);
    let yMin = Math.min(...yd), yMax = Math.max(...yd);
    const pad = 0.05 * (yMax - yMin || 1.0);
    yMin -= pad; yMax += pad;

    const sx = x => PAD.l + (x - a) / (b - a) * plotW;
    const sy = y => PAD.t + (yMax - y) / (yMax - yMin) * plotH;

    // Axes + ticks
    const xt = niceTicks(a,b), yt = niceTicks(yMin,yMax);
    const frame = `M ${PAD.l} ${PAD.t} L ${PAD.l+plotW} ${PAD.t}
                   L ${PAD.l+plotW} ${PAD.t+plotH} L ${PAD.l} ${PAD.t+plotH} Z`;
    let ticks=''; let labels='';
    xt.ticks.forEach(v=>{ ticks += `M ${sx(v)} ${PAD.t+plotH} v 6 `; labels += `<text x="${sx(v)}" y="${PAD.t+plotH+20}" text-anchor="middle" font-size="10" fill="#64748b">${v}</text>`; });
    yt.ticks.forEach(v=>{ ticks += `M ${PAD.l} ${sy(v)} h -6 `;      labels += `<text x="${PAD.l-8}" y="${sy(v)+3}" text-anchor="end" font-size="10" fill="#64748b">${v}</text>`; });

    let zero='';
    if (yMin<=0 && 0<=yMax) zero += `M ${PAD.l} ${sy(0)} L ${PAD.l+plotW} ${sy(0)}`;
    if (a<=0 && 0<=b)      zero += ` M ${sx(0)} ${PAD.t} L ${sx(0)} ${PAD.t+plotH}`;

    axesG.innerHTML = `
      <path d="${frame}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${ticks}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${zero}"  stroke="#94a3b8" stroke-width="1.2" fill="none"/>
      ${labels}
    `;

    return {sx, sy, yMin, yMax};
  }

  function pathFromXY(xs,ys,sx,sy){
    if (!xs.length) return '';
    let d = `M ${sx(xs[0])} ${sy(ys[0])}`;
    for (let i=1;i<xs.length;i++) d += ` L ${sx(xs[i])} ${sy(ys[i])}`;
    return d;
  }

  function update(){
    let a = parseFloat(aIn.value), b = parseFloat(bIn.value);
    if (!(Number.isFinite(a) && Number.isFinite(b))) return;
    if (b <= a) b = a + 1e-6;

    const npts = Math.max(2, parseInt(nIn.value||'5',10));
    const segs = npts - 1;
    nLab.textContent = npts; sLab.textContent = segs;

    const f = fFactory(funSel.value);

    // Axes from current function & domain
    const {sx, sy} = buildAxes(a,b,f);

    // True curve (dense)
    const xd = linspace(a,b,800);
    const yd = xd.map(f);
    pTrue.setAttribute('d', pathFromXY(xd, yd, sx, sy));

    // Breakpoints (uniform) & piecewise-linear
    const xb = linspace(a,b,npts);
    const fb = xb.map(f);

    // Polyline over breakpoints
    pLin.setAttribute('d', pathFromXY(xb, fb, sx, sy));

    // Markers
    ptsG.innerHTML = xb.map((x,i)=>`<circle cx="${sx(x)}" cy="${sy(fb[i])}" r="3.5" fill="#111827" />`).join('');

    // Error metrics on dense grid
    // Compute linear interp ŷ on each dense x by locating its segment
    let maxErr = 0, sumAbs = 0;
    for (let k=0;k<xd.length;k++){
      const x = xd[k], y = yd[k];
      // locate segment i s.t. xb[i] <= x <= xb[i+1]
      let i = Math.min(xb.length-2, Math.max(0, Math.floor((x-a) / (b-a) * (xb.length-1))));
      // Guard edges
      while (i < xb.length-2 && x > xb[i+1]) i++;
      while (i > 0 && x < xb[i]) i--;
      const x0 = xb[i], x1 = xb[i+1], y0 = fb[i], y1 = fb[i+1];
      const t = (x - x0) / (x1 - x0);
      const yhat = (1 - t) * y0 + t * y1;
      const e = Math.abs(yhat - y);
      sumAbs += e; if (e > maxErr) maxErr = e;
    }
    const mae = sumAbs / xd.length;
    errLab.textContent = maxErr.toExponential(3);
    maeLab.textContent = mae.toExponential(3);

    // Optional: draw a thin band between true and interp by stitching both paths
    // (for aesthetics; not area-accurate). We’ll sample a coarser grid for performance.
    const xs = linspace(a,b,200);
    const ysTrue = xs.map(f);
    const ysLin  = xs.map(x=>{
      // same segment locate
      let i = Math.min(xb.length-2, Math.max(0, Math.floor((x-a)/(b-a)*(xb.length-1))));
      while (i < xb.length-2 && x > xb[i+1]) i++;
      while (i > 0 && x < xb[i]) i--;
      const x0=xb[i], x1=xb[i+1], y0=fb[i], y1=fb[i+1];
      const t=(x-x0)/(x1-x0);
      return (1-t)*y0 + t*y1;
    });
    const top = pathFromXY(xs, ysTrue, sx, sy);
    const bot = pathFromXY([...xs].reverse(), [...ysLin].reverse(), sx, sy);
    band.setAttribute('d', top + ' ' + bot + ' Z');
  }

  ['input','change'].forEach(ev=>{
    [funSel, aIn, bIn, nIn].forEach(el=> el.addEventListener(ev, update));
  });

  update();
})();
</script>

<!-- ======= 2D Piecewise Bilinear Interpolation (SOS2) ======= -->
<section id="pwl2d" class="py-12 bg-gradient-to-tr from-slate-50 via-brand-50 to-slate-100 border-y border-slate-200">
  <div class="max-w-7xl mx-auto px-6">
    <header class="mb-6">
      <h2 class="text-3xl font-extrabold tracking-tight text-slate-900">2D Piecewise Bilinear Interpolation: Complete SOS2 Formulation</h2>
      <p class="text-slate-700 max-w-3xl mt-2">
        Approximate \(f(x,y)\) on a rectangular grid using bilinear interpolation in each cell. Compare the true surface to its
        piecewise-bilinear surrogate, grow the grid, and see the error shrink. Models can be built with either SOS2 in both axes or a binary cell-selection scheme.
      </p>
    </header>

    <!-- Formulation cards -->
    <div class="grid lg:grid-cols-3 gap-4">
      <article class="card p-5">
        <h3 class="text-lg font-semibold text-slate-800">1) Grid & Samples</h3>
        <div class="theorem text-sm mt-2">
          \[
            x_0&lt;x_1&lt;\dots&lt;x_m,\quad y_0&lt;y_1&lt;\dots&lt;y_n,\quad
            f_{i,j}=f(x_i,y_j).
          \]
        </div>
        <p class="text-sm text-slate-700 mt-2">
          Each cell \(R_{i,j}=[x_i,x_{i+1}]\times[y_j,y_{j+1}]\) has four corner values.
        </p>
      </article>

      <article class="card p-5">
        <h3 class="text-lg font-semibold text-slate-800">2) Bilinear in a Cell</h3>
        <p class="text-sm text-slate-700 mt-2">For \((x,y)\in R_{i,j}\), with
          \(u=\frac{x-x_i}{x_{i+1}-x_i}\), \(v=\frac{y-y_j}{y_{j+1}-y_j}\):</p>
        <div class="theorem text-sm mt-3">
          \[
          \hat f(x,y)=(1-u)(1-v)f_{i,j}+u(1-v)f_{i+1,j}+(1-u)v f_{i,j+1}+uv f_{i+1,j+1}.
          \]
        </div>
      </article>

      <article class="card p-5">
        <h3 class="text-lg font-semibold text-slate-800">3) SOS2 / Binary Models</h3>
        <p class="text-sm text-slate-700 mt-2"><strong>SOS2:</strong> weights \(\lambda_{i,j}\ge 0\), \(\sum_{i,j}\lambda_{i,j}=1\), with
          \(\alpha_i=\sum_j\lambda_{i,j}\) SOS2 on \(x\), and \(\beta_j=\sum_i\lambda_{i,j}\) SOS2 on \(y\).
        </p>
        <div class="theorem text-sm mt-3 space-y-1">
          <div>\(x=\sum_{i,j}\lambda_{i,j}x_i,\quad y=\sum_{i,j}\lambda_{i,j}y_j,\quad \hat f=\sum_{i,j}\lambda_{i,j}f_{i,j}.\)</div>
        </div>
        <p class="text-sm text-slate-700 mt-3"><strong>Binary (cell selection):</strong> one active cell \(\delta_{i,j}\), corner weights sum to \(\delta_{i,j}\).
        </p>
      </article>
    </div>

    <!-- Controls -->
    <div class="mt-8 grid md:grid-cols-3 gap-4 text-sm">
      <div class="card p-4">
        <div class="font-semibold text-slate-700 mb-2">Function & Domain</div>
        <label class="flex items-center justify-between gap-2 mb-2">f(x,y)
          <select id="pwl2_fun" class="w-48 px-2 py-1 border rounded-md">
            <option value="sincos" selected>sin(x)·cos(y)</option>
            <option value="peaks">peaks-like</option>
            <option value="saddle">x·y (saddle)</option>
          </select>
        </label>
        <div class="grid grid-cols-2 gap-2">
          <label class="flex items-center justify-between gap-2">x<sub>min</sub>
            <input id="pwl2_ax" type="number" step="0.1" value="0" class="w-24 px-2 py-1 border rounded-md">
          </label>
          <label class="flex items-center justify-between gap-2">x<sub>max</sub>
            <input id="pwl2_bx" type="number" step="0.1" value="3.1415926535" class="w-24 px-2 py-1 border rounded-md">
          </label>
          <label class="flex items-center justify-between gap-2">y<sub>min</sub>
            <input id="pwl2_ay" type="number" step="0.1" value="0" class="w-24 px-2 py-1 border rounded-md">
          </label>
          <label class="flex items-center justify-between gap-2">y<sub>max</sub>
            <input id="pwl2_by" type="number" step="0.1" value="3.1415926535" class="w-24 px-2 py-1 border rounded-md">
          </label>
        </div>
        <p class="text-xs text-slate-600 mt-2">Default \([0,\pi]\times[0,\pi]\) for \(\sin x\,\cos y\).</p>
      </div>

      <div class="card p-4">
        <div class="font-semibold text-slate-700 mb-2">Grid Resolution</div>
        <label class="block">\(N_x{+}1\) points
          <input id="pwl2_nx" type="range" min="2" max="25" step="1" value="5" class="w-full mt-2">
        </label>
        <label class="block mt-3">\(N_y{+}1\) points
          <input id="pwl2_ny" type="range" min="2" max="25" step="1" value="5" class="w-full mt-2">
        </label>
        <div class="text-xs text-slate-600 mt-2">Nx: <span id="pwl2_nxv">5</span> • Ny: <span id="pwl2_nyv">5</span></div>
        <div class="text-xs text-slate-600 mt-1">Cells: <span id="pwl2_cells">16</span></div>
        <label class="mt-3 inline-flex items-center gap-2">
          <input id="pwl2_grid" type="checkbox" class="rounded" checked>
          <span>Show grid lines</span>
        </label>
      </div>

      <div class="card p-4">
        <div class="font-semibold text-slate-700 mb-2">Probe & Error</div>
        <p class="text-xs text-slate-600">Drag the crosshair on either panel to evaluate \((x^\*,y^\*)\).</p>
        <div class="text-xs text-slate-700 mt-2">Probe:
          \(x^\*=\)<span id="pwl2_xp">–</span>, \(y^\*=\)<span id="pwl2_yp">–</span>,
          \(f=\)<span id="pwl2_fp">–</span>, \(\hat f=\)<span id="pwl2_fh">–</span>, |err|=\(<span id="pwl2_fe">–</span>\)
        </div>
        <div class="text-xs text-slate-700 mt-2">Dense grid error:
          max \(|e|=\) <span id="pwl2_emax">–</span>,
          mean \(|e|=\) <span id="pwl2_emean">–</span>
        </div>
      </div>
    </div>

    <!-- Canvases -->
    <div class="mt-6 grid md:grid-cols-2 gap-4">
      <div class="card p-3">
        <h4 class="font-semibold text-slate-800 mb-2">True \(f(x,y)\)</h4>
        <div class="relative">
          <canvas id="pwl2_true" width="360" height="360" class="w-full h-auto rounded-lg border border-slate-200 bg-white"></canvas>
          <canvas id="pwl2_true_overlay" width="360" height="360" class="absolute inset-0 pointer-events-none"></canvas>
        </div>
      </div>
      <div class="card p-3">
        <h4 class="font-semibold text-slate-800 mb-2">Piecewise Bilinear \(\hat f(x,y)\)</h4>
        <div class="relative">
          <canvas id="pwl2_approx" width="360" height="360" class="w-full h-auto rounded-lg border border-slate-200 bg-white"></canvas>
          <canvas id="pwl2_approx_overlay" width="360" height="360" class="absolute inset-0 pointer-events-none"></canvas>
        </div>
      </div>
    </div>

    <!-- Model variants (quick reference) -->
    <div class="mt-8 grid md:grid-cols-2 gap-4">
      <article class="card p-5">
        <h3 class="text-lg font-semibold text-slate-800">SOS2 (both axes)</h3>
        <div class="theorem text-sm mt-2 space-y-2">
          <div>\(\lambda_{i,j}\ge 0,\ \sum_{i,j}\lambda_{i,j}=1\).</div>
          <div>\(\alpha_i=\sum_j\lambda_{i,j}\) is SOS2 over ordered \(x_i\); \(\beta_j=\sum_i\lambda_{i,j}\) is SOS2 over ordered \(y_j\).</div>
          <div>\(x=\sum_{i,j}\lambda_{i,j}x_i,\ y=\sum_{i,j}\lambda_{i,j}y_j,\ \hat f=\sum_{i,j}\lambda_{i,j}f_{i,j}.\)</div>
        </div>
      </article>
      <article class="card p-5">
        <h3 class="text-lg font-semibold text-slate-800">Binary (disaggregated)</h3>
        <div class="theorem text-sm mt-2">
          \[
          \sum_{i=0}^{m-1}\sum_{j=0}^{n-1}\delta_{i,j}=1,\quad
          \lambda_{i,j}^{00}+\lambda_{i,j}^{10}+\lambda_{i,j}^{01}+\lambda_{i,j}^{11}=\delta_{i,j}.
          \]
        </div>
        <p class="text-sm text-slate-700 mt-2">Then combine corner contributions to reconstruct \(x,y,\hat f\) for the active cell.</p>
      </article>
    </div>
  </div>
</section>

<script>
(function(){
  // Simple 2D wireframe-style visualization without Three.js
  const canT = document.getElementById('pwl2_true');
  const canA = document.getElementById('pwl2_approx');
  if (!canT || !canA) return;

  const funSel = document.getElementById('pwl2_fun');
  const axIn = document.getElementById('pwl2_ax'), bxIn = document.getElementById('pwl2_bx');
  const ayIn = document.getElementById('pwl2_ay'), byIn = document.getElementById('pwl2_by');
  const nxIn = document.getElementById('pwl2_nx'), nyIn = document.getElementById('pwl2_ny');
  const nxV = document.getElementById('pwl2_nxv'), nyV = document.getElementById('pwl2_nyv'), cellsV = document.getElementById('pwl2_cells');
  const showGrid = document.getElementById('pwl2_grid');

  const xpV = document.getElementById('pwl2_xp'), ypV = document.getElementById('pwl2_yp');
  const fpV = document.getElementById('pwl2_fp'), fhV = document.getElementById('pwl2_fh'), feV = document.getElementById('pwl2_fe');
  const emaxV = document.getElementById('pwl2_emax'), emeanV = document.getElementById('pwl2_emean');

  const ctxT = canT.getContext('2d');
  const ctxA = canA.getContext('2d');
  const W = canT.width, H = canT.height;

  // 3D projection parameters
  const proj = {
    scale: 80,
    offsetX: W/2,
    offsetY: H/2,
    angle: Math.PI/6, // 30 degrees
    tilt: Math.PI/4   // 45 degrees
  };

  function fFactory(kind){
    if (kind === 'peaks') {
      return (x, y) => {
        const sx = (x - Math.PI/2), sy = (y - Math.PI/2);
        return 0.3 * Math.sin(2*x) * Math.cos(2*y) + 0.2 * Math.sin(4*x + 4*y);
      };
    }
    if (kind === 'saddle') return (x,y) => 0.5 * (x - Math.PI/2) * (y - Math.PI/2);
    return (x,y) => Math.sin(x) * Math.cos(y);
  }

  function linspace(a, b, n){
    if (n <= 1) return [a];
    const out = new Array(n);
    const h = (b - a) / (n - 1);
    for(let i = 0; i < n; i++) out[i] = a + h * i;
    return out;
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function bilinearEval(x, y, xs, ys, F){
    let i = 0;
    while (i < xs.length - 2 && x > xs[i + 1]) i++;
    i = clamp(i, 0, xs.length - 2);
    
    let j = 0;
    while (j < ys.length - 2 && y > ys[j + 1]) j++;
    j = clamp(j, 0, ys.length - 2);

    const x0 = xs[i], x1 = xs[i + 1];
    const y0 = ys[j], y1 = ys[j + 1];
    
    const u = clamp((x - x0) / (x1 - x0), 0, 1);
    const v = clamp((y - y0) / (y1 - y0), 0, 1);

    const f00 = F[i][j], f10 = F[i + 1][j];
    const f01 = F[i][j + 1], f11 = F[i + 1][j + 1];

    return (1 - u) * (1 - v) * f00 + u * (1 - v) * f10 + (1 - u) * v * f01 + u * v * f11;
  }

  // 3D to 2D projection
  function project3D(x, y, z, ax, bx, ay, by) {
    // Normalize coordinates
    const nx = (x - ax) / (bx - ax) - 0.5;
    const ny = (y - ay) / (by - ay) - 0.5;
    const nz = z;

    // Isometric projection
    const screenX = proj.offsetX + proj.scale * (nx * Math.cos(proj.angle) - ny * Math.sin(proj.angle));
    const screenY = proj.offsetY - proj.scale * (nz + (nx * Math.sin(proj.angle) + ny * Math.cos(proj.angle)) * Math.sin(proj.tilt));
    
    return { x: screenX, y: screenY };
  }

  function drawWireframeSurface(ctx, evalFn, ax, bx, ay, by, resolution, color, lineWidth = 1) {
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    
    const step = resolution - 1;
    const dx = (bx - ax) / step;
    const dy = (by - ay) / step;

    // Draw grid lines in x direction
    for (let i = 0; i <= step; i++) {
      ctx.beginPath();
      const x = ax + i * dx;
      let first = true;
      for (let j = 0; j <= step; j++) {
        const y = ay + j * dy;
        const z = evalFn(x, y);
        const p = project3D(x, y, z, ax, bx, ay, by);
        
        if (first) {
          ctx.moveTo(p.x, p.y);
          first = false;
        } else {
          ctx.lineTo(p.x, p.y);
        }
      }
      ctx.stroke();
    }

    // Draw grid lines in y direction  
    for (let j = 0; j <= step; j++) {
      ctx.beginPath();
      const y = ay + j * dy;
      let first = true;
      for (let i = 0; i <= step; i++) {
        const x = ax + i * dx;
        const z = evalFn(x, y);
        const p = project3D(x, y, z, ax, bx, ay, by);
        
        if (first) {
          ctx.moveTo(p.x, p.y);
          first = false;
        } else {
          ctx.lineTo(p.x, p.y);
        }
      }
      ctx.stroke();
    }
  }

  function drawGridPoints(ctx, xs, ys, F, ax, bx, ay, by, color = '#ff0000', size = 4) {
    ctx.fillStyle = color;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < xs.length; i++) {
      for (let j = 0; j < ys.length; j++) {
        const p = project3D(xs[i], ys[j], F[i][j], ax, bx, ay, by);
        ctx.beginPath();
        ctx.arc(p.x, p.y, size, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      }
    }
  }

  function drawAxes(ctx, ax, bx, ay, by) {
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    
    // X axis
    ctx.beginPath();
    const x1 = project3D(ax, (ay+by)/2, 0, ax, bx, ay, by);
    const x2 = project3D(bx, (ay+by)/2, 0, ax, bx, ay, by);
    ctx.moveTo(x1.x, x1.y);
    ctx.lineTo(x2.x, x2.y);
    ctx.stroke();
    
    // Y axis  
    ctx.beginPath();
    const y1 = project3D((ax+bx)/2, ay, 0, ax, bx, ay, by);
    const y2 = project3D((ax+bx)/2, by, 0, ax, bx, ay, by);
    ctx.moveTo(y1.x, y1.y);
    ctx.lineTo(y2.x, y2.y);
    ctx.stroke();
    
    // Z axis
    ctx.beginPath();
    const z1 = project3D((ax+bx)/2, (ay+by)/2, -1, ax, bx, ay, by);
    const z2 = project3D((ax+bx)/2, (ay+by)/2, 1, ax, bx, ay, by);
    ctx.moveTo(z1.x, z1.y);
    ctx.lineTo(z2.x, z2.y);
    ctx.stroke();
  }

  function drawProbe(ctx, x, y, z, ax, bx, ay, by) {
    const p = project3D(x, y, z, ax, bx, ay, by);
    
    ctx.fillStyle = '#ff4444';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
  }

  const state = {
    ax: parseFloat(axIn.value) || 0,
    bx: parseFloat(bxIn.value) || Math.PI,
    ay: parseFloat(ayIn.value) || 0,
    by: parseFloat(byIn.value) || Math.PI,
    nx: parseInt(nxIn.value, 10) || 5,
    ny: parseInt(nyIn.value, 10) || 5,
    probe: { x: Math.PI/2, y: Math.PI/2 }
  };

  function updateDerived(){
    nxV.textContent = state.nx;
    nyV.textContent = state.ny;
    cellsV.textContent = (state.nx - 1) * (state.ny - 1);
  }

  function rebuild(){
    const f = fFactory(funSel.value);
    const {ax, bx, ay, by, nx, ny} = state;

    // Create grid
    const xs = linspace(ax, bx, nx);
    const ys = linspace(ay, by, ny);
    const F = Array.from({length: nx}, () => new Array(ny));
    
    for (let i = 0; i < nx; i++) {
      for (let j = 0; j < ny; j++) {
        F[i][j] = f(xs[i], ys[j]);
      }
    }

    // Clear canvases
    ctxT.clearRect(0, 0, W, H);
    ctxA.clearRect(0, 0, W, H);

    // Draw background
    ctxT.fillStyle = '#f8fafc';
    ctxT.fillRect(0, 0, W, H);
    ctxA.fillStyle = '#f8fafc';  
    ctxA.fillRect(0, 0, W, H);

    // Draw axes
    drawAxes(ctxT, ax, bx, ay, by);
    drawAxes(ctxA, ax, bx, ay, by);

    // Draw surfaces
    drawWireframeSurface(ctxT, (x,y) => f(x,y), ax, bx, ay, by, 20, '#4338ca', 1.5);
    drawWireframeSurface(ctxA, (x,y) => bilinearEval(x, y, xs, ys, F), ax, bx, ay, by, 20, '#059669', 1.5);

    // Draw grid if enabled
    if (showGrid.checked) {
      drawGridPoints(ctxT, xs, ys, F, ax, bx, ay, by, '#ff0000', 4);
      drawGridPoints(ctxA, xs, ys, F, ax, bx, ay, by, '#ff0000', 4);
      
      // Draw coarser grid wireframe over approximation
      drawWireframeSurface(ctxA, (x,y) => bilinearEval(x, y, xs, ys, F), ax, bx, ay, by, nx-1, '#333333', 2);
    }

    // Draw probe point
    const fx = f(state.probe.x, state.probe.y);
    const fh = bilinearEval(state.probe.x, state.probe.y, xs, ys, F);
    drawProbe(ctxT, state.probe.x, state.probe.y, fx, ax, bx, ay, by);
    drawProbe(ctxA, state.probe.x, state.probe.y, fh, ax, bx, ay, by);

    // Update probe values
    const err = Math.abs(fx - fh);
    xpV.textContent = state.probe.x.toFixed(3);
    ypV.textContent = state.probe.y.toFixed(3);
    fpV.textContent = fx.toExponential(3);
    fhV.textContent = fh.toExponential(3);
    feV.textContent = err.toExponential(3);

    // Calculate error statistics
    const sampleRes = 50;
    let maxErr = 0, sumErr = 0, count = 0;
    
    for (let j = 0; j < sampleRes; j++){
      const y = ay + j / (sampleRes - 1) * (by - ay);
      for (let i = 0; i < sampleRes; i++){
        const x = ax + i / (sampleRes - 1) * (bx - ax);
        const trueVal = f(x, y);
        const approxVal = bilinearEval(x, y, xs, ys, F);
        const error = Math.abs(trueVal - approxVal);
        
        if (Number.isFinite(error)) {
          maxErr = Math.max(maxErr, error);
          sumErr += error;
          count++;
        }
      }
    }
    
    emaxV.textContent = maxErr.toExponential(3);
    emeanV.textContent = count > 0 ? (sumErr / count).toExponential(3) : '0.000e+0';
  }

  // Mouse interaction for probe
  function handleProbeMove(e, canvas) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Simple mapping from screen to domain (approximate)
    const u = (mouseX - 50) / (W - 100);
    const v = (mouseY - 50) / (H - 100);
    
    state.probe.x = state.ax + clamp(u, 0, 1) * (state.bx - state.ax);
    state.probe.y = state.ay + clamp(1-v, 0, 1) * (state.by - state.ay);
    
    rebuild();
  }

  canT.addEventListener('click', (e) => handleProbeMove(e, canT));
  canA.addEventListener('click', (e) => handleProbeMove(e, canA));

  // Event listeners
  ['input', 'change'].forEach(evt => {
    [funSel, axIn, bxIn, ayIn, byIn, nxIn, nyIn, showGrid].forEach(el => {
      el.addEventListener(evt, () => {
        state.ax = parseFloat(axIn.value) || 0;
        state.bx = parseFloat(bxIn.value) || Math.PI;
        state.ay = parseFloat(ayIn.value) || 0;
        state.by = parseFloat(byIn.value) || Math.PI;
        state.nx = Math.max(2, parseInt(nxIn.value, 10) || 2);
        state.ny = Math.max(2, parseInt(nyIn.value, 10) || 2);
        
        if (state.bx <= state.ax) state.bx = state.ax + 1e-6;
        if (state.by <= state.ay) state.by = state.ay + 1e-6;
        
        updateDerived();
        rebuild();
      });
    });
  });

  updateDerived();
  rebuild();
})();
</script>

  <!-- ======= Content (cards) ======= -->
  <main class="max-w-7xl mx-auto px-6 py-10 print-grid">
    <!-- Logic -->
    <section id="logic" class="mb-10">
      <h3 class="text-2xl font-bold mb-3">Logical Statements</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <article class="card p-4 tip">
          <h4 class="font-semibold">Implication — <span class="text-slate-500">If \(x\) then \(y\)</span></h4>
          <div class="mt-2">$$x \le y$$</div>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">Logical NOT</h4>
          <div class="mt-2">$$\lnot y \;=\; 1 - y$$</div>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">AND — \(z = x \land y\)</h4>
          <div class="mt-2 space-y-1">$$z \le x$$ $$z \le y$$ $$x + y - 1 \le z$$</div>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">OR — \(z = x \lor y\)</h4>
          <div class="mt-2 space-y-1">$$x \le z$$ $$y \le z$$ $$z \le x + y$$</div>
        </article>
      </div>
    </section>

    <!-- Big-M -->
    <section id="bigm" class="mb-10">
      <h3 class="text-2xl font-bold mb-3">Big-M</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <article class="card p-4 tip">
          <h4 class="font-semibold">Setup Cost — <span class="text-slate-500">If \(x>0\) then \(y=1\)</span></h4>
          <div class="mt-2">$$x \le M y$$</div>
          <p class="text-xs text-slate-600 mt-2">Choose the smallest valid \(M\) to tighten the model.</p>
        </article>
      </div>
    </section>

    <!-- Conditional -->
    <section id="conditional" class="mb-10">
      <h3 class="text-2xl font-bold mb-3">Conditional Expressions</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <article class="card p-4 tip">
          <h4 class="font-semibold">If-Then — <span class="text-slate-500">if \(y=1\) then \(a x \le b\)</span></h4>
          <div class="mt-2">$$a x \le b + M(1 - y)$$</div>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">If-Then-Else</h4>
          <div class="mt-2 space-y-1">
            $$a_1 x_1 \le b + M(1 - y_1)$$
            $$a_2 x_2 \le b + M(1 - y_2)$$
            $$y_1 + y_2 = 1$$
          </div>
        </article>
      </div>
    </section>

    <!-- Precedence -->
    <section id="precedence" class="mb-10">
      <h3 class="text-2xl font-bold mb-3">Precedence</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <article class="card p-4 tip">
          <h4 class="font-semibold">\(x_i\) preceded by \(x_j\)?</h4>
          <div class="mt-2">$$x_i + d_i \le x_j + M(1 - y_{i,j})$$</div>
        </article>
      </div>
    </section>

    <!-- Linearization -->
    <section id="linearization" class="mb-10">
      <h3 class="text-2xl font-bold mb-3">Linearization</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <article class="card p-4 tip">
          <h4 class="font-semibold">Binary × Binary — <span class="text-slate-500">\(z = xy\)</span></h4>
          <div class="mt-2 space-y-1">$$z \le x$$ $$z \le y$$ $$z \ge x + y - 1$$</div>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">Real × Binary — <span class="text-slate-500">\(z = x y,\ x\in[L,U]\)</span></h4>
          <div class="mt-2 space-y-1">
            $$z \le x + U(1 - y)$$
            $$z \ge x - L(1 - y)$$
            $$z \le U y$$
            $$L y \le z$$
          </div>
        </article>
      </div>
    </section>

    <!-- Min/Max -->
    <section id="minmax" class="mb-10">
      <h3 class="text-2xl font-bold mb-3">Min-Max Gadgets</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <article class="card p-4 tip">
          <h4 class="font-semibold">\(z = \max\{x, y\}\)</h4>
          <div class="mt-2 space-y-1">
            $$z \ge x$$
            $$z \ge y$$
            $$z \le x + M(1 - b)$$
            $$x \le y + M b$$
            $$b \in \{0,1\}$$
          </div>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">\(z = \min\{x, y\}\)</h4>
          <div class="mt-2 space-y-1">
            $$z \le x$$
            $$z \le y$$
            $$z \ge x - M(1 - b)$$
            $$z \ge y - M b$$
            $$b \in \{0,1\}$$
          </div>
        </article>
      </div>
    </section>

    <!-- Extras -->
    <section id="extras" class="mb-10">
      <h3 class="text-2xl font-bold mb-3">Extras — Modeling Tips</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <article class="card p-4 tip">
          <h4 class="font-semibold">Tight Big-M</h4>
          <p class="text-sm text-slate-700 mt-2">
            Derive \(M\) from known bounds: if \(a x \le b\) and \(x\in[L,U]\), use the worst-case left-hand side to compute the smallest valid \(M\).
          </p>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">Indicator Constraints</h4>
          <p class="text-sm text-slate-700 mt-2">
            Prefer native indicators (if the solver supports them) over Big-M for numerics and automatic presolve/branching.
          </p>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">SOS2 / Piecewise Linear</h4>
          <p class="text-sm text-slate-700 mt-2">
            For \(y = f(x)\) on breakpoints, use SOS2 with convex combination; it’s tighter and faster than ad-hoc binaries.
          </p>
        </article>
        <article class="card p-4 tip">
          <h4 class="font-semibold">McCormick for Bilinear</h4>
          <p class="text-sm text-slate-700 mt-2">
            If \(w = x\,z\), \(x\in[L_x,U_x]\), \(z\in[L_z,U_z]\), add four McCormick planes; refine with partitioning for better bounds.
          </p>
        </article>
      </div>
    </section>
  </main>

  <!-- ======= Footer ======= -->
  <footer class="py-10 bg-slate-950 text-slate-200">
    <div class="max-w-7xl mx-auto px-6">
      <div class="flex flex-col md:flex-row items-center justify-between gap-4">
        <p class="text-sm">© <span id="year"></span> DAS-410049 • IP Tips & Tricks</p>
        <div class="text-xs text-slate-400">Single-page • Copy-ready • Printable</div>
      </div>
    </div>
  </footer>
    <!-- ======= Scripts ======= -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const y = document.getElementById('year'); if (y) y.textContent = new Date().getFullYear();
            const printBtn = document.getElementById('printBtn'); if (printBtn) printBtn.onclick = () => window.print();
        });
    </script>

  <!-- ======= McCormick script (axis-fixed) ======= -->
<!-- ======= McCormick script (axes fixed to initial bounds) ======= -->
<!-- ======= McCormick script (axes fixed + robust shade updates) ======= -->
<!-- ======= McCormick script (axes fixed + clipped to [xL,xU]) ======= -->

<script>
(function () {
  const svg = document.getElementById('pw_plot');
  if (!svg) return;

  const axesG = document.getElementById('pw_axes');
  const partsG = document.getElementById('pw_partitions');
  const shade  = document.getElementById('pw_shade');
  const pTrue  = document.getElementById('pw_true');
  const pUnder = document.getElementById('pw_under');
  const pOver  = document.getElementById('pw_over');

  const xLIn = document.getElementById('pw_xL');
  const xUIn = document.getElementById('pw_xU');
  const yLIn = document.getElementById('pw_yL');
  const yUIn = document.getElementById('pw_yU');
  const NxIn = document.getElementById('pw_Nx');
  const NyIn = document.getElementById('pw_Ny');
  const yFix = document.getElementById('pw_yFix');
  const yVal = document.getElementById('pw_yVal');
  const errB = document.getElementById('pw_errBound');

  document.getElementById('pw_incNx').onclick = () => { NxIn.value = (+NxIn.value || 1) + 1; update(); };
  document.getElementById('pw_decNx').onclick = () => { NxIn.value = Math.max(1, (+NxIn.value || 1) - 1); update(); };
  document.getElementById('pw_incNy').onclick = () => { NyIn.value = (+NyIn.value || 1) + 1; update(); };
  document.getElementById('pw_decNy').onclick = () => { NyIn.value = Math.max(1, (+NyIn.value || 1) - 1); update(); };

  const PAD = { l: 60, r: 20, t: 20, b: 50 };
  const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
  const plotW = W - PAD.l - PAD.r, plotH = H - PAD.t - PAD.b;

  const LAST = {};
  function n(el, k){ const v=parseFloat(el.value); if(Number.isFinite(v)){LAST[k]=v;return v;} return Number.isFinite(LAST[k])?LAST[k]:0; }
  function uniformBreaks(L,U,N){ return Array.from({length:N+1},(_,i)=>L+(U-L)*i/N); }
  function niceTicks(min,max,count=6){
    const span=max-min||1; const raw=span/count; const p10=Math.pow(10,Math.floor(Math.log10(raw)));
    const steps=[1,2,2.5,5,10].map(k=>k*p10); const step=steps.reduce((a,b)=>Math.abs(raw-a)<Math.abs(raw-b)?a:b);
    const lo=Math.floor(min/step)*step, hi=Math.ceil(max/step)*step;
    const ticks=[]; for(let v=lo; v<=hi+1e-12; v+=step) ticks.push(+v.toFixed(12)); return {ticks,lo,hi};
  }

  // Fix axes from initial values
  LAST.xL = parseFloat(xLIn.value); LAST.xU = parseFloat(xUIn.value);
  LAST.yL = parseFloat(yLIn.value); LAST.yU = parseFloat(yUIn.value);

  const xL0 = n(xLIn,'xL'), xU0 = n(xUIn,'xU');
  const yL0 = n(yLIn,'yL'), yU0 = n(yUIn,'yU');

  const FIX = (() => {
    const xMin = Math.min(xL0,xU0), xMax=Math.max(xL0,xU0);
    const corners=[xL0*yL0,xL0*yU0,xU0*yL0,xU0*yU0];
    let wMin=Math.min(...corners), wMax=Math.max(...corners);
    const pad=0.05*(wMax-wMin||1); wMin-=pad; wMax+=pad;
    const sx=x=>PAD.l+(x-xMin)/(xMax-xMin)*plotW;
    const sy=w=>PAD.t+(wMax-w)/(wMax-wMin)*plotH;
    return {xMin,xMax,wMin,wMax,sx,sy};
  })();

  function path(xs,ys){
    if(!xs.length) return '';
    let d=`M ${FIX.sx(xs[0])} ${FIX.sy(ys[0])}`;
    for(let i=1;i<xs.length;i++) d+=` L ${FIX.sx(xs[i])} ${FIX.sy(ys[i])}`;
    return d;
  }

  function renderAxesFixed(){
    const xt=niceTicks(FIX.xMin,FIX.xMax), yt=niceTicks(FIX.wMin,FIX.wMax);
    const frame = `
      M ${PAD.l} ${PAD.t} L ${PAD.l + plotW} ${PAD.t}
      L ${PAD.l + plotW} ${PAD.t + plotH}
      L ${PAD.l} ${PAD.t + plotH} Z`;
    let ticks='';
    xt.ticks.forEach(v=>ticks+=`M ${FIX.sx(v)} ${PAD.t+plotH} v 6 `);
    yt.ticks.forEach(v=>ticks+=`M ${PAD.l} ${FIX.sy(v)} h -6 `);
    let labels='';
    xt.ticks.forEach(v=>labels+=`<text x="${FIX.sx(v)}" y="${PAD.t+plotH+20}" text-anchor="middle" font-size="10" fill="#64748b">${v}</text>`);
    yt.ticks.forEach(v=>labels+=`<text x="${PAD.l-8}" y="${FIX.sy(v)+3}" text-anchor="end" font-size="10" fill="#64748b">${v}</text>`);
    let zero='';
    if(FIX.wMin<=0&&0<=FIX.wMax) zero+=`M ${PAD.l} ${FIX.sy(0)} L ${PAD.l+plotW} ${FIX.sy(0)}`;
    if(FIX.xMin<=0&&0<=FIX.xMax) zero+=` M ${FIX.sx(0)} ${PAD.t} L ${FIX.sx(0)} ${PAD.t+plotH}`;
    axesG.innerHTML = `
      <path d="${frame}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${ticks}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${zero}"  stroke="#94a3b8" stroke-width="1.2" fill="none"/>
      ${labels}
    `;
    shade.setAttribute('fill-rule','evenodd');
  }

  function activeIndex(breaks,y){
    for(let i = 0; i < breaks.length - 1; i++) {
      if(y >= breaks[i] && y <= breaks[i+1]) return i;
    }
    // If not found, clamp to valid range
    if(y < breaks[0]) return 0;
    if(y > breaks[breaks.length-1]) return breaks.length - 2;
    return 0;
  }

  function findXCell(xBreaks, x) {
    for(let i = 0; i < xBreaks.length - 1; i++) {
      if(x >= xBreaks[i] && x <= xBreaks[i+1]) return i;
    }
    // Clamp to valid range
    if(x < xBreaks[0]) return 0;
    if(x > xBreaks[xBreaks.length-1]) return xBreaks.length - 2;
    return 0;
  }

  function update(){
    let xL = n(xLIn,'xL'), xU = n(xUIn,'xU');
    let yL = n(yLIn,'yL'), yU = n(yUIn,'yU');
    let Nx = Math.max(1, parseInt(NxIn.value||'1',10));
    let Ny = Math.max(1, parseInt(NyIn.value||'1',10));
    if (xU <= xL) xU = xL + 1e-6;
    if (yU <= yL) yU = yL + 1e-6;

    const y = yL + (yU - yL) * parseFloat(yFix.value || '0.5');
    yVal.textContent = (+y).toFixed(2);

    // partitions for CURRENT domain
    const xB = uniformBreaks(xL,xU,Nx);
    const yB = uniformBreaks(yL,yU,Ny);
    const m = activeIndex(yB, y);
    const yLloc = yB[m], yUloc = yB[m+1];

    // Draw partition lines (both vertical and horizontal reference)
    let partitionPath = '';
    
    // Vertical partition lines within domain bounds
    for (let k = 1; k < xB.length - 1; k++) {
      if(xB[k] >= FIX.xMin && xB[k] <= FIX.xMax) {
        partitionPath += `M ${FIX.sx(xB[k])} ${PAD.t} L ${FIX.sx(xB[k])} ${PAD.t+plotH} `;
      }
    }
    
    // Active y-interval indicator (horizontal lines)
    if(yLloc <= FIX.wMax && yUloc >= FIX.wMin) {
      const yLclamped = Math.max(FIX.wMin, yLloc);
      const yUclamped = Math.min(FIX.wMax, yUloc);
      partitionPath += `M ${PAD.l-15} ${FIX.sy(yLclamped)} L ${PAD.l-5} ${FIX.sy(yLclamped)} `;
      partitionPath += `M ${PAD.l-15} ${FIX.sy(yUclamped)} L ${PAD.l-5} ${FIX.sy(yUclamped)} `;
      partitionPath += `M ${PAD.l-10} ${FIX.sy(yLclamped)} L ${PAD.l-10} ${FIX.sy(yUclamped)} `;
    }

    partsG.innerHTML = partitionPath ? `<path d="${partitionPath}" stroke="#f59e0b" stroke-width="1.5" fill="none"/>` : '';

    // Sample across full fixed axis range for display
    const Npts = 500;
    const xsAxis = Array.from({length:Npts},(_,i)=> FIX.xMin + (FIX.xMax - FIX.xMin)*i/(Npts-1));

    // True function and piecewise approximation across full axis
    const trueWAxis = xsAxis.map(x => x*y);
    const underAxis = [], overAxis = [];

    for (let i = 0; i < xsAxis.length; i++) {
      const x = xsAxis[i];
      
      // Only compute piecewise bounds within the domain
      if(x >= xL && x <= xU) {
        const c = findXCell(xB, x);
        const xLloc = xB[c], xUloc = xB[c+1];

        const u1 = xLloc*y + x*yLloc - xLloc*yLloc;
        const u2 = xUloc*y + x*yUloc - xUloc*yUloc;
        const o1 = xUloc*y + x*yLloc - xUloc*yLloc;
        const o2 = x*yUloc + xLloc*y - xLloc*yUloc;

        underAxis.push(Math.max(u1,u2));
        overAxis.push(Math.min(o1,o2));
      } else {
        // Outside domain - use NaN to create gaps in the lines
        underAxis.push(NaN);
        overAxis.push(NaN);
      }
    }

    // Draw true function only within domain
    const xsTrue = xsAxis.filter(x => x >= xL && x <= xU);
    const trueWTrue = xsTrue.map(x => x*y);
    pTrue.setAttribute('d', path(xsTrue, trueWTrue));

    // Draw piecewise bounds (will have gaps outside domain)
    const validIndices = [];
    const xsValid = [], underValid = [], overValid = [];
    
    for(let i = 0; i < xsAxis.length; i++) {
      if(!isNaN(underAxis[i]) && !isNaN(overAxis[i])) {
        xsValid.push(xsAxis[i]);
        underValid.push(underAxis[i]);
        overValid.push(overAxis[i]);
      }
    }

    pUnder.setAttribute('d', path(xsValid, underValid));
    pOver.setAttribute('d', path(xsValid, overValid));

    // Shaded area only where bounds are valid
    if(xsValid.length > 0) {
      const top = path(xsValid, overValid);
      const bot = path([...xsValid].reverse(), [...underValid].reverse());
      shade.setAttribute('d', top + ' ' + bot + ' Z');
    } else {
      shade.setAttribute('d', '');
    }

    // Error bound calculation
    const err = ((xU - xL) * (yU - yL)) / (4 * Nx * Ny);
    errB.textContent = `≤ ${err.toExponential(2)}  (uniform ${Nx}×${Ny})`;
  }

  ['input','change'].forEach(evt=>{
    [xLIn,xUIn,yLIn,yUIn,NxIn,NyIn,yFix].forEach(el=>el.addEventListener(evt, update));
  });

  renderAxesFixed();
  update();
})();
</script>
<script>
(function () {
  const svg = document.getElementById('mcPlot');
  if (!svg) return;

  const PAD = { l: 50, r: 15, t: 15, b: 40 };
  const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
  const plotW = W - PAD.l - PAD.r, plotH = H - PAD.t - PAD.b;

  const axesG = document.getElementById('axes');
  const shade = document.getElementById('shade');
  const pTrue = document.getElementById('trueW');
  const pU1 = document.getElementById('u1');
  const pU2 = document.getElementById('u2');
  const pO1 = document.getElementById('o1');
  const pO2 = document.getElementById('o2');

  const inputs = {
    xL: document.getElementById('xL'),
    xU: document.getElementById('xU'),
    yL: document.getElementById('yL'),
    yU: document.getElementById('yU'),
    yFix: document.getElementById('yFix'),
    yVal: document.getElementById('yVal')
  };

  // helpers
  const LAST = {};
  function n(el, key) {
    const v = parseFloat(el.value);
    if (Number.isFinite(v)) { LAST[key] = v; return v; }
    return Number.isFinite(LAST[key]) ? LAST[key] : 0;
  }
  function niceTicks(min, max, count = 6) {
    const span = max - min || 1;
    const raw = span / count;
    const p10 = Math.pow(10, Math.floor(Math.log10(raw)));
    const steps = [1, 2, 2.5, 5, 10].map(k => k * p10);
    const step = steps.reduce((a,b)=>Math.abs(raw-a)<Math.abs(raw-b)?a:b);
    const lo = Math.floor(min/step)*step, hi = Math.ceil(max/step)*step;
    const ticks=[]; for(let v=lo; v<=hi+1e-12; v+=step) ticks.push(+v.toFixed(12));
    return {ticks, lo, hi};
  }

  // Fixed axis extents from initial values
  LAST.xL = parseFloat(inputs.xL.value);
  LAST.xU = parseFloat(inputs.xU.value);
  LAST.yL = parseFloat(inputs.yL.value);
  LAST.yU = parseFloat(inputs.yU.value);

  const xL0 = n(inputs.xL,'xL'), xU0 = n(inputs.xU,'xU');
  const yL0 = n(inputs.yL,'yL'), yU0 = n(inputs.yU,'yU');

  const FIX = (() => {
    const xMin = Math.min(xL0, xU0), xMax = Math.max(xL0, xU0);
    const corners = [xL0*yL0, xL0*yU0, xU0*yL0, xU0*yU0];
    let wMin = Math.min(...corners), wMax = Math.max(...corners);
    const pad = 0.05 * (wMax - wMin || 1);
    wMin -= pad; wMax += pad;
    const sx = x => PAD.l + (x - xMin) / (xMax - xMin) * plotW;
    const sy = w => PAD.t + (wMax - w) / (wMax - wMin) * plotH;
    return { xMin, xMax, wMin, wMax, sx, sy };
  })();

  function path(xs, ys) {
    if (!xs.length) return '';
    let d = `M ${FIX.sx(xs[0])} ${FIX.sy(ys[0])}`;
    for (let i=1;i<xs.length;i++) d += ` L ${FIX.sx(xs[i])} ${FIX.sy(ys[i])}`;
    return d;
  }

  function renderAxesFixed() {
    const xt = niceTicks(FIX.xMin, FIX.xMax);
    const yt = niceTicks(FIX.wMin, FIX.wMax);

    const frame = `
      M ${PAD.l} ${PAD.t} L ${PAD.l + plotW} ${PAD.t}
      L ${PAD.l + plotW} ${PAD.t + plotH}
      L ${PAD.l} ${PAD.t + plotH} Z`;

    let ticks = '';
    xt.ticks.forEach(v => ticks += `M ${FIX.sx(v)} ${PAD.t + plotH} v 6 `);
    yt.ticks.forEach(v => ticks += `M ${PAD.l} ${FIX.sy(v)} h -6 `);

    let labels = '';
    xt.ticks.forEach(v => labels += `<text x="${FIX.sx(v)}" y="${PAD.t+plotH+20}" text-anchor="middle" font-size="10" fill="#64748b">${v}</text>`);
    yt.ticks.forEach(v => labels += `<text x="${PAD.l-8}" y="${FIX.sy(v)+3}" text-anchor="end" font-size="10" fill="#64748b">${v}</text>`);

    let zero = '';
    if (FIX.wMin <= 0 && 0 <= FIX.wMax) zero += `M ${PAD.l} ${FIX.sy(0)} L ${PAD.l + plotW} ${FIX.sy(0)}`;
    if (FIX.xMin <= 0 && 0 <= FIX.xMax) zero += ` M ${FIX.sx(0)} ${PAD.t} L ${FIX.sx(0)} ${PAD.t + plotH}`;

    shade.setAttribute('fill-rule','evenodd');
    axesG.innerHTML = `
      <path d="${frame}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${ticks}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${zero}"  stroke="#94a3b8" stroke-width="1.2" fill="none"/>
      ${labels}
    `;
  }

  function update() {
    let xL = n(inputs.xL,'xL'), xU = n(inputs.xU,'xU');
    let yL = n(inputs.yL,'yL'), yU = n(inputs.yU,'yU');
    if (xU <= xL) xU = xL + 1e-6;
    if (yU <= yL) yU = yL + 1e-6;

    const y = yL + (yU - yL) * parseFloat(inputs.yFix.value || '0.5');
    inputs.yVal.textContent = (+y).toFixed(2);

    // Sample over the fixed axis range for display
    const N = 400;
    const xsAxis = Array.from({length:N}, (_,i)=> FIX.xMin + (FIX.xMax - FIX.xMin)*i/(N-1));
    const trueWAxis = xsAxis.map(x => x * y);
    const under1Axis = xsAxis.map(x => xL * y + x * yL - xL * yL);
    const under2Axis = xsAxis.map(x => xU * y + x * yU - xU * yU);
    const over1Axis  = xsAxis.map(x => xU * y + x * yL - xU * yL);
    const over2Axis  = xsAxis.map(x => x * yU + xL * y - xL * yU);

    // Constraint lines: always draw across full axis range (not clipped)
    pU1.setAttribute('d', path(xsAxis, under1Axis));
    pU2.setAttribute('d', path(xsAxis, under2Axis));
    pO1.setAttribute('d', path(xsAxis, over1Axis));
    pO2.setAttribute('d', path(xsAxis, over2Axis));

    // True line: crop to domain bounds [xL, xU]
    const xsTrue = xsAxis.filter(x => x >= xL && x <= xU);
    if (xsTrue.length > 0) {
      const trueWTrue = xsTrue.map(x => x * y);
      pTrue.setAttribute('d', path(xsTrue, trueWTrue));
    } else {
      pTrue.setAttribute('d', '');
    }

    // Shaded area: compute envelope directly at axis points using extended constraint logic
    const underAxis = xsAxis.map(x => {
      const u1 = xL * y + x * yL - xL * yL;
      const u2 = xU * y + x * yU - xU * yU;
      return Math.max(u1, u2);
    });
    
    const overAxis = xsAxis.map(x => {
      const o1 = xU * y + x * yL - xU * yL;
      const o2 = x * yU + xL * y - xL * yU;
      return Math.min(o1, o2);
    });

    // Filter to domain and feasible region
    const xsForShade = [];
    const underForShade = [];
    const overForShade = [];
    
    for (let i = 0; i < xsAxis.length; i++) {
      const x = xsAxis[i];
      if (x >= xL && x <= xU && underAxis[i] <= overAxis[i]) {
        xsForShade.push(x);
        underForShade.push(underAxis[i]);
        overForShade.push(overAxis[i]);
      }
    }

    if (xsForShade.length > 0) {
      const top = path(xsForShade, overForShade);
      const bot = path([...xsForShade].reverse(), [...underForShade].reverse());
      shade.setAttribute('d', top + ' ' + bot + ' Z');
    } else {
      shade.setAttribute('d', '');
    }
  }

  ['input','change'].forEach(evt=>{
    Object.values(inputs).forEach(el=>{
      if (el && el.tagName === 'INPUT') el.addEventListener(evt, update);
    });
  });

  renderAxesFixed();
  update();
})();
</script>

</body>

</html>