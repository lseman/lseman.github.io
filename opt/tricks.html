<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Integer Programming — Tips & Tricks</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        brand: {
                            50: '#eef2ff', 100: '#e0e7ff', 200: '#c7d2fe', 300: '#a5b4fc',
                            400: '#818cf8', 500: '#6366f1', 600: '#4f46e5', 700: '#4338ca',
                            800: '#3730a3', 900: '#312e81'
                        }
                    }
                }
            }
        }
    </script>

    <!-- MathJax (v3) -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]], displayMath: [["$$", "$$"], ["\\[", "\\]"]] },
            chtml: { linebreaks: { automatic: false }, matchFontHeight: true },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" defer></script>

    <!-- Prism (core + LaTeX component) -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.min.css" as="style"
        onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.min.css">
    </noscript>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-latex.min.js" defer></script>

    <!-- Theme styles -->
    <style>
        :root {
            /* Semantic tokens for quick retheme */
            --bg-soft: #f8fafc;
            /* slate-50 */
            --bg-card: rgba(255, 255, 255, .78);
            --ink-strong: #0f172a;
            /* slate-900 */
            --ink-soft: #475569;
            /* slate-600 */
            --ring: #e2e8f0;
            /* slate-200 */
            --grid-stroke: rgba(15, 23, 42, .06);

            /* Accents */
            --pri-50: #eef2ff;
            --pri-100: #e0e7ff;
            --pri-200: #c7d2fe;
            --pri-300: #a5b4fc;
            --pri-400: #818cf8;
            --pri-500: #6366f1;
            --pri-600: #4f46e5;
            --pri-700: #4338ca;

            --ok-50: #ecfdf5;
            --ok-200: #a7f3d0;
            --ok-600: #059669;
            /* emerald family */
            --warn-50: #fffbeb;
            --warn-200: #fde68a;
            --warn-600: #d97706;
            /* amber family  */
            --err-50: #fff1f2;
            --err-200: #fecdd3;
            --err-600: #e11d48;
            /* rose family   */
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            color: var(--ink-strong);
            background: linear-gradient(140deg, #f8fafc 0%, #eef2ff 70%);
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            backdrop-filter: saturate(120%) blur(6px);
            border: 1px solid var(--ring);
            border-radius: 1rem;
        }

        /* Note styles */
        .theorem,
        .def,
        .warn,
        .insight {
            padding: .75rem 1rem;
            border-radius: .6rem;
            border: 1px solid var(--ring);
            box-shadow: 0 1px 0 rgba(15, 23, 42, .02);
        }

        .theorem {
            background: var(--pri-50);
            border-left: 4px solid var(--pri-400);
        }

        .def {
            background: var(--ok-50);
            border-left: 4px solid var(--ok-600);
        }

        .warn {
            background: var(--err-50);
            border-left: 4px solid var(--err-600);
        }

        .insight {
            background: var(--warn-50);
            border-left: 4px solid var(--warn-600);
        }

        /* Subtle grid + vignette for hero */
        .bg-grid {
            background-image:
                linear-gradient(to right, var(--grid-stroke) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-stroke) 1px, transparent 1px);
            background-size: 24px 24px;
            mask-image: radial-gradient(ellipse at 50% 28%, rgba(0, 0, 0, .9), rgba(0, 0, 0, .16) 60%, transparent 76%);
        }

        /* Gentle glow in brand hue */
        .glow {
            position: absolute;
            inset: -15% -10% auto -10%;
            height: 52vh;
            background: radial-gradient(60% 60% at 50% 40%,
                    rgba(99, 102, 241, .22), rgba(129, 140, 248, .14) 42%, rgba(203, 213, 225, .10) 70%, transparent 75%);
            filter: blur(40px);
            pointer-events: none;
        }

        .fade-up {
            opacity: 0;
            transform: translateY(12px);
            animation: fadeUp .7s ease forwards .1s;
        }

        @keyframes fadeUp {
            to {
                opacity: 1;
                transform: none;
            }
        }

        /* Watermark math (very subtle) */
        .math-watermark {
            position: absolute;
            inset: 10% auto auto 55%;
            transform: translateX(-20%);
            opacity: .06;
            font-weight: 700;
            letter-spacing: .02em;
            color: #0f172a;
            pointer-events: none;
            user-select: none;
        }

        /* Print styles (A4) */
        @media print {
            @page {
                size: A4;
                margin: 10mm;
            }

            .no-print {
                display: none !important;
            }

            .print-grid {
                columns: 2;
                column-gap: 12mm;
            }

            section {
                break-inside: avoid;
            }

            .tip {
                break-inside: avoid;
                border: 1px solid var(--ring);
            }
        }
    </style>

    <!-- Prism line-numbers styling (harmonized) -->
    <style>
        pre[class*="language-"].line-numbers {
            position: relative;
            padding-left: 3.5em;
            counter-reset: linenumber;
            background: #0b1220;
            border: 1px solid #1f2937;
            border-radius: .75rem;
        }

        pre[class*="language-"].line-numbers>code {
            position: relative;
            white-space: inherit;
        }

        .line-numbers .line-numbers-rows {
            position: absolute;
            pointer-events: none;
            top: 0;
            left: 0;
            width: 3em;
            border-right: 1px solid #334155;
            user-select: none;
        }

        .line-numbers-rows>span {
            display: block;
            counter-increment: linenumber;
        }

        .line-numbers-rows>span:before {
            content: counter(linenumber);
            color: #64748b;
            display: block;
            padding-right: .6em;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        pre code {
            color: #e5e7eb;
        }
    </style>
    <style>
        .formula-container {
            animation: float 20s ease-in-out infinite;
        }

        .formula-container:nth-child(odd) {
            animation-delay: -10s;
        }

        .formula-container:nth-child(3n) {
            animation-delay: -5s;
        }

        .formula-container:nth-child(4n) {
            animation-delay: -15s;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px) rotate(0deg);
            }

            25% {
                transform: translateY(-10px) rotate(1deg);
            }

            50% {
                transform: translateY(5px) rotate(-0.5deg);
            }

            75% {
                transform: translateY(-5px) rotate(0.5deg);
            }
        }

        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .blur-effect {
            filter: blur(0.5px);
        }
    </style>
</head>

<body class="min-h-screen text-slate-800">

    <!-- ======= Hero ======= -->
    <header class="relative h-[100svh] flex items-center">

        <div aria-hidden="true" class="absolute inset-0 bg-grid"></div>
        <div aria-hidden="true" class="glow"></div>

        <div class="relative mx-auto max-w-7xl px-6 py-12 lg:py-20">
            <div class="grid lg:grid-cols-1 gap-10 items-start">

                <!-- Left: Title + Lead + TOC -->
                <div class="fade-up">
                    <header>
                        <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900 leading-[1.05]">
                            Mixed-Integer Programming Cheat-Sheet
                        </h1>
                        <p class="mt-4 text-lg text-slate-700 max-w-2xl">
                            Concise formulas and modeling idioms for MILP: logical relations, Big-M, conditional
                            constraints,
                            linearization, min/max gadgets, and McCormick envelopes. MathJax-ready, classroom-friendly,
                            and printable.
                        </p>
                    </header>

                    <!-- TOC -->
                    <nav class="mt-8 grid sm:grid-cols-2 md:grid-cols-3 gap-3 text-sm">
                        <a href="#logic"
                            class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Logical
                            Statements</a>
                        <a href="#bigm"
                            class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Big-M</a>
                        <a href="#conditional"
                            class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Conditional</a>
                        <a href="#precedence"
                            class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Precedence</a>
                        <a href="#linearization"
                            class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Linearization</a>
                        <a href="#minmax"
                            class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition">Min
                            / Max</a>
                        <a href="#mccormick"
                            class="px-4 py-2 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm hover:bg-slate-50 transition md:col-span-1 col-span-2">McCormick</a>
                    </nav>

                    <!-- Actions -->
                    <div class="mt-6 flex flex-wrap gap-3">
                        <a href="#piecewise-mccormick"
                            class="px-5 py-2.5 rounded-xl bg-brand-600 text-white font-semibold shadow hover:bg-brand-700">Jump
                            to Piecewise McCormick</a>
                        <a id="printBtn"
                            class="px-5 py-2.5 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50 cursor-pointer">Print
                            / PDF</a>
                    </div>
                </div>

            </div>
        </div>
        <!-- Watermark formula -->
        <!-- Watermark formulas -->
        <div class="pointer-events-none select-none text-slate-900/5 font-bold tracking-tight">
            <!-- Linear Programming - Top Left -->
            <div class="formula-container absolute top-[8%] left-[5%] text-2xl md:text-4xl">
                <span class="gradient-text">\(\min\; c^\top x \;\; \text{s.t.}\;\; Ax \leq b,\; x \geq 0\)</span>
            </div>

            <!-- Integer Programming - Top Right -->
            <div class="formula-container absolute top-[12%] right-[8%] text-3xl md:text-5xl rotate-[-8deg] opacity-80">
                <span>\(x \in \{0,1\}^n\)</span>
            </div>

            <!-- Lagrangian - Upper Middle -->
            <div class="formula-container absolute top-[18%] left-[35%] text-xl md:text-3xl rotate-[5deg] blur-effect">
                <span>\(\mathcal{L}(x,\lambda) = f(x) + \lambda^\top g(x)\)</span>
            </div>

            <!-- Quadratic Programming - Center Left -->
            <div class="formula-container absolute top-[30%] left-[12%] text-3xl md:text-5xl rotate-[-3deg]">
                <span>\(\min\; \frac{1}{2}x^\top Qx + c^\top x\)</span>
            </div>

            <!-- KKT Conditions - Center -->
            <div class="formula-container absolute top-[35%] left-[45%] text-lg md:text-2xl opacity-60">
                <span>\(\nabla f(x^*) + \sum_i \lambda_i \nabla g_i(x^*) = 0\)</span>
            </div>

            <!-- Semidefinite Programming - Center Right -->
            <div class="formula-container absolute top-[28%] right-[10%] text-2xl md:text-4xl rotate-[12deg]">
                <span>\(X \succeq 0,\; \text{tr}(CX) \to \min\)</span>
            </div>

            <!-- Convex Optimization - Mid Left -->
            <div class="formula-container absolute top-[45%] left-[8%] text-xl md:text-3xl rotate-[8deg] blur-effect">
                <span>\(\min_{x \in \mathcal{C}} f(x)\)</span>
            </div>

            <!-- Dual Problem - Large Center -->
            <div class="formula-container absolute top-[50%] left-[25%] text-4xl md:text-6xl rotate-[-5deg] opacity-8">
                <span>\(\max\; \sum_i p_i y_i \;\; \text{s.t.}\;\; \sum_j a_{ij} y_j \leq b_i\)</span>
            </div>

            <!-- Robust Optimization - Mid Right -->
            <div class="formula-container absolute top-[48%] right-[15%] text-2xl md:text-4xl rotate-[-10deg]">
                <span>\(\min_x \max_{\xi \in \mathcal{U}} f(x,\xi)\)</span>
            </div>

            <!-- Stochastic Programming - Lower Left -->
            <div class="formula-container absolute top-[65%] left-[6%] text-xl md:text-3xl rotate-[6deg]">
                <span>\(\min\; \mathbb{E}[Q(x,\omega)]\)</span>
            </div>

            <!-- Non-linear Programming - Lower Center -->
            <div class="formula-container absolute top-[62%] left-[40%] text-2xl md:text-4xl rotate-[-8deg] opacity-70">
                <span>\(\min\; f(x) \;\; \text{s.t.}\;\; g_i(x) \leq 0\)</span>
            </div>

            <!-- Dynamic Programming - Lower Right -->
            <div class="formula-container absolute top-[68%] right-[12%] text-xl md:text-3xl rotate-[10deg]">
                <span>\(V_t(s) = \max_a \{r(s,a) + \gamma V_{t+1}(s')\}\)</span>
            </div>

            <!-- L1 Norm Minimization - Bottom Left -->
            <div class="formula-container absolute bottom-[18%] left-[10%] text-2xl md:text-4xl blur-effect">
                <span>\(\min\; \|Ax - b\|_1\)</span>
            </div>

            <!-- Network Flow - Bottom Center -->
            <div class="formula-container absolute bottom-[15%] left-[35%] text-xl md:text-3xl rotate-[4deg]">
                <span>\(\sum_{j} x_{ij} - \sum_{k} x_{jk} = b_i\)</span>
            </div>

            <!-- Multi-objective - Bottom Right -->
            <div class="formula-container absolute bottom-[12%] right-[8%] text-xl md:text-3xl rotate-[-6deg]">
                <span>\(\min\; (f_1(x), f_2(x), \ldots, f_k(x))\)</span>
            </div>

            <!-- Gradient Descent - Very Bottom -->
            <div class="formula-container absolute bottom-[8%] left-[20%] text-lg md:text-2xl rotate-[8deg] opacity-50">
                <span>\(x_{k+1} = x_k - \alpha_k \nabla f(x_k)\)</span>
            </div>

            <!-- Newton's Method - Bottom Far Right -->
            <div
                class="formula-container absolute bottom-[6%] right-[25%] text-lg md:text-2xl rotate-[-12deg] opacity-60">
                <span>\(x_{k+1} = x_k - [\nabla^2 f(x_k)]^{-1} \nabla f(x_k)\)</span>
            </div>

            <!-- Barrier Method - Top Far Right -->
            <div class="formula-container absolute top-[5%] right-[25%] text-lg md:text-2xl rotate-[15deg] opacity-40">
                <span>\(f(x) - \mu \sum_i \log(-g_i(x))\)</span>
            </div>

            <!-- Duality Gap - Upper Left -->
            <div class="formula-container absolute top-[25%] left-[2%] text-lg md:text-2xl rotate-[-15deg] opacity-50">
                <span>\(p^* - d^* = 0\)</span>
            </div>

            <!-- Complementary Slackness - Far Right -->
            <div class="formula-container absolute top-[55%] right-[2%] text-lg md:text-2xl rotate-[18deg] opacity-45">
                <span>\(\lambda_i g_i(x^*) = 0\)</span>
            </div>

            <!-- Primal-Dual Interior Point -->
            <div class="formula-container absolute top-[75%] left-[45%] text-lg md:text-2xl rotate-[-4deg] opacity-55">
                <span>\(\mu = \frac{x^\top s}{n}\)</span>
            </div>
        </div>
    </header>

    <!-- ======= McCormick (single-box) ======= -->
    <section id="mccormick"
        class="py-12 bg-gradient-to-tr from-slate-50 via-brand-50 to-slate-100 border-b border-slate-200">
        <div class="max-w-7xl mx-auto px-6">
            <h2 class="text-3xl font-extrabold tracking-tight text-slate-900 mb-6">McCormick Envelopes</h2>

            <div class="grid lg:grid-cols-2 gap-6">
                <!-- Derivation -->
                <article class="card p-5">
                    <h3 class="text-xl font-bold mb-3">Derivation (bounded bilinear: \(w=xy\))</h3>
                    <p class="text-slate-700 mb-2">
                        Bounds: \(x\in[x_L,x_U],\; y\in[y_L,y_U]\). Using nonnegativity of products, we obtain two
                        convex lower planes and two concave upper planes:
                    </p>
                    <div class="theorem text-sm space-y-1">
                        <div><strong>Lower:</strong>
                            $$\begin{aligned}
                            w &\ge x_L y + x y_L - x_L y_L\\[-2pt]
                            w &\ge x_U y + x y_U - x_U y_U
                            \end{aligned}$$
                        </div>
                        <div><strong>Upper:</strong>
                            $$\begin{aligned}
                            w &\le x_U y + x y_L - x_U y_L\\[-2pt]
                            w &\le x y_U + x_L y - x_L y_U
                            \end{aligned}$$
                        </div>
                    </div>
                    <p class="text-slate-700 mt-3">
                        These four inequalities form the tightest convex relaxation over the rectangle, touching
                        \(w=xy\) at the four corners.
                    </p>
                    <div class="insight text-sm mt-3"><strong>Tip:</strong> Refining bounds or partitioning the box
                        yields tighter relaxations (piecewise McCormick).</div>

                    <details class="warn mt-3">
                        <summary class="font-semibold cursor-pointer">Step-by-step factorization proof</summary>
                        <div class="mt-2 text-sm space-y-2">
                            <div><em>Lower 1:</em> \((x-x_L)(y-y_L)\ge 0 \Rightarrow w \ge x_L y + x y_L - x_L y_L\)
                            </div>
                            <div><em>Lower 2:</em> \((x_U-x)(y_U-y)\ge 0 \Rightarrow w \ge x_U y + x y_U - x_U y_U\)
                            </div>
                            <div><em>Upper 1:</em> \((x_U-x)(y-y_L)\ge 0 \Rightarrow w \le x_U y + x y_L - x_U y_L\)
                            </div>
                            <div><em>Upper 2:</em> \((x-x_L)(y_U-y)\ge 0 \Rightarrow w \le x y_U + x_L y - x_L y_U\)
                            </div>
                        </div>
                    </details>
                </article>

                <!-- Interactive slice -->
                <article class="card p-5">
                    <h3 class="text-xl font-bold mb-3">Interactive 2D Slice (fix \(y\))</h3>
                    <div class="grid sm:grid-cols-2 gap-3 text-sm">
                        <label class="def flex items-center justify-between rounded-lg">x_L
                            <input id="xL" type="number" step="0.1" value="0.0"
                                class="ml-3 w-24 px-2 py-1 border rounded-md">
                        </label>
                        <label class="def flex items-center justify-between rounded-lg">x_U
                            <input id="xU" type="number" step="0.1" value="1.0"
                                class="ml-3 w-24 px-2 py-1 border rounded-md">
                        </label>
                        <label class="def flex items-center justify-between rounded-lg">y_L
                            <input id="yL" type="number" step="0.1" value="0.0"
                                class="ml-3 w-24 px-2 py-1 border rounded-md">
                        </label>
                        <label class="def flex items-center justify-between rounded-lg">y_U
                            <input id="yU" type="number" step="0.1" value="1.0"
                                class="ml-3 w-24 px-2 py-1 border rounded-md">
                        </label>
                        <label class="insight rounded-lg col-span-full">y (slice)
                            <input id="yFix" type="range" min="0" max="1" value="0.5" step="0.01" class="w-full">
                            <div class="text-xs text-slate-600 mt-1">y = <span id="yVal">0.50</span></div>
                        </label>
                    </div>

                    <div class="mt-4 bg-white rounded-xl border border-slate-200 p-3">
                        <svg id="mcPlot" viewBox="0 0 640 420" class="w-full h-auto">
                            <defs>
                                <linearGradient id="envShade" x1="0" x2="0" y1="0" y2="1">
                                    <stop offset="0%" stop-opacity="0.25" stop-color="#94a3b8" />
                                    <stop offset="100%" stop-opacity="0.1" stop-color="#94a3b8" />
                                </linearGradient>
                            </defs>
                            <!-- Axes -->
                            <g id="axes"></g>
                            <!-- Shaded envelope -->
                            <path id="shade" fill="url(#envShade)" stroke="none" />
                            <!-- Curves -->
                            <path id="trueW" fill="none" stroke="#0f172a" stroke-width="2" />
                            <path id="u1" fill="none" stroke="#a16207" stroke-dasharray="5,5" stroke-width="1.5" />
                            <path id="u2" fill="none" stroke="#b91c1c" stroke-dasharray="5,5" stroke-width="1.5" />
                            <path id="o1" fill="none" stroke="#3b82f6" stroke-dasharray="5,5" stroke-width="1.5" />
                            <path id="o2" fill="none" stroke="#22c55e" stroke-dasharray="5,5" stroke-width="1.5" />
                        </svg>
                        <div class="text-xs text-slate-600 mt-2">
                            Black: true \(w=xy\) (slice). Dashed: McCormick bounds. Shaded band: feasible envelope for
                            this \(y\).
                        </div>
                    </div>
                </article>
            </div>
        </div>
    </section>

    <!-- ======= Piecewise McCormick ======= -->
    <section id="piecewise-mccormick"
        class="py-12 bg-gradient-to-tr from-slate-50 via-brand-50 to-slate-100 border-y border-slate-200">
        <div class="max-w-7xl mx-auto px-6">
            <header class="mb-6">
                <h2 class="text-3xl font-extrabold tracking-tight text-slate-900">Piecewise McCormick Envelopes</h2>
                <p class="text-slate-700 max-w-3xl mt-2">
                    Approximate the bilinear term \(w=xy\) by partitioning the domain into smaller rectangles and
                    applying McCormick locally.
                    Increasing the number of partitions tightens the relaxation and shrinks the envelope gap. Use the
                    controls to change partitions
                    and view a slice (fixing \(y\)).
                </p>
            </header>

            <div class="mt-8 grid lg:grid-cols-3 gap-4">
                <div class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">Why piecewise?</h3>
                    <p class="text-sm text-slate-700 mt-2">
                        Standard McCormick relaxes \(w=xy\) over the whole box with four inequalities—simple but often
                        loose on large domains.
                        Partitioning the box into \(N_x\times N_y\) rectangles and applying McCormick locally yields a
                        much tighter convex envelope.
                    </p>
                    <h4 class="mt-4 font-semibold text-slate-800 text-sm">Geometric intuition</h4>
                    <ul class="list-disc pl-5 text-sm text-slate-700 mt-1 space-y-1">
                        <li>Tile the curved surface \(w=xy\) with small rectangles (cells).</li>
                        <li>Each cell has its own linear bounds (local McCormick).</li>
                        <li>Summing these bounds forms a tight global relaxation.</li>
                    </ul>
                </div>

                <div class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">Multiple-Choice Disaggregated (MCD)</h3>
                    <p class="text-sm text-slate-700 mt-2">
                        Split the x-interval into \(\{[x^L_n,x^U_n]\}\) and the y-interval into \(\{[y^L_m,y^U_m]\}\).
                        Create binary cell selectors \(z_{nm}\in\{0,1\}\) with exactly one active cell:
                    </p>
                    <p class="text-sm font-mono bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 mt-2">
                        \(\textstyle \sum_{n=1}^{N_x}\sum_{m=1}^{N_y} z_{nm} = 1.\)
                    </p>
                    <p class="text-sm text-slate-700 mt-3">
                        Disaggregate variables per cell \((\hat{x}_{nm},\hat{y}_{nm},\hat{w}_{nm})\) and link with
                        \(x=\sum_{n,m}\hat{x}_{nm},\ y=\sum_{n,m}\hat{y}_{nm},\ w=\sum_{n,m}\hat{w}_{nm}\).
                    </p>
                </div>

                <div class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">Local McCormick in each cell</h3>
                    <p class="text-sm text-slate-700 mt-2">
                        Within cell \((n,m)\), apply McCormick to \((\hat{x}_{nm},\hat{y}_{nm},\hat{w}_{nm})\) over
                        \([x^L_n,x^U_n]\times[y^L_m,y^U_m]\) scaled by \(z_{nm}\):
                    </p>
                    <p class="text-sm font-mono bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 mt-2">
                        \(\begin{aligned}
                        \hat{w}_{nm} &\ge x^L_n\,\hat{y}_{nm} + y^L_m\,\hat{x}_{nm} - x^L_n y^L_m\,z_{nm},\\
                        \hat{w}_{nm} &\ge x^U_n\,\hat{y}_{nm} + y^U_m\,\hat{x}_{nm} - x^U_n y^U_m\,z_{nm},\\
                        \hat{w}_{nm} &\le x^U_n\,\hat{y}_{nm} + y^L_m\,\hat{x}_{nm} - x^U_n y^L_m\,z_{nm},\\
                        \hat{w}_{nm} &\le x^L_n\,\hat{y}_{nm} + y^U_m\,\hat{x}_{nm} - x^L_n y^U_m\,z_{nm}.
                        \end{aligned}\)
                    </p>
                </div>
            </div>

            <div class="mt-6 grid md:grid-cols-3 gap-4 text-sm">
                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Domain</div>
                    <label class="flex items-center justify-between gap-2 mb-2">x_L
                        <input id="pw_xL" type="number" step="0.1" value="0" class="w-28 px-2 py-1 border rounded-md">
                    </label>
                    <label class="flex items-center justify-between gap-2 mb-2">x_U
                        <input id="pw_xU" type="number" step="0.1" value="1" class="w-28 px-2 py-1 border rounded-md">
                    </label>
                    <label class="flex items-center justify-between gap-2 mb-2">y_L
                        <input id="pw_yL" type="number" step="0.1" value="0" class="w-28 px-2 py-1 border rounded-md">
                    </label>
                    <label class="flex items-center justify-between gap-2">y_U
                        <input id="pw_yU" type="number" step="0.1" value="1" class="w-28 px-2 py-1 border rounded-md">
                    </label>
                </div>

                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Partitions</div>
                    <label class="flex items-center justify-between gap-2 mb-2">N<sub>x</sub> (x partitions)
                        <div class="flex items-center gap-2">
                            <button id="pw_decNx" type="button" class="px-2 py-1 border rounded-md">–</button>
                            <input id="pw_Nx" type="number" min="1" step="1" value="3"
                                class="w-20 px-2 py-1 border rounded-md">
                            <button id="pw_incNx" type="button" class="px-2 py-1 border rounded-md">+</button>
                        </div>
                    </label>
                    <label class="flex items-center justify-between gap-2">N<sub>y</sub> (y partitions)
                        <div class="flex items-center gap-2">
                            <button id="pw_decNy" type="button" class="px-2 py-1 border rounded-md">–</button>
                            <input id="pw_Ny" type="number" min="1" step="1" value="1"
                                class="w-20 px-2 py-1 border rounded-md">
                            <button id="pw_incNy" type="button" class="px-2 py-1 border rounded-md">+</button>
                        </div>
                    </label>
                    <p class="text-xs text-slate-600 mt-3">Uniform partitions; non-uniform grids can be added with
                        custom breakpoints.</p>
                </div>

                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Slice</div>
                    <label class="block">Fix y
                        <input id="pw_yFix" type="range" min="0" max="1" step="0.01" value="0.5" class="w-full mt-2">
                    </label>
                    <div class="text-xs text-slate-600 mt-2">y = <span id="pw_yVal">0.50</span></div>
                    <div class="text-xs text-slate-600 mt-2">Error bound (uniform): <span id="pw_errBound">–</span>
                    </div>
                </div>
            </div>

            <div class="mt-6 bg-white rounded-xl border border-slate-200 p-3">
                <svg id="pw_plot" viewBox="0 0 720 440" class="w-full h-auto">
                    <defs>
                        <linearGradient id="pw_envShade" x1="0" x2="0" y1="0" y2="1">
                            <stop offset="0%" stop-opacity="0.25" stop-color="#94a3b8" />
                            <stop offset="100%" stop-opacity="0.1" stop-color="#94a3b8" />
                        </linearGradient>
                    </defs>
                    <!-- Axes -->
                    <g id="pw_axes"></g>
                    <!-- Partition verticals -->
                    <g id="pw_partitions"></g>
                    <!-- Shade -->
                    <path id="pw_shade" fill="url(#pw_envShade)" stroke="none" />
                    <!-- Curves -->
                    <path id="pw_true" fill="none" stroke="#0f172a" stroke-width="2" />
                    <path id="pw_under" fill="none" stroke="#f59e0b" stroke-dasharray="6,6" stroke-width="1.5" />
                    <path id="pw_over" fill="none" stroke="#60a5fa" stroke-dasharray="6,6" stroke-width="1.5" />
                </svg>
                <div class="text-xs text-slate-600 mt-2">
                    Black: \(w=xy\) (slice). Orange/Blue: piecewise McCormick lower/upper bound for the active row.
                    Shaded band: feasible envelope. Light grid lines show x-partitions; row is chosen by the y-slider.
                </div>
            </div>

            <div class="mt-6 bg-white rounded-xl border border-slate-200 p-3">

                <section style="max-width: 980px; margin: 10px 0;">
                    <div
                        style="display:flex; flex-wrap:wrap; gap:14px; align-items:center; margin:6px 0 10px; font:12px/1 ui-sans-serif, system-ui; color:#334155;">


                        <label>
                            Link Nx = Ny
                            <input id="pw3d_linkMN" type="checkbox" checked
                                style="vertical-align:middle; margin-left:6px;">
                        </label>

                        <label>
                            Nx (3D only)
                            <input id="pw3d_Nx" type="range" min="1" max="64" step="1" value="4"
                                style="vertical-align:middle; margin-left:6px;">
                            <span id="pw3d_Nxv" style="font-variant-numeric:tabular-nums;">4</span>
                        </label>

                        <label>
                            Ny (3D only)
                            <input id="pw3d_Ny" type="range" min="1" max="64" step="1" value="4"
                                style="vertical-align:middle; margin-left:6px;">
                            <span id="pw3d_Nyv" style="font-variant-numeric:tabular-nums;">4</span>
                        </label>

                        <span style="width:1px;height:18px;background:#e2e8f0;"></span>

                        <label>
                            Auto 3D axes
                            <input id="pw3d_auto_axes" type="checkbox" checked
                                style="vertical-align:middle; margin-left:6px;">
                        </label>

                        <label>
                            Z×
                            <input id="pw3d_vz" type="range" min="1" max="8" step="0.5" value="2"
                                style="vertical-align:middle; margin-left:6px;">
                            <span id="pw3d_vzv" style="margin-left:6px; font-variant-numeric: tabular-nums;">2.0×</span>
                        </label>

                        <span style="width:1px;height:18px;background:#e2e8f0;"></span>

                        <label>
                            Auto 3D res
                            <input id="pw3d_auto_res" type="checkbox" checked
                                style="vertical-align:middle; margin-left:6px;">
                        </label>
                        <label>
                            Render res
                            <input id="pw3d_res" type="range" min="12" max="96" step="2" value="28"
                                style="vertical-align:middle; margin-left:6px;">
                            <span id="pw3d_resv"
                                style="margin-left:6px; font-variant-numeric: tabular-nums;">auto</span>
                        </label>
                    </div>

                    <canvas id="pw3d"
                        style="width: 100%; height: 460px; display:block; background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px;"></canvas>
                </section>

            </div>


        </div>

        
    </section>
    <script>
        (function () {
            // 3D canvas
            const can = document.getElementById('pw3d');
            const ctx = can?.getContext('2d');
            if (!can || !ctx) return;

            // Read-only references to your existing 2D inputs (we never write to them)
            const xLIn = document.getElementById('pw_xL');
            const xUIn = document.getElementById('pw_xU');
            const yLIn = document.getElementById('pw_yL');
            const yUIn = document.getElementById('pw_yU');
            const NxIn = document.getElementById('pw_Nx');
            const NyIn = document.getElementById('pw_Ny');

            // 3D-only controls (private; do not affect 2D)
            const mirror2d = document.getElementById('pw3d_mirror2d');
            const linkMN = document.getElementById('pw3d_linkMN');
            const Nx3dIn = document.getElementById('pw3d_Nx');
            const Ny3dIn = document.getElementById('pw3d_Ny');
            const Nx3dV = document.getElementById('pw3d_Nxv');
            const Ny3dV = document.getElementById('pw3d_Nyv');

            const autoAxes = document.getElementById('pw3d_auto_axes');
            const vzIn = document.getElementById('pw3d_vz');
            const vzV = document.getElementById('pw3d_vzv');
            const autoRes = document.getElementById('pw3d_auto_res');
            const resIn = document.getElementById('pw3d_res');
            const resV = document.getElementById('pw3d_resv');

            // Hi-DPI sizing
            function fitCanvas() {
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                const r = can.getBoundingClientRect();
                can.width = Math.max(1, Math.floor(r.width * dpr));
                can.height = Math.max(1, Math.floor(r.height * dpr));
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            fitCanvas();
            window.addEventListener('resize', () => { fitCanvas(); draw3D(); });

            // Helpers (read numeric safely)
            const LAST = {};
            const val = (el, k) => {
                const v = parseFloat(el?.value);
                if (Number.isFinite(v)) { LAST[k] = v; return v; }
                return Number.isFinite(LAST[k]) ? LAST[k] : 0;
            };

            // Snapshot initial ranges (used when Auto 3D axes is OFF)
            LAST.xL = parseFloat(xLIn.value); LAST.xU = parseFloat(xUIn.value);
            LAST.yL = parseFloat(yLIn.value); LAST.yU = parseFloat(yUIn.value);
            const xL0 = val(xLIn, 'xL'), xU0 = val(xUIn, 'xU');
            const yL0 = val(yLIn, 'yL'), yU0 = val(yUIn, 'yU');

            // Interaction
            const proj = {
                scale: 150,
                angle: Math.PI / 6,
                tilt: Math.PI / 4,
                offsetX: () => can.getBoundingClientRect().width / 2,
                offsetY: () => can.getBoundingClientRect().height / 2,
            };
            let vz = parseFloat(vzIn.value) || 1; vzV.textContent = vz.toFixed(1) + '×';

            let dragging = false, lx = 0, ly = 0;
            can.addEventListener('mousedown', e => { dragging = true; lx = e.clientX; ly = e.clientY; });
            window.addEventListener('mouseup', () => dragging = false);
            window.addEventListener('mousemove', e => {
                if (!dragging) return;
                const dx = e.clientX - lx, dy = e.clientY - ly;
                lx = e.clientX; ly = e.clientY;
                proj.angle += dx * 0.005;
                proj.tilt = Math.max(0.1, Math.min(Math.PI - 0.1, proj.tilt - dy * 0.005));
                draw3D();
            });
            can.addEventListener('wheel', e => {
                e.preventDefault();
                const k = Math.exp(-e.deltaY * 0.001);
                proj.scale = Math.max(40, Math.min(700, proj.scale * k));
                draw3D();
            }, { passive: false });

            // Utils
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            const linspace = (a, b, n) => Array.from({ length: n }, (_, i) => a + (b - a) * (i / (n - 1)));
            const rgba = (hex, a) => {
                const c = hex.startsWith('#') ? hex.slice(1) : hex;
                const r = parseInt(c.slice(0, 2), 16), g = parseInt(c.slice(2, 4), 16), b = parseInt(c.slice(4, 6), 16);
                return `rgba(${r},${g},${b},${a})`;
            };

            // Ranges
            function getRanges() {
                const xL = val(xLIn, 'xL'), xU = val(xUIn, 'xU');
                const yL = val(yLIn, 'yL'), yU = val(yUIn, 'yU');
                const xMinC = Math.min(xL, xU), xMaxC = Math.max(xL, xU);
                const yMinC = Math.min(yL, yU), yMaxC = Math.max(yL, yU);
                const cornersC = [xL * yL, xL * yU, xU * yL, xU * yU];

                const pad = (mn, mx) => { const p = 0.05 * (mx - mn || 1); return [mn - p, mx + p]; };
                if (autoAxes.checked) {
                    const wMinC = Math.min(...cornersC), wMaxC = Math.max(...cornersC);
                    const [wMin, wMax] = pad(wMinC, wMaxC);
                    return { xMin: xMinC, xMax: xMaxC, yMin: yMinC, yMax: yMaxC, wMin, wMax };
                } else {
                    const xMin0 = Math.min(xL0, xU0), xMax0 = Math.max(xL0, xU0);
                    const yMin0 = Math.min(yL0, yU0), yMax0 = Math.max(yL0, yU0);
                    const c0 = [xL0 * yL0, xL0 * yU0, xU0 * yL0, xU0 * yU0];
                    let wMin0 = Math.min(...c0), wMax0 = Math.max(...c0);
                    const p0 = 0.05 * (wMax0 - wMin0 || 1); wMin0 -= p0; wMax0 += p0;
                    return { xMin: xMin0, xMax: xMax0, yMin: yMin0, yMax: yMax0, wMin: wMin0, wMax: wMax0 };
                }
            }

            function projector(rng) {
                return function project3D(x, y, w) {
                    const nx = (x - rng.xMin) / (rng.xMax - rng.xMin) - 0.5;
                    const ny = (y - rng.yMin) / (rng.yMax - rng.yMin) - 0.5;
                    const nz = (w - rng.wMin) / (rng.wMax - rng.wMin) - 0.5;

                    const ca = Math.cos(proj.angle), sa = Math.sin(proj.angle);
                    const cx = nx * ca - ny * sa;
                    const cy = nx * sa + ny * ca;

                    const st = Math.sin(proj.tilt), ct = Math.cos(proj.tilt);
                    const cy2 = cy * ct - nz * st;
                    const z2 = cy * st + nz * ct;

                    const sx = proj.offsetX() + proj.scale * cx;
                    const sy = proj.offsetY() - proj.scale * (cy2 + z2 * 0.9 * vz);
                    return { x: sx, y: sy, depth: z2 };
                };
            }

            // Envelopes
            const stdLower = (x, y, xL, xU, yL, yU) => Math.max(xL * y + x * yL - xL * yL, xU * y + x * yU - xU * yU);
            const stdUpper = (x, y, xL, xU, yL, yU) => Math.min(xL * y + x * yU - xL * yU, xU * y + x * yL - xU * yL);

            function findCell(breaks, v) {
                if (v <= breaks[0]) return 0;
                const last = breaks.length - 2;
                if (v >= breaks[last + 1]) return last;
                let i = 0; while (i < last && v > breaks[i + 1]) i++;
                return i;
            }

            function drawWireframe(rng, evalFn, res, color, lw, dash) {
                const P = projector(rng);
                const step = Math.max(2, res);
                const xs = linspace(rng.xMin, rng.xMax, step);
                const ys = linspace(rng.yMin, rng.yMax, step);
                const segs = [];
                for (let i = 0; i < step; i++) {
                    let prev = null;
                    for (let j = 0; j < step; j++) {
                        const p = P(xs[i], ys[j], evalFn(xs[i], ys[j]));
                        if (prev && Number.isFinite(p.y)) segs.push([prev, p]);
                        prev = p;
                    }
                }
                for (let j = 0; j < step; j++) {
                    let prev = null;
                    for (let i = 0; i < step; i++) {
                        const p = P(xs[i], ys[j], evalFn(xs[i], ys[j]));
                        if (prev && Number.isFinite(p.y)) segs.push([prev, p]);
                        prev = p;
                    }
                }
                segs.sort((a, b) => (a[0].depth + a[1].depth) - (b[0].depth + b[1].depth));

                ctx.save();
                ctx.lineWidth = lw;
                if (dash) ctx.setLineDash(dash);
                for (const [p0, p1] of segs) {
                    const depthAvg = (p0.depth + p1.depth) * 0.5;
                    const alpha = clamp(0.28 + 0.72 * (depthAvg + 0.5), 0.2, 1.0);
                    ctx.strokeStyle = rgba(color, alpha);
                    ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                }
                ctx.restore();
            }

            function drawAxesBox(rng) {
                const P = projector(rng);
                const xs = [rng.xMin, rng.xMax], ys = [rng.yMin, rng.yMax], ws = [rng.wMin, rng.wMax];
                const C = [];
                for (const x of xs) for (const y of ys) for (const w of ws) C.push(P(x, y, w));
                const E = [[0, 1], [0, 2], [0, 4], [1, 3], [1, 5], [2, 3], [2, 6], [3, 7], [4, 5], [4, 6], [5, 7], [6, 7]];
                const lines = E.map(([a, b]) => [C[a], C[b]]);
                lines.sort((a, b) => (a[0].depth + a[1].depth) - (b[0].depth + b[1].depth));

                ctx.save();
                ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1;
                for (const [p0, p1] of lines) { ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke(); }
                ctx.restore();
            }

            function drawFloorHeatmap(rng, res = 36) {
                const P = projector(rng);
                const z = 0.5 * (rng.wMin + rng.wMax);
                ctx.save();
                for (let j = 0; j < res - 1; j++) {
                    for (let i = 0; i < res - 1; i++) {
                        const x0 = rng.xMin + (rng.xMax - rng.xMin) * i / (res - 1);
                        const x1 = rng.xMin + (rng.xMax - rng.xMin) * (i + 1) / (res - 1);
                        const y0 = rng.yMin + (rng.yMax - rng.yMin) * j / (res - 1);
                        const y1 = rng.yMin + (rng.yMax - rng.yMin) * (j + 1) / (res - 1);

                        const c00 = P(x0, y0, z), c10 = P(x1, y0, z), c11 = P(x1, y1, z), c01 = P(x0, y1, z);

                        const t00 = (x0 * y0 - rng.wMin) / (rng.wMax - rng.wMin);
                        const t10 = (x1 * y0 - rng.wMin) / (rng.wMax - rng.wMin);
                        const t11 = (x1 * y1 - rng.wMin) / (rng.wMax - rng.wMin);
                        const t01 = (x0 * y1 - rng.wMin) / (rng.wMax - rng.wMin);
                        const t = clamp((t00 + t10 + t11 + t01) / 4, 0, 1);

                        const r = Math.round(255 * t), b = Math.round(255 * (1 - t)), g = Math.round(255 * (0.9 - Math.abs(t - 0.5)));
                        ctx.fillStyle = `rgba(${r},${g},${b},0.22)`;

                        ctx.beginPath();
                        ctx.moveTo(c00.x, c00.y); ctx.lineTo(c10.x, c10.y);
                        ctx.lineTo(c11.x, c11.y); ctx.lineTo(c01.x, c01.y);
                        ctx.closePath(); ctx.fill();
                    }
                }
                ctx.restore();
            }

            function drawPartitionsOnFloor(rng, xB, yB) {
                const P = projector(rng);
                const z = 0.5 * (rng.wMin + rng.wMax);
                ctx.save();
                ctx.strokeStyle = '#10b981'; ctx.lineWidth = 1;
                for (let i = 0; i < xB.length; i++) {
                    const p0 = P(xB[i], rng.yMin, z), p1 = P(xB[i], rng.yMax, z);
                    ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                }
                for (let j = 0; j < yB.length; j++) {
                    const p0 = P(rng.xMin, yB[j], z), p1 = P(rng.xMax, yB[j], z);
                    ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
                }
                ctx.restore();
            }

            function drawStdRidges(rng, xL, xU, yL, yU) {
                const P = projector(rng);
                const A = (xU - xL), B = (yU - yL);
                function drawRidge(isLower) {
                    const c = isLower ? (xU * yU - xL * yL) : (xU * yL - xL * yU);
                    const pts = [];
                    const N = 160;
                    for (let i = 0; i < N; i++) {
                        const x = rng.xMin + (rng.xMax - rng.xMin) * (i / (N - 1));
                        const y = (c - (isLower ? B * x : -B * x)) / A;
                        if (y >= rng.yMin - 1e-9 && y <= rng.yMax + 1e-9) {
                            const w = isLower ? stdLower(x, y, xL, xU, yL, yU) : stdUpper(x, y, xL, xU, yL, yU);
                            const p = P(x, y, w); pts.push(p);
                        }
                    }
                    if (pts.length < 2) return;
                    ctx.save();
                    ctx.strokeStyle = '#ef4444';
                    ctx.setLineDash([4, 3]);
                    ctx.lineWidth = 1.2;
                    ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
                    for (let k = 1; k < pts.length; k++) ctx.lineTo(pts[k].x, pts[k].y);
                    ctx.stroke();
                    ctx.restore();
                }
                drawRidge(true);  // lower ridge
                drawRidge(false); // upper ridge
            }

            function drawLegend(resLabel) {
                const x = 14, y = 16;
                ctx.save();
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(x - 10, y - 14, 270, 74, 6); ctx.fill(); ctx.stroke(); }
                else { ctx.fillRect(x - 10, y - 14, 270, 74); ctx.strokeRect(x - 10, y - 14, 270, 74); }

                // standard (red dashed)
                ctx.setLineDash([6, 4]);
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 30, y); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#334155'; ctx.fillText('Standard envelope', x + 36, y + 4);

                // piecewise (blue)
                ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(x, y + 20); ctx.lineTo(x + 30, y + 20); ctx.stroke();
                ctx.fillText('Piecewise (3D-only Nx,Ny)', x + 36, y + 24);

                // true (black)
                ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 1.2;
                ctx.beginPath(); ctx.moveTo(x, y + 40); ctx.lineTo(x + 30, y + 40); ctx.stroke();
                ctx.fillText('True w = x·y', x + 36, y + 44);

                ctx.fillStyle = '#334155';
                ctx.fillText(`Z× ${vz.toFixed(1)}  •  res: ${resLabel}`, x + 36, y + 62);
                ctx.restore();
            }

            function draw3D() {
                // Domain from 2D inputs (read-only)
                let xL = val(xLIn, 'xL'), xU = val(xUIn, 'xU');
                let yL = val(yLIn, 'yL'), yU = val(yUIn, 'yU');
                if (xU <= xL) xU = xL + 1e-6;
                if (yU <= yL) yU = yL + 1e-6;

                // Partitions: either mirror 2D or use private 3D sliders
                let Nx, Ny;
                // if (mirror2d.checked) {
                //   Nx = Math.max(1, parseInt(NxIn.value || '1', 10));
                //   Ny = Math.max(1, parseInt(NyIn.value || '1', 10));
                // } else {
                Nx = Math.max(1, parseInt(Nx3dIn.value || '1', 10));
                Ny = linkMN.checked ? Nx : Math.max(1, parseInt(Ny3dIn.value || '1', 10));
                Ny3dIn.disabled = !!linkMN.checked;
                // }
                Nx3dV.textContent = String(Nx3dIn.value);
                Ny3dV.textContent = linkMN.checked ? String(Nx3dIn.value) : String(Ny3dIn.value);

                const rng = getRanges();
                const xB = linspace(xL, xU, Nx + 1);
                const yB = linspace(yL, yU, Ny + 1);

                // Resolution
                let res = parseInt(resIn.value, 10) || 28;
                let resLabel = 'auto';
                if (autoRes.checked) {
                    const M = Math.max(Nx, Ny);
                    res = clamp(16 + 4 * M, 24, 88);
                } else {
                    resLabel = String(res);
                }
                const resStd = Math.max(res + 10, 36);
                const resPW = Math.max(res, 2 * Math.max(Nx, Ny) + 1);

                // Clear/bg
                const r = can.getBoundingClientRect();
                ctx.clearRect(0, 0, r.width, r.height);
                ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, r.width, r.height);

                // Axes, floor, partitions
                drawAxesBox(rng);
                drawFloorHeatmap(rng, 36);
                drawPartitionsOnFloor(rng, xB, yB);

                // True
                drawWireframe(rng, (x, y) => x * y, res, '#0f172a', 1.2, null);

                // Standard (continuous)
                drawWireframe(rng, (x, y) => stdLower(x, y, xL, xU, yL, yU), resStd, '#ef4444', 1.8, [6, 4]);
                drawWireframe(rng, (x, y) => stdUpper(x, y, xL, xU, yL, yU), resStd, '#ef4444', 1.8, [6, 4]);
                drawStdRidges(rng, xL, xU, yL, yU);

                // Piecewise (3D-only)
                function pwLower(x, y) {
                    if (x < xL || x > xU || y < yL || y > yU) return NaN;
                    const ix = findCell(xB, x), iy = findCell(yB, y);
                    const x0 = xB[ix], x1 = xB[ix + 1], y0 = yB[iy], y1 = yB[iy + 1];
                    const l1 = x0 * y + x * y0 - x0 * y0, l2 = x1 * y + x * y1 - x1 * y1;
                    return Math.max(l1, l2);
                }
                function pwUpper(x, y) {
                    if (x < xL || x > xU || y < yL || y > yU) return NaN;
                    const ix = findCell(xB, x), iy = findCell(yB, y);
                    const x0 = xB[ix], x1 = xB[ix + 1], y0 = yB[iy], y1 = yB[iy + 1];
                    const u1 = x0 * y + x * y1 - x0 * y1, u2 = x1 * y + x * y0 - x1 * y0;
                    return Math.min(u1, u2);
                }
                drawWireframe(rng, pwLower, resPW, '#2563eb', 1.9, null);
                drawWireframe(rng, pwUpper, resPW, '#2563eb', 1.9, null);

                drawLegend(resLabel);
            }

            // Events — note we never write to 2D inputs, only repaint on change
            ['input', 'change'].forEach(evt => {
                [xLIn, xUIn, yLIn, yUIn, NxIn, NyIn].forEach(el => el?.addEventListener(evt, draw3D));
                [mirror2d, linkMN, Nx3dIn, Ny3dIn, autoAxes, autoRes, resIn, vzIn].forEach(el => el?.addEventListener(evt, () => {
                    if (el === vzIn) { const v = parseFloat(vzIn.value) || 1; vz = v; vzV.textContent = v.toFixed(1) + '×'; }
                    draw3D();
                }));
            });

            // Initial paint
            draw3D();
        })();
    </script>


    <!-- ======= 1D Piecewise Linear Interpolation (SOS2) ======= -->
    <section id="pwl1d"
        class="py-12 bg-gradient-to-tr from-slate-50 via-brand-50 to-slate-100 border-y border-slate-200">
        <div class="max-w-7xl mx-auto px-6">
            <header class="mb-6">
                <h2 class="text-3xl font-extrabold tracking-tight text-slate-900">1D Piecewise Linear Interpolation</h2>
                <p class="text-slate-700 max-w-3xl mt-2">
                    Approximate a scalar function \(f(x)\) on a grid \(x_0&lt;x_1&lt;\dots&lt;x_n\) by connecting
                    consecutive breakpoints.
                    This yields a continuous piecewise-linear surrogate that integrates cleanly with convex optimization
                    or MIP using SOS2.
                </p>
            </header>

            <!-- Formulation cards -->
            <div class="grid lg:grid-cols-3 gap-4">
                <article class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">1) Grid & Values</h3>
                    <p class="text-sm text-slate-700 mt-2">
                        Choose breakpoints \(\{x_i\}_{i=0}^n\) and sample \(f_i=f(x_i)\).
                    </p>
                    <div class="theorem text-sm mt-3">
                        \[
                        x_0 &lt; x_1 &lt; \cdots &lt; x_n,\qquad f_i=f(x_i)
                        \]
                    </div>
                </article>

                <article class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">2) Local Interpolation</h3>
                    <p class="text-sm text-slate-700 mt-2">
                        If \(x\in[x_i,x_{i+1}]\) and \(u=\dfrac{x-x_i}{x_{i+1}-x_i}\), then
                    </p>
                    <div class="theorem text-sm mt-3">
                        \[
                        f(x)\approx (1-u)f_i + u f_{i+1}.
                        \]
                    </div>
                </article>

                <article class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">3) MIP (SOS2) Model</h3>
                    <p class="text-sm text-slate-700 mt-2">With convex combination weights \(\{\lambda_i\}\):</p>
                    <div class="theorem text-sm mt-3 space-y-2">
                        <div>\(\lambda_i\ge 0,\ \sum_i \lambda_i = 1,\ \lambda\ \text{is SOS2 on the ordered }
                            \{x_i\}\).</div>
                        <div>\(x=\sum_i \lambda_i x_i,\qquad \hat f=\sum_i \lambda_i f_i.\)</div>
                    </div>
                    <p class="text-xs text-slate-600 mt-2">
                        SOS2 enforces that at most two adjacent \(\lambda_i\) are nonzero, selecting the active segment.
                    </p>
                </article>
            </div>

            <!-- Controls -->
            <div class="mt-8 grid md:grid-cols-3 gap-4 text-sm">
                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Function & Domain</div>
                    <label class="flex items-center justify-between gap-2 mb-2">f(x)
                        <select id="pwl_fun" class="w-40 px-2 py-1 border rounded-md">
                            <option value="sin" selected>sin(x)</option>
                            <option value="quad">0.2(x-1)^2 + 0.3</option>
                            <option value="abs">|x-1.5|</option>
                        </select>
                    </label>
                    <label class="flex items-center justify-between gap-2 mb-2">a (left)
                        <input id="pwl_a" type="number" step="0.1" value="0" class="w-28 px-2 py-1 border rounded-md">
                    </label>
                    <label class="flex items-center justify-between gap-2">b (right)
                        <input id="pwl_b" type="number" step="0.1" value="3.1415926535"
                            class="w-28 px-2 py-1 border rounded-md">
                    </label>
                    <p class="text-xs text-slate-600 mt-2">Default \([0,\pi]\) for \(\sin x\).</p>
                </div>

                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Breakpoints</div>
                    <label class="block">Number of points \(n{+}1\)
                        <input id="pwl_pts" type="range" min="2" max="25" step="1" value="5" class="w-full mt-2">
                    </label>
                    <div class="text-xs text-slate-600 mt-2">Points: <span id="pwl_pts_val">5</span></div>
                    <div class="text-xs text-slate-600 mt-1">Segments: <span id="pwl_segs_val">4</span></div>
                </div>

                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Quality</div>
                    <div class="text-xs text-slate-600">Max abs error (dense): <span id="pwl_err">–</span></div>
                    <div class="text-xs text-slate-600 mt-1">Mean abs error (dense): <span id="pwl_mae">–</span></div>
                    <div class="text-xs text-slate-600 mt-1">Note: uniform grid; nonuniform can reduce error further.
                    </div>
                </div>
            </div>

            <!-- Plot -->
            <div class="mt-6 bg-white rounded-xl border border-slate-200 p-3">
                <svg id="pwl_plot" viewBox="0 0 720 440" class="w-full h-auto">
                    <defs>
                        <linearGradient id="pwl_shade" x1="0" x2="0" y1="0" y2="1">
                            <stop offset="0%" stop-opacity="0.22" stop-color="#94a3b8" />
                            <stop offset="100%" stop-opacity="0.08" stop-color="#94a3b8" />
                        </linearGradient>
                    </defs>
                    <!-- Axes -->
                    <g id="pwl_axes"></g>
                    <!-- Shade between true & approx (optional aesthetic) -->
                    <path id="pwl_band" fill="url(#pwl_shade)" stroke="none" />
                    <!-- Curves -->
                    <path id="pwl_true" fill="none" stroke="#0f172a" stroke-width="2" />
                    <path id="pwl_lin" fill="none" stroke="#4338ca" stroke-width="2.25" />
                    <!-- Breakpoint markers -->
                    <g id="pwl_pts_g"></g>
                </svg>
                <div class="text-xs text-slate-600 mt-2">
                    Black: true \(f(x)\). Indigo: piecewise-linear interpolation. Dots: breakpoints. Use the slider to
                    increase points.
                </div>
            </div>

        </div>
    </section>

    <script>
        (function () {
            const svg = document.getElementById('pwl_plot');
            if (!svg) return;

            // --- DOM refs
            const axesG = document.getElementById('pwl_axes');
            const band = document.getElementById('pwl_band');
            const pTrue = document.getElementById('pwl_true');
            const pLin = document.getElementById('pwl_lin');
            const ptsG = document.getElementById('pwl_pts_g');

            const funSel = document.getElementById('pwl_fun');
            const aIn = document.getElementById('pwl_a');
            const bIn = document.getElementById('pwl_b');
            const nIn = document.getElementById('pwl_pts');
            const nLab = document.getElementById('pwl_pts_val');
            const sLab = document.getElementById('pwl_segs_val');
            const errLab = document.getElementById('pwl_err');
            const maeLab = document.getElementById('pwl_mae');

            // --- Geometry
            const PAD = { l: 60, r: 20, t: 20, b: 50 };
            const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
            const plotW = W - PAD.l - PAD.r, plotH = H - PAD.t - PAD.b;

            function fFactory(kind) {
                if (kind === 'quad') return x => 0.2 * (x - 1) * (x - 1) + 0.3;
                if (kind === 'abs') return x => Math.abs(x - 1.5);
                return x => Math.sin(x);
            }

            function linspace(a, b, n) {
                if (n <= 1) return [a];
                const out = new Array(n);
                const h = (b - a) / (n - 1);
                for (let i = 0; i < n; i++) out[i] = a + h * i;
                return out;
            }

            function niceTicks(min, max, count = 6) {
                const span = Math.max(1e-12, max - min);
                const raw = span / count;
                const p10 = Math.pow(10, Math.floor(Math.log10(raw)));
                const steps = [1, 2, 2.5, 5, 10].map(k => k * p10);
                const step = steps.reduce((a, b) => Math.abs(raw - a) < Math.abs(raw - b) ? a : b);
                const lo = Math.floor(min / step) * step, hi = Math.ceil(max / step) * step;
                const ticks = []; for (let v = lo; v <= hi + 1e-12; v += step) ticks.push(+v.toFixed(12));
                return { ticks, lo, hi };
            }

            function buildAxes(a, b, f) {
                // Sample dense to estimate y-range
                const xd = linspace(a, b, 1000);
                const yd = xd.map(f);
                let yMin = Math.min(...yd), yMax = Math.max(...yd);
                const pad = 0.05 * (yMax - yMin || 1.0);
                yMin -= pad; yMax += pad;

                const sx = x => PAD.l + (x - a) / (b - a) * plotW;
                const sy = y => PAD.t + (yMax - y) / (yMax - yMin) * plotH;

                // Axes + ticks
                const xt = niceTicks(a, b), yt = niceTicks(yMin, yMax);
                const frame = `M ${PAD.l} ${PAD.t} L ${PAD.l + plotW} ${PAD.t}
                   L ${PAD.l + plotW} ${PAD.t + plotH} L ${PAD.l} ${PAD.t + plotH} Z`;
                let ticks = ''; let labels = '';
                xt.ticks.forEach(v => { ticks += `M ${sx(v)} ${PAD.t + plotH} v 6 `; labels += `<text x="${sx(v)}" y="${PAD.t + plotH + 20}" text-anchor="middle" font-size="10" fill="#64748b">${v}</text>`; });
                yt.ticks.forEach(v => { ticks += `M ${PAD.l} ${sy(v)} h -6 `; labels += `<text x="${PAD.l - 8}" y="${sy(v) + 3}" text-anchor="end" font-size="10" fill="#64748b">${v}</text>`; });

                let zero = '';
                if (yMin <= 0 && 0 <= yMax) zero += `M ${PAD.l} ${sy(0)} L ${PAD.l + plotW} ${sy(0)}`;
                if (a <= 0 && 0 <= b) zero += ` M ${sx(0)} ${PAD.t} L ${sx(0)} ${PAD.t + plotH}`;

                axesG.innerHTML = `
      <path d="${frame}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${ticks}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${zero}"  stroke="#94a3b8" stroke-width="1.2" fill="none"/>
      ${labels}
    `;

                return { sx, sy, yMin, yMax };
            }

            function pathFromXY(xs, ys, sx, sy) {
                if (!xs.length) return '';
                let d = `M ${sx(xs[0])} ${sy(ys[0])}`;
                for (let i = 1; i < xs.length; i++) d += ` L ${sx(xs[i])} ${sy(ys[i])}`;
                return d;
            }

            function update() {
                let a = parseFloat(aIn.value), b = parseFloat(bIn.value);
                if (!(Number.isFinite(a) && Number.isFinite(b))) return;
                if (b <= a) b = a + 1e-6;

                const npts = Math.max(2, parseInt(nIn.value || '5', 10));
                const segs = npts - 1;
                nLab.textContent = npts; sLab.textContent = segs;

                const f = fFactory(funSel.value);

                // Axes from current function & domain
                const { sx, sy } = buildAxes(a, b, f);

                // True curve (dense)
                const xd = linspace(a, b, 800);
                const yd = xd.map(f);
                pTrue.setAttribute('d', pathFromXY(xd, yd, sx, sy));

                // Breakpoints (uniform) & piecewise-linear
                const xb = linspace(a, b, npts);
                const fb = xb.map(f);

                // Polyline over breakpoints
                pLin.setAttribute('d', pathFromXY(xb, fb, sx, sy));

                // Markers
                ptsG.innerHTML = xb.map((x, i) => `<circle cx="${sx(x)}" cy="${sy(fb[i])}" r="3.5" fill="#111827" />`).join('');

                // Error metrics on dense grid
                // Compute linear interp ŷ on each dense x by locating its segment
                let maxErr = 0, sumAbs = 0;
                for (let k = 0; k < xd.length; k++) {
                    const x = xd[k], y = yd[k];
                    // locate segment i s.t. xb[i] <= x <= xb[i+1]
                    let i = Math.min(xb.length - 2, Math.max(0, Math.floor((x - a) / (b - a) * (xb.length - 1))));
                    // Guard edges
                    while (i < xb.length - 2 && x > xb[i + 1]) i++;
                    while (i > 0 && x < xb[i]) i--;
                    const x0 = xb[i], x1 = xb[i + 1], y0 = fb[i], y1 = fb[i + 1];
                    const t = (x - x0) / (x1 - x0);
                    const yhat = (1 - t) * y0 + t * y1;
                    const e = Math.abs(yhat - y);
                    sumAbs += e; if (e > maxErr) maxErr = e;
                }
                const mae = sumAbs / xd.length;
                errLab.textContent = maxErr.toExponential(3);
                maeLab.textContent = mae.toExponential(3);

                // Optional: draw a thin band between true and interp by stitching both paths
                // (for aesthetics; not area-accurate). We’ll sample a coarser grid for performance.
                const xs = linspace(a, b, 200);
                const ysTrue = xs.map(f);
                const ysLin = xs.map(x => {
                    // same segment locate
                    let i = Math.min(xb.length - 2, Math.max(0, Math.floor((x - a) / (b - a) * (xb.length - 1))));
                    while (i < xb.length - 2 && x > xb[i + 1]) i++;
                    while (i > 0 && x < xb[i]) i--;
                    const x0 = xb[i], x1 = xb[i + 1], y0 = fb[i], y1 = fb[i + 1];
                    const t = (x - x0) / (x1 - x0);
                    return (1 - t) * y0 + t * y1;
                });
                const top = pathFromXY(xs, ysTrue, sx, sy);
                const bot = pathFromXY([...xs].reverse(), [...ysLin].reverse(), sx, sy);
                band.setAttribute('d', top + ' ' + bot + ' Z');
            }

            ['input', 'change'].forEach(ev => {
                [funSel, aIn, bIn, nIn].forEach(el => el.addEventListener(ev, update));
            });

            update();
        })();
    </script>

    <!-- ======= 2D Piecewise Bilinear Interpolation (SOS2) ======= -->
    <section id="pwl2d"
        class="py-12 bg-gradient-to-tr from-slate-50 via-brand-50 to-slate-100 border-y border-slate-200">
        <div class="max-w-7xl mx-auto px-6">
            <header class="mb-6">
                <h2 class="text-3xl font-extrabold tracking-tight text-slate-900">2D Piecewise Bilinear Interpolation:
                    Complete SOS2 Formulation</h2>
                <p class="text-slate-700 max-w-3xl mt-2">
                    Approximate \(f(x,y)\) on a rectangular grid using bilinear interpolation in each cell. Compare the
                    true surface to its
                    piecewise-bilinear surrogate, grow the grid, and see the error shrink. Models can be built with
                    either SOS2 in both axes or a binary cell-selection scheme.
                </p>
            </header>

            <!-- Formulation cards -->
            <div class="grid lg:grid-cols-3 gap-4">
                <article class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">1) Grid & Samples</h3>
                    <div class="theorem text-sm mt-2">
                        \[
                        x_0&lt;x_1&lt;\dots&lt;x_m,\quad y_0&lt;y_1&lt;\dots&lt;y_n,\quad
                        f_{i,j}=f(x_i,y_j).
                        \]
                    </div>
                    <p class="text-sm text-slate-700 mt-2">
                        Each cell \(R_{i,j}=[x_i,x_{i+1}]\times[y_j,y_{j+1}]\) has four corner values.
                    </p>
                </article>

                <article class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">2) Bilinear in a Cell</h3>
                    <p class="text-sm text-slate-700 mt-2">For \((x,y)\in R_{i,j}\), with
                        \(u=\frac{x-x_i}{x_{i+1}-x_i}\), \(v=\frac{y-y_j}{y_{j+1}-y_j}\):</p>
                    <div class="theorem text-sm mt-3">
                        \[
                        \hat f(x,y)=(1-u)(1-v)f_{i,j}+u(1-v)f_{i+1,j}+(1-u)v f_{i,j+1}+uv f_{i+1,j+1}.
                        \]
                    </div>
                </article>

                <article class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">3) SOS2 / Binary Models</h3>
                    <p class="text-sm text-slate-700 mt-2"><strong>SOS2:</strong> weights \(\lambda_{i,j}\ge 0\),
                        \(\sum_{i,j}\lambda_{i,j}=1\), with
                        \(\alpha_i=\sum_j\lambda_{i,j}\) SOS2 on \(x\), and \(\beta_j=\sum_i\lambda_{i,j}\) SOS2 on
                        \(y\).
                    </p>
                    <div class="theorem text-sm mt-3 space-y-1">
                        <div>\(x=\sum_{i,j}\lambda_{i,j}x_i,\quad y=\sum_{i,j}\lambda_{i,j}y_j,\quad \hat
                            f=\sum_{i,j}\lambda_{i,j}f_{i,j}.\)</div>
                    </div>
                    <p class="text-sm text-slate-700 mt-3"><strong>Binary (cell selection):</strong> one active cell
                        \(\delta_{i,j}\), corner weights sum to \(\delta_{i,j}\).
                    </p>
                </article>
            </div>

            <!-- Controls -->
            <div class="mt-8 grid md:grid-cols-3 gap-4 text-sm">
                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Function & Domain</div>
                    <label class="flex items-center justify-between gap-2 mb-2">f(x,y)
                        <select id="pwl2_fun" class="w-48 px-2 py-1 border rounded-md">
                            <option value="sincos" selected>sin(x)·cos(y)</option>
                            <option value="peaks">peaks-like</option>
                            <option value="saddle">x·y (saddle)</option>
                        </select>
                    </label>
                    <div class="grid grid-cols-2 gap-2">
                        <label class="flex items-center justify-between gap-2">x<sub>min</sub>
                            <input id="pwl2_ax" type="number" step="0.1" value="0"
                                class="w-24 px-2 py-1 border rounded-md">
                        </label>
                        <label class="flex items-center justify-between gap-2">x<sub>max</sub>
                            <input id="pwl2_bx" type="number" step="0.1" value="3.1415926535"
                                class="w-24 px-2 py-1 border rounded-md">
                        </label>
                        <label class="flex items-center justify-between gap-2">y<sub>min</sub>
                            <input id="pwl2_ay" type="number" step="0.1" value="0"
                                class="w-24 px-2 py-1 border rounded-md">
                        </label>
                        <label class="flex items-center justify-between gap-2">y<sub>max</sub>
                            <input id="pwl2_by" type="number" step="0.1" value="3.1415926535"
                                class="w-24 px-2 py-1 border rounded-md">
                        </label>
                    </div>
                    <p class="text-xs text-slate-600 mt-2">Default \([0,\pi]\times[0,\pi]\) for \(\sin x\,\cos y\).</p>
                </div>

                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Grid Resolution</div>
                    <label class="block">\(N_x{+}1\) points
                        <input id="pwl2_nx" type="range" min="2" max="25" step="1" value="5" class="w-full mt-2">
                    </label>
                    <label class="block mt-3">\(N_y{+}1\) points
                        <input id="pwl2_ny" type="range" min="2" max="25" step="1" value="5" class="w-full mt-2">
                    </label>
                    <div class="text-xs text-slate-600 mt-2">Nx: <span id="pwl2_nxv">5</span> • Ny: <span
                            id="pwl2_nyv">5</span></div>
                    <div class="text-xs text-slate-600 mt-1">Cells: <span id="pwl2_cells">16</span></div>
                    <label class="mt-3 inline-flex items-center gap-2">
                        <input id="pwl2_grid" type="checkbox" class="rounded" checked>
                        <span>Show grid lines</span>
                    </label>
                </div>

                <div class="card p-4">
                    <div class="font-semibold text-slate-700 mb-2">Probe & Error</div>
                    <p class="text-xs text-slate-600">Drag the crosshair on either panel to evaluate \((x^\*,y^\*)\).
                    </p>
                    <div class="text-xs text-slate-700 mt-2">Probe:
                        \(x^\*=\)<span id="pwl2_xp">–</span>, \(y^\*=\)<span id="pwl2_yp">–</span>,
                        \(f=\)<span id="pwl2_fp">–</span>, \(\hat f=\)<span id="pwl2_fh">–</span>, |err|=\(<span
                            id="pwl2_fe">–</span>\)
                    </div>
                    <div class="text-xs text-slate-700 mt-2">Dense grid error:
                        max \(|e|=\) <span id="pwl2_emax">–</span>,
                        mean \(|e|=\) <span id="pwl2_emean">–</span>
                    </div>
                </div>
            </div>

            <!-- Canvases -->
            <div class="mt-6 grid md:grid-cols-2 gap-4">
                <div class="card p-3">
                    <h4 class="font-semibold text-slate-800 mb-2">True \(f(x,y)\)</h4>
                    <div class="relative">
                        <canvas id="pwl2_true" width="360" height="360"
                            class="w-full h-auto rounded-lg border border-slate-200 bg-white"></canvas>
                        <canvas id="pwl2_true_overlay" width="360" height="360"
                            class="absolute inset-0 pointer-events-none"></canvas>
                    </div>
                </div>
                <div class="card p-3">
                    <h4 class="font-semibold text-slate-800 mb-2">Piecewise Bilinear \(\hat f(x,y)\)</h4>
                    <div class="relative">
                        <canvas id="pwl2_approx" width="360" height="360"
                            class="w-full h-auto rounded-lg border border-slate-200 bg-white"></canvas>
                        <canvas id="pwl2_approx_overlay" width="360" height="360"
                            class="absolute inset-0 pointer-events-none"></canvas>
                    </div>
                </div>
            </div>

            <!-- Model variants (quick reference) -->
            <div class="mt-8 grid md:grid-cols-2 gap-4">
                <article class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">SOS2 (both axes)</h3>
                    <div class="theorem text-sm mt-2 space-y-2">
                        <div>\(\lambda_{i,j}\ge 0,\ \sum_{i,j}\lambda_{i,j}=1\).</div>
                        <div>\(\alpha_i=\sum_j\lambda_{i,j}\) is SOS2 over ordered \(x_i\);
                            \(\beta_j=\sum_i\lambda_{i,j}\) is SOS2 over ordered \(y_j\).</div>
                        <div>\(x=\sum_{i,j}\lambda_{i,j}x_i,\ y=\sum_{i,j}\lambda_{i,j}y_j,\ \hat
                            f=\sum_{i,j}\lambda_{i,j}f_{i,j}.\)</div>
                    </div>
                </article>
                <article class="card p-5">
                    <h3 class="text-lg font-semibold text-slate-800">Binary (disaggregated)</h3>
                    <div class="theorem text-sm mt-2">
                        \[
                        \sum_{i=0}^{m-1}\sum_{j=0}^{n-1}\delta_{i,j}=1,\quad
                        \lambda_{i,j}^{00}+\lambda_{i,j}^{10}+\lambda_{i,j}^{01}+\lambda_{i,j}^{11}=\delta_{i,j}.
                        \]
                    </div>
                    <p class="text-sm text-slate-700 mt-2">Then combine corner contributions to reconstruct \(x,y,\hat
                        f\) for the active cell.</p>
                </article>
            </div>
        </div>
    </section>
    <script>
        (function () {
            // ----------- grab elements -----------
            const canT = document.getElementById('pwl2_true');
            const canA = document.getElementById('pwl2_approx');
            if (!canT || !canA) return;

            const funSel = document.getElementById('pwl2_fun');
            const axIn = document.getElementById('pwl2_ax'), bxIn = document.getElementById('pwl2_bx');
            const ayIn = document.getElementById('pwl2_ay'), byIn = document.getElementById('pwl2_by');
            const nxIn = document.getElementById('pwl2_nx'), nyIn = document.getElementById('pwl2_ny');
            const nxV = document.getElementById('pwl2_nxv'), nyV = document.getElementById('pwl2_nyv'), cellsV = document.getElementById('pwl2_cells');
            const showGrid = document.getElementById('pwl2_grid');

            const xpV = document.getElementById('pwl2_xp'), ypV = document.getElementById('pwl2_yp');
            const fpV = document.getElementById('pwl2_fp'), fhV = document.getElementById('pwl2_fh'), feV = document.getElementById('pwl2_fe');
            const emaxV = document.getElementById('pwl2_emax'), emeanV = document.getElementById('pwl2_emean');

            // ----------- canvas + DPR scaling -----------
            const ctxT = canT.getContext('2d');
            const ctxA = canA.getContext('2d');
            function fitCanvas(canvas, ctx) {
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                const { width, height } = canvas.getBoundingClientRect();
                canvas.width = Math.max(1, Math.floor(width * dpr));
                canvas.height = Math.max(1, Math.floor(height * dpr));
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            function fitAll() { fitCanvas(canT, ctxT); fitCanvas(canA, ctxA); }
            fitAll();
            window.addEventListener('resize', () => { fitAll(); rebuild(); });

            // ----------- projection state (interactive) -----------
            const proj = {
                scale: 350,
                angle: 0.55,  // yaw (around z)
                tilt: 2.25,   // pitch (around x')
                offsetX: () => canT.getBoundingClientRect().width / 2,
                offsetY: () => canT.getBoundingClientRect().height / 2,
                zScale: 1,           // adaptive, set per rebuild
            };

            // mouse drag to rotate; wheel to zoom (both canvases)
            let dragging = false, lastX = 0, lastY = 0;
            function attachInteractions(canvas) {
                canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
                window.addEventListener('mouseup', () => dragging = false);
                window.addEventListener('mousemove', e => {
                    if (!dragging) return;
                    const dx = e.clientX - lastX, dy = e.clientY - lastY;
                    lastX = e.clientX; lastY = e.clientY;
                    proj.angle += dx * 0.005;
                    console.log(proj.angle);
                    proj.tilt = Math.max(0.1, Math.min(Math.PI - 0.1, proj.tilt - dy * 0.005));
                    console.log(proj.tilt);
                    rebuild();
                });
                canvas.addEventListener('wheel', e => {
                    e.preventDefault();
                    const k = Math.exp(-e.deltaY * 0.001);
                    proj.scale = Math.max(20, Math.min(600, proj.scale * k));
                    rebuild();
                }, { passive: false });
            }
            attachInteractions(canT);
            attachInteractions(canA);

            // ----------- functions -----------
            function fFactory(kind) {
                if (kind === 'peaks') {
                    return (x, y) => {
                        const sx = (x - Math.PI / 2), sy = (y - Math.PI / 2);
                        return 0.3 * Math.sin(2 * x) * Math.cos(2 * y) + 0.2 * Math.sin(4 * x + 4 * y)
                            + 0.15 * Math.exp(-(sx * sx + sy * sy));
                    };
                }
                if (kind === 'saddle') return (x, y) => 0.5 * (x - Math.PI / 2) * (y - Math.PI / 2);
                return (x, y) => Math.sin(x) * Math.cos(y);
            }
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            function linspace(a, b, n) {
                if (n <= 1) return [a];
                const out = new Array(n), h = (b - a) / (n - 1);
                for (let i = 0; i < n; i++) out[i] = a + h * i;
                return out;
            }
            function bilinearEval(x, y, xs, ys, F) {
                let i = 0; while (i < xs.length - 2 && x > xs[i + 1]) i++;
                let j = 0; while (j < ys.length - 2 && y > ys[j + 1]) j++;
                i = clamp(i, 0, xs.length - 2); j = clamp(j, 0, ys.length - 2);
                const x0 = xs[i], x1 = xs[i + 1], y0 = ys[j], y1 = ys[j + 1];
                const u = clamp((x - x0) / (x1 - x0), 0, 1);
                const v = clamp((y - y0) / (y1 - y0), 0, 1);
                const f00 = F[i][j], f10 = F[i + 1][j], f01 = F[i][j + 1], f11 = F[i + 1][j + 1];
                return (1 - u) * (1 - v) * f00 + u * (1 - v) * f10 + (1 - u) * v * f01 + u * v * f11;
            }

            // sample z-range for auto zScale (keeps shapes nice)
            function sampleZRange(evalFn, ax, bx, ay, by) {
                const S = 32;
                let zmin = +Infinity, zmax = -Infinity;
                for (let j = 0; j < S; j++) {
                    const y = ay + (by - ay) * j / (S - 1);
                    for (let i = 0; i < S; i++) {
                        const x = ax + (bx - ax) * i / (S - 1);
                        const z = evalFn(x, y);
                        if (Number.isFinite(z)) { if (z < zmin) zmin = z; if (z > zmax) zmax = z; }
                    }
                }
                if (!isFinite(zmin) || !isFinite(zmax)) zmin = -1, zmax = 1;
                return { zmin, zmax, span: Math.max(1e-9, zmax - zmin) };
            }

            // 3D -> 2D projection (isometric-ish with tilt & yaw)
            function project3D(x, y, z, ax, bx, ay, by, zmin, span, canvas) {
                const W = canvas.getBoundingClientRect().width;
                const H = canvas.getBoundingClientRect().height;

                const nx = (x - ax) / (bx - ax) - 0.5;
                const ny = (y - ay) / (by - ay) - 0.5;
                const nz = (z - zmin) / span - 0.5; // normalize z to [0,1] then center

                // rotate around z (yaw), then apply tilt (pitch). Keep it simple.
                const ca = Math.cos(proj.angle), sa = Math.sin(proj.angle);
                const cx = nx * ca - ny * sa;
                const cy = nx * sa + ny * ca;

                const st = Math.sin(proj.tilt), ct = Math.cos(proj.tilt);
                const cy2 = cy * ct - nz * st;
                const z2 = cy * st + nz * ct;

                const sx = proj.offsetX() + proj.scale * cx;
                const sy = proj.offsetY() - proj.scale * (cy2 + proj.zScale * z2);
                return { x: sx, y: sy, depth: z2 }; // depth for sorting
            }

            // generate line segments for a wire grid, then sort by depth (painter)
            function drawWireframe(ctx, evalFn, ax, bx, ay, by, res, color, lw, contour = false, canvas = canT) {
                const { zmin, span } = sampleZRange(evalFn, ax, bx, ay, by);
                const step = Math.max(2, res);
                const dx = (bx - ax) / (step - 1);
                const dy = (by - ay) / (step - 1);

                // Build segments
                const segs = [];

                // x-direction lines
                for (let i = 0; i < step; i++) {
                    const x = ax + i * dx;
                    let prev = null;
                    for (let j = 0; j < step; j++) {
                        const y = ay + j * dy;
                        const z = evalFn(x, y);
                        const p = project3D(x, y, z, ax, bx, ay, by, zmin, span, canvas);
                        if (prev) segs.push([prev, p]);
                        prev = p;
                    }
                }
                // y-direction lines
                for (let j = 0; j < step; j++) {
                    const y = ay + j * dy;
                    let prev = null;
                    for (let i = 0; i < step; i++) {
                        const x = ax + i * dx;
                        const z = evalFn(x, y);
                        const p = project3D(x, y, z, ax, bx, ay, by, zmin, span, canvas);
                        if (prev) segs.push([prev, p]);
                        prev = p;
                    }
                }

                // depth sort (back to front)
                segs.sort((a, b) => ((a[0].depth + a[1].depth) - (b[0].depth + b[1].depth)));

                ctx.lineWidth = lw;
                for (const [p0, p1] of segs) {
                    const depthAvg = (p0.depth + p1.depth) * 0.5; // ~[-?, ?]
                    const alpha = clamp(0.35 + 0.65 * (depthAvg + 0.5), 0.2, 1.0);
                    ctx.strokeStyle = colorWithAlpha(color, alpha);
                    ctx.beginPath();
                    ctx.moveTo(p0.x, p0.y);
                    ctx.lineTo(p1.x, p1.y);
                    ctx.stroke();
                }

                // optional contours (equally spaced)
                if (contour) {
                    const levels = 8;
                    ctx.lineWidth = Math.max(1, lw - 0.5);
                    for (let k = 1; k < levels; k++) {
                        const zlev = zmin + (span * k) / levels;
                        ctx.strokeStyle = colorWithAlpha('#0f172a', 0.25);
                        // marching-squares-ish sampling along rows
                        for (let j = 0; j < step - 1; j++) {
                            for (let i = 0; i < step - 1; i++) {
                                const x0 = ax + i * dx, x1 = ax + (i + 1) * dx;
                                const y0 = ay + j * dy, y1 = ay + (j + 1) * dy;
                                const z00 = evalFn(x0, y0), z10 = evalFn(x1, y0);
                                const z01 = evalFn(x0, y1), z11 = evalFn(x1, y1);
                                const edges = [];
                                function interpX(yc, za, zb) {
                                    const t = (zlev - za) / (zb - za);
                                    return clamp(x0 + t * (x1 - x0), x0, x1);
                                }
                                function interpY(xc, za, zb) {
                                    const t = (zlev - za) / (zb - za);
                                    return clamp(y0 + t * (y1 - y0), y0, y1);
                                }
                                if ((z00 - zlev) * (z10 - zlev) < 0) edges.push({ x: interpX(y0, z00, z10), y: y0 });
                                if ((z01 - zlev) * (z11 - zlev) < 0) edges.push({ x: interpX(y1, z01, z11), y: y1 });
                                if ((z00 - zlev) * (z01 - zlev) < 0) edges.push({ x: x0, y: interpY(x0, z00, z01) });
                                if ((z10 - zlev) * (z11 - zlev) < 0) edges.push({ x: x1, y: interpY(x1, z10, z11) });
                                if (edges.length === 2) {
                                    const P0 = project3D(edges[0].x, edges[0].y, zlev, ax, bx, ay, by, zmin, span, canvas);
                                    const P1 = project3D(edges[1].x, edges[1].y, zlev, ax, bx, ay, by, zmin, span, canvas);
                                    ctx.beginPath(); ctx.moveTo(P0.x, P0.y); ctx.lineTo(P1.x, P1.y); ctx.stroke();
                                }
                            }
                        }
                    }
                }

                return { zmin, span };
            }

            function colorWithAlpha(hex, a) {
                // accepts '#rrggbb'
                const c = hex.startsWith('#') ? hex.slice(1) : hex;
                const r = parseInt(c.slice(0, 2), 16), g = parseInt(c.slice(2, 4), 16), b = parseInt(c.slice(4, 6), 16);
                return `rgba(${r},${g},${b},${a})`;
            }

            function drawAxes(ctx, ax, bx, ay, by, evalFn, canvas) {
                const { zmin, span } = sampleZRange(evalFn, ax, bx, ay, by);
                ctx.strokeStyle = '#475569';
                ctx.lineWidth = 1.5;

                // draw 3 axes crossing domain center at median z
                const cx = (ax + bx) / 2, cy = (ay + by) / 2, cz = zmin + span * 0.5;

                const X0 = project3D(ax, cy, cz, ax, bx, ay, by, zmin, span, canvas);
                const X1 = project3D(bx, cy, cz, ax, bx, ay, by, zmin, span, canvas);
                const Y0 = project3D(cx, ay, cz, ax, bx, ay, by, zmin, span, canvas);
                const Y1 = project3D(cx, by, cz, ax, bx, ay, by, zmin, span, canvas);
                const Z0 = project3D(cx, cy, zmin, ax, bx, ay, by, zmin, span, canvas);
                const Z1 = project3D(cx, cy, zmin + span, ax, bx, ay, by, zmin, span, canvas);

                ctx.beginPath(); ctx.moveTo(X0.x, X0.y); ctx.lineTo(X1.x, X1.y); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(Y0.x, Y0.y); ctx.lineTo(Y1.x, Y1.y); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(Z0.x, Z0.y); ctx.lineTo(Z1.x, Z1.y); ctx.stroke();

                // ticks + labels
                ctx.fillStyle = '#0f172a';
                ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, monospace';
                const T = 4, xt = 4, yt = 4, zt = 4;

                for (let i = 0; i <= xt; i++) {
                    const x = ax + (bx - ax) * (i / xt);
                    const P = project3D(x, cy, cz, ax, bx, ay, by, zmin, span, canvas);
                    ctx.beginPath(); ctx.moveTo(P.x, P.y); ctx.lineTo(P.x + 4, P.y + 4); ctx.stroke();
                    ctx.fillText(x.toFixed(2), P.x + 6, P.y + 6);
                }
                for (let i = 0; i <= yt; i++) {
                    const y = ay + (by - ay) * (i / yt);
                    const P = project3D(cx, y, cz, ax, bx, ay, by, zmin, span, canvas);
                    ctx.beginPath(); ctx.moveTo(P.x, P.y); ctx.lineTo(P.x + 4, P.y + 4); ctx.stroke();
                    ctx.fillText(y.toFixed(2), P.x + 6, P.y + 6);
                }
                for (let i = 0; i <= zt; i++) {
                    const z = zmin + span * (i / zt);
                    const P = project3D(cx, cy, z, ax, bx, ay, by, zmin, span, canvas);
                    ctx.beginPath(); ctx.moveTo(P.x, P.y); ctx.lineTo(P.x + 4, P.y + 4); ctx.stroke();
                    ctx.fillText(z.toExponential(1), P.x + 6, P.y + 6);
                }
            }

            function drawGridPoints(ctx, xs, ys, F, ax, bx, ay, by, evalFn, canvas) {
                const { zmin, span } = sampleZRange(evalFn, ax, bx, ay, by);
                ctx.fillStyle = '#ef4444';
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                for (let i = 0; i < xs.length; i++) for (let j = 0; j < ys.length; j++) {
                    const p = project3D(xs[i], ys[j], F[i][j], ax, bx, ay, by, zmin, span, canvas);
                    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
                }
            }

            // state + probe
            const state = {
                ax: parseFloat(axIn.value) || 0,
                bx: parseFloat(bxIn.value) || Math.PI,
                ay: parseFloat(ayIn.value) || 0,
                by: parseFloat(byIn.value) || Math.PI,
                nx: Math.max(2, parseInt(nxIn.value, 10) || 5),
                ny: Math.max(2, parseInt(nyIn.value, 10) || 5),
                probe: { x: Math.PI / 2, y: Math.PI / 2 },
            };
            function updateDerived() {
                nxV.textContent = state.nx; nyV.textContent = state.ny;
                cellsV.textContent = (state.nx - 1) * (state.ny - 1);
            }

            // smarter probe mapping: invert the normalized plane approximately
            function screenToDomain(canvas, x, y) {
                const rect = canvas.getBoundingClientRect();
                const sx = x - rect.left - proj.offsetX();
                const sy = (y - rect.top - proj.offsetY());
                // approximate inverse: ignore z; invert rotation and tilt on (nx, ny)
                const cx = sx / proj.scale;
                const cy2 = -sy / proj.scale;

                const st = Math.sin(proj.tilt), ct = Math.cos(proj.tilt);
                const cy = cy2 / ct; // ignore nz contribution -> good enough for probe

                const ca = Math.cos(proj.angle), sa = Math.sin(proj.angle);
                const nx = cx * ca + cy * sa;
                const ny = -cx * sa + cy * ca;

                const u = nx + 0.5, v = ny + 0.5;
                const xi = clamp(u, 0, 1), yi = clamp(v, 0, 1);
                const xdom = state.ax + xi * (state.bx - state.ax);
                const ydom = state.ay + yi * (state.by - state.ay);
                return { x: xdom, y: ydom };
            }

            function rebuild() {
                const f = fFactory(funSel.value);
                const { ax, bx, ay, by, nx, ny } = state;

                // grid + samples
                const xs = linspace(ax, bx, nx);
                const ys = linspace(ay, by, ny);
                const F = Array.from({ length: nx }, () => new Array(ny));
                for (let i = 0; i < nx; i++) for (let j = 0; j < ny; j++) F[i][j] = f(xs[i], ys[j]);

                // clear + bg
                for (const ctx of [ctxT, ctxA]) {
                    const canvas = ctx.canvas;
                    const { width, height } = canvas.getBoundingClientRect();
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#f8fafc'; ctx.fillRect(0, 0, width, height);
                    // soft vignette
                    ctx.save();
                    const grd = ctx.createRadialGradient(width / 2, height / 2, Math.min(width, height) / 4, width / 2, height / 2, Math.max(width, height) / 1.2);
                    grd.addColorStop(0, 'rgba(255,255,255,0)');
                    grd.addColorStop(1, 'rgba(15,23,42,0.08)');
                    ctx.fillStyle = grd; ctx.fillRect(0, 0, width, height);
                    ctx.restore();
                }

                // axes
                drawAxes(ctxT, ax, bx, ay, by, (x, y) => f(x, y), canT);
                drawAxes(ctxA, ax, bx, ay, by, (x, y) => bilinearEval(x, y, xs, ys, F), canA);

                // surfaces (depth-sorted wireframe + contours)
                drawWireframe(ctxT, (x, y) => f(x, y), ax, bx, ay, by, 28, '#4338ca', 1.4, true, canT);
                drawWireframe(ctxA, (x, y) => bilinearEval(x, y, xs, ys, F), ax, bx, ay, by, 28, '#059669', 1.4, true, canA);

                // optional coarse grid overlay + points
                if (showGrid && showGrid.checked) {
                    drawGridPoints(ctxT, xs, ys, F, ax, bx, ay, by, (x, y) => f(x, y), canT);
                    drawGridPoints(ctxA, xs, ys, F, ax, bx, ay, by, (x, y) => bilinearEval(x, y, xs, ys, F), canA);
                    drawWireframe(ctxA, (x, y) => bilinearEval(x, y, xs, ys, F), ax, bx, ay, by, Math.max(3, nx), '#111827', 1.6, false, canA);
                }

                // probe + readouts
                const fx = f(state.probe.x, state.probe.y);
                const fh = bilinearEval(state.probe.x, state.probe.y, xs, ys, F);

                const { zmin: ztMin, span: ztSpan } = sampleZRange((x, y) => f(x, y), ax, bx, ay, by);
                const { zmin: zaMin, span: zaSpan } = sampleZRange((x, y) => bilinearEval(x, y, xs, ys, F), ax, bx, ay, by);

                function drawProbe(ctx, canvas, zmin, span, zval, color) {
                    const p = project3D(state.probe.x, state.probe.y, zval, ax, bx, ay, by, zmin, span, canvas);
                    ctx.fillStyle = color; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
                }
                drawProbe(ctxT, canT, ztMin, ztSpan, fx, '#ef4444');
                drawProbe(ctxA, canA, zaMin, zaSpan, fh, '#ef4444');

                // error stats
                const sampleRes = 50;
                let maxErr = 0, sumErr = 0, count = 0;
                for (let j = 0; j < sampleRes; j++) {
                    const y = ay + j / (sampleRes - 1) * (by - ay);
                    for (let i = 0; i < sampleRes; i++) {
                        const x = ax + i / (sampleRes - 1) * (bx - ax);
                        const e = Math.abs(f(x, y) - bilinearEval(x, y, xs, ys, F));
                        if (Number.isFinite(e)) { maxErr = Math.max(maxErr, e); sumErr += e; count++; }
                    }
                }
                const err = Math.abs(fx - fh);
                xpV.textContent = state.probe.x.toFixed(3);
                ypV.textContent = state.probe.y.toFixed(3);
                fpV.textContent = fx.toExponential(3);
                fhV.textContent = fh.toExponential(3);
                feV.textContent = err.toExponential(3);
                emaxV.textContent = maxErr.toExponential(3);
                emeanV.textContent = count > 0 ? (sumErr / count).toExponential(3) : '0.000e+0';
            }

            // click to move probe (both canvases)
            function handleProbeClick(e) {
                const canvas = e.currentTarget;
                const pt = screenToDomain(canvas, e.clientX, e.clientY);
                state.probe.x = pt.x; state.probe.y = pt.y;
                rebuild();
            }
            canT.addEventListener('click', handleProbeClick);
            canA.addEventListener('click', handleProbeClick);

            // inputs -> state
            function pullInputs() {
                state.ax = parseFloat(axIn.value) || 0;
                state.bx = parseFloat(bxIn.value) || Math.PI;
                state.ay = parseFloat(ayIn.value) || 0;
                state.by = parseFloat(byIn.value) || Math.PI;
                state.nx = Math.max(2, parseInt(nxIn.value, 10) || 2);
                state.ny = Math.max(2, parseInt(nyIn.value, 10) || 2);
                if (state.bx <= state.ax) state.bx = state.ax + 1e-6;
                if (state.by <= state.ay) state.by = state.ay + 1e-6;
            }
            ['input', 'change'].forEach(evt => {
                [funSel, axIn, bxIn, ayIn, byIn, nxIn, nyIn, showGrid].forEach(el => {
                    el.addEventListener(evt, () => { pullInputs(); updateDerived(); rebuild(); });
                });
            });

            updateDerived();
            rebuild();
        })();
    </script>

    <!-- ======= Content (cards) ======= -->
    <main class="max-w-7xl mx-auto px-6 py-10 print-grid">
        <!-- Logic -->
        <section id="logic" class="mb-10">
            <h3 class="text-2xl font-bold mb-3">Logical Statements</h3>
            <div class="grid md:grid-cols-2 gap-4">
                <article class="card p-4 tip">
                    <h4 class="font-semibold">Implication — <span class="text-slate-500">If \(x\) then \(y\)</span></h4>
                    <div class="mt-2">$$x \le y$$</div>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">Logical NOT</h4>
                    <div class="mt-2">$$\lnot y \;=\; 1 - y$$</div>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">AND — \(z = x \land y\)</h4>
                    <div class="mt-2 space-y-1">$$z \le x$$ $$z \le y$$ $$x + y - 1 \le z$$</div>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">OR — \(z = x \lor y\)</h4>
                    <div class="mt-2 space-y-1">$$x \le z$$ $$y \le z$$ $$z \le x + y$$</div>
                </article>
            </div>
        </section>

        <!-- Big-M -->
        <section id="bigm" class="mb-10">
            <h3 class="text-2xl font-bold mb-3">Big-M</h3>
            <div class="grid md:grid-cols-2 gap-4">
                <article class="card p-4 tip">
                    <h4 class="font-semibold">Setup Cost — <span class="text-slate-500">If \(x>0\) then \(y=1\)</span>
                    </h4>
                    <div class="mt-2">$$x \le M y$$</div>
                    <p class="text-xs text-slate-600 mt-2">Choose the smallest valid \(M\) to tighten the model.</p>
                </article>
            </div>
        </section>

        <!-- Conditional -->
        <section id="conditional" class="mb-10">
            <h3 class="text-2xl font-bold mb-3">Conditional Expressions</h3>
            <div class="grid md:grid-cols-2 gap-4">
                <article class="card p-4 tip">
                    <h4 class="font-semibold">If-Then — <span class="text-slate-500">if \(y=1\) then \(a x \le
                            b\)</span></h4>
                    <div class="mt-2">$$a x \le b + M(1 - y)$$</div>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">If-Then-Else</h4>
                    <div class="mt-2 space-y-1">
                        $$a_1 x_1 \le b + M(1 - y_1)$$
                        $$a_2 x_2 \le b + M(1 - y_2)$$
                        $$y_1 + y_2 = 1$$
                    </div>
                </article>
            </div>
        </section>

        <!-- Precedence -->
        <section id="precedence" class="mb-10">
            <h3 class="text-2xl font-bold mb-3">Precedence</h3>
            <div class="grid md:grid-cols-2 gap-4">
                <article class="card p-4 tip">
                    <h4 class="font-semibold">\(x_i\) preceded by \(x_j\)?</h4>
                    <div class="mt-2">$$x_i + d_i \le x_j + M(1 - y_{i,j})$$</div>
                </article>
            </div>
        </section>

        <!-- Linearization -->
        <section id="linearization" class="mb-10">
            <h3 class="text-2xl font-bold mb-3">Linearization</h3>
            <div class="grid md:grid-cols-2 gap-4">
                <article class="card p-4 tip">
                    <h4 class="font-semibold">Binary × Binary — <span class="text-slate-500">\(z = xy\)</span></h4>
                    <div class="mt-2 space-y-1">$$z \le x$$ $$z \le y$$ $$z \ge x + y - 1$$</div>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">Real × Binary — <span class="text-slate-500">\(z = x y,\
                            x\in[L,U]\)</span></h4>
                    <div class="mt-2 space-y-1">
                        $$z \le x + U(1 - y)$$
                        $$z \ge x - L(1 - y)$$
                        $$z \le U y$$
                        $$L y \le z$$
                    </div>
                </article>
            </div>
        </section>

        <!-- Min/Max -->
        <section id="minmax" class="mb-10">
            <h3 class="text-2xl font-bold mb-3">Min-Max Gadgets</h3>
            <div class="grid md:grid-cols-2 gap-4">
                <article class="card p-4 tip">
                    <h4 class="font-semibold">\(z = \max\{x, y\}\)</h4>
                    <div class="mt-2 space-y-1">
                        $$z \ge x$$
                        $$z \ge y$$
                        $$z \le x + M(1 - b)$$
                        $$x \le y + M b$$
                        $$b \in \{0,1\}$$
                    </div>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">\(z = \min\{x, y\}\)</h4>
                    <div class="mt-2 space-y-1">
                        $$z \le x$$
                        $$z \le y$$
                        $$z \ge x - M(1 - b)$$
                        $$z \ge y - M b$$
                        $$b \in \{0,1\}$$
                    </div>
                </article>
            </div>
        </section>

        <!-- Extras -->
        <section id="extras" class="mb-10">
            <h3 class="text-2xl font-bold mb-3">Extras — Modeling Tips</h3>
            <div class="grid md:grid-cols-2 gap-4">
                <article class="card p-4 tip">
                    <h4 class="font-semibold">Tight Big-M</h4>
                    <p class="text-sm text-slate-700 mt-2">
                        Derive \(M\) from known bounds: if \(a x \le b\) and \(x\in[L,U]\), use the worst-case left-hand
                        side to compute the smallest valid \(M\).
                    </p>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">Indicator Constraints</h4>
                    <p class="text-sm text-slate-700 mt-2">
                        Prefer native indicators (if the solver supports them) over Big-M for numerics and automatic
                        presolve/branching.
                    </p>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">SOS2 / Piecewise Linear</h4>
                    <p class="text-sm text-slate-700 mt-2">
                        For \(y = f(x)\) on breakpoints, use SOS2 with convex combination; it’s tighter and faster than
                        ad-hoc binaries.
                    </p>
                </article>
                <article class="card p-4 tip">
                    <h4 class="font-semibold">McCormick for Bilinear</h4>
                    <p class="text-sm text-slate-700 mt-2">
                        If \(w = x\,z\), \(x\in[L_x,U_x]\), \(z\in[L_z,U_z]\), add four McCormick planes; refine with
                        partitioning for better bounds.
                    </p>
                </article>
            </div>
        </section>
    </main>

    <!-- ======= Footer ======= -->
    <footer class="py-10 bg-slate-950 text-slate-200">
        <div class="max-w-7xl mx-auto px-6">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <p class="text-sm">© <span id="year"></span> DAS-410049 • IP Tips & Tricks</p>
                <div class="text-xs text-slate-400">Single-page • Copy-ready • Printable</div>
            </div>
        </div>
    </footer>
    <!-- ======= Scripts ======= -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const y = document.getElementById('year'); if (y) y.textContent = new Date().getFullYear();
            const printBtn = document.getElementById('printBtn'); if (printBtn) printBtn.onclick = () => window.print();
        });
    </script>

    <!-- ======= McCormick script (axis-fixed) ======= -->
    <!-- ======= McCormick script (axes fixed to initial bounds) ======= -->
    <!-- ======= McCormick script (axes fixed + robust shade updates) ======= -->
    <!-- ======= McCormick script (axes fixed + clipped to [xL,xU]) ======= -->

    <script>
        (function () {
            const svg = document.getElementById('pw_plot');
            if (!svg) return;

            // Groups (existing)
            const axesG = document.getElementById('pw_axes');
            const partsG = document.getElementById('pw_partitions');
            const shade = document.getElementById('pw_shade');
            const pTrue = document.getElementById('pw_true');
            const pUnder = document.getElementById('pw_under');
            const pOver = document.getElementById('pw_over');

            // NEW: standard-envelope layers (created if missing)
            const NS = 'http://www.w3.org/2000/svg';
            function needPath(id, stroke, sw, dash, fill, opacity) {
                let el = document.getElementById(id);
                if (!el) { el = document.createElementNS(NS, 'path'); el.setAttribute('id', id); svg.appendChild(el); }
                if (stroke) el.setAttribute('stroke', stroke);
                if (sw != null) el.setAttribute('stroke-width', sw);
                if (dash) el.setAttribute('stroke-dasharray', dash);
                if (fill) el.setAttribute('fill', fill);
                if (opacity != null) el.setAttribute('fill-opacity', opacity);
                el.setAttribute('vector-effect', 'non-scaling-stroke');
                return el;
            }
            const shadeStd = needPath('pw_std_shade', null, null, null, '#ef4444', 0.10); // light red
            const pStdLo = needPath('pw_std_under', '#ef4444', 1.5, '6 4', 'none', null);
            const pStdUp = needPath('pw_std_over', '#ef4444', 1.5, '6 4', 'none', null);

            // Inputs / readouts
            const xLIn = document.getElementById('pw_xL');
            const xUIn = document.getElementById('pw_xU');
            const yLIn = document.getElementById('pw_yL');
            const yUIn = document.getElementById('pw_yU');
            const NxIn = document.getElementById('pw_Nx');
            const NyIn = document.getElementById('pw_Ny');
            const yFix = document.getElementById('pw_yFix');
            const yVal = document.getElementById('pw_yVal');
            const errB = document.getElementById('pw_errBound');

            document.getElementById('pw_incNx').onclick = () => { NxIn.value = (+NxIn.value || 1) + 1; update(); };
            document.getElementById('pw_decNx').onclick = () => { NxIn.value = Math.max(1, (+NxIn.value || 1) - 1); update(); };
            document.getElementById('pw_incNy').onclick = () => { NyIn.value = (+NyIn.value || 1) + 1; update(); };
            document.getElementById('pw_decNy').onclick = () => { NyIn.value = Math.max(1, (+NyIn.value || 1) - 1); update(); };

            // Layout
            const PAD = { l: 60, r: 20, t: 20, b: 50 };
            const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
            const plotW = W - PAD.l - PAD.r, plotH = H - PAD.t - PAD.b;

            // Helpers
            const LAST = {};
            function n(el, k) { const v = parseFloat(el.value); if (Number.isFinite(v)) { LAST[k] = v; return v; } return Number.isFinite(LAST[k]) ? LAST[k] : 0; }
            const uniformBreaks = (L, U, N) => Array.from({ length: N + 1 }, (_, i) => L + (U - L) * i / N);
            function niceTicks(min, max, count = 6) {
                const span = max - min || 1, raw = span / count, p10 = Math.pow(10, Math.floor(Math.log10(raw)));
                const steps = [1, 2, 2.5, 5, 10].map(k => k * p10);
                const step = steps.reduce((a, b) => Math.abs(raw - a) < Math.abs(raw - b) ? a : b);
                const lo = Math.floor(min / step) * step, hi = Math.ceil(max / step) * step;
                const ticks = []; for (let v = lo; v <= hi + 1e-12; v += step) ticks.push(+v.toFixed(12)); return { ticks, lo, hi };
            }
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

            // Fix axes from initial values (your requirement)
            LAST.xL = parseFloat(xLIn.value); LAST.xU = parseFloat(xUIn.value);
            LAST.yL = parseFloat(yLIn.value); LAST.yU = parseFloat(yUIn.value);
            const xL0 = n(xLIn, 'xL'), xU0 = n(xUIn, 'xU');
            const yL0 = n(yLIn, 'yL'), yU0 = n(yUIn, 'yU');

            const FIX = (() => {
                const xMin = Math.min(xL0, xU0), xMax = Math.max(xL0, xU0);
                const corners = [xL0 * yL0, xL0 * yU0, xU0 * yL0, xU0 * yU0];
                let wMin = Math.min(...corners), wMax = Math.max(...corners);
                const pad = 0.05 * (wMax - wMin || 1); wMin -= pad; wMax += pad;
                const sx = x => PAD.l + (x - xMin) / (xMax - xMin) * plotW;
                const sy = w => PAD.t + (wMax - w) / (wMax - wMin) * plotH;
                return { xMin, xMax, wMin, wMax, sx, sy };
            })();

            function path(xs, ys) {
                if (!xs.length) return '';
                let d = `M ${FIX.sx(xs[0])} ${FIX.sy(ys[0])}`;
                for (let i = 1; i < xs.length; i++) d += ` L ${FIX.sx(xs[i])} ${FIX.sy(ys[i])}`;
                return d;
            }

            function renderAxesFixed() {
                const xt = niceTicks(FIX.xMin, FIX.xMax), yt = niceTicks(FIX.wMin, FIX.wMax);
                const frame = `M ${PAD.l} ${PAD.t} L ${PAD.l + plotW} ${PAD.t}
                   L ${PAD.l + plotW} ${PAD.t + plotH}
                   L ${PAD.l} ${PAD.t + plotH} Z`;
                let ticks = ''; xt.ticks.forEach(v => ticks += `M ${FIX.sx(v)} ${PAD.t + plotH} v 6 `);
                yt.ticks.forEach(v => ticks += `M ${PAD.l} ${FIX.sy(v)} h -6 `);
                let labels = ''; xt.ticks.forEach(v => labels += `<text x="${FIX.sx(v)}" y="${PAD.t + plotH + 20}" text-anchor="middle" font-size="10" fill="#64748b">${v}</text>`);
                yt.ticks.forEach(v => labels += `<text x="${PAD.l - 8}" y="${FIX.sy(v) + 3}" text-anchor="end" font-size="10" fill="#64748b">${v}</text>`);
                let zero = ''; if (FIX.wMin <= 0 && 0 <= FIX.wMax) zero += `M ${PAD.l} ${FIX.sy(0)} L ${PAD.l + plotW} ${FIX.sy(0)}`;
                if (FIX.xMin <= 0 && 0 <= FIX.xMax) zero += ` M ${FIX.sx(0)} ${PAD.t} L ${FIX.sx(0)} ${PAD.t + plotH}`;

                axesG.innerHTML = `
      <path d="${frame}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${ticks}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${zero}"  stroke="#94a3b8" stroke-width="1.2" fill="none"/>
      ${labels}
      <text x="${PAD.l}" y="${PAD.t - 6}" font-size="11" fill="#334155">w</text>
      <text x="${PAD.l + plotW}" y="${PAD.t + plotH + 36}" font-size="11" fill="#334155" text-anchor="end">x</text>
    `;

                // mini legend (top-right inside frame)
                const Lx = PAD.l + plotW - 150, Ly = PAD.t + 16;
                const legend = `
      <g id="pw_legend" transform="translate(${Lx},${Ly})" font-size="11">
        <rect x="0" y="-12" width="150" height="48" rx="6" fill="white" stroke="#e2e8f0"/>
        <line x1="10" y1="6" x2="40" y2="6" stroke="#ef4444" stroke-width="2" stroke-dasharray="6 4"/>
        <text x="48" y="9"  fill="#334155">Standard envelope</text>
        <line x1="10" y1="24" x2="40" y2="24" stroke="#2563eb" stroke-width="2"/>
        <text x="48" y="27" fill="#334155">Piecewise envelope</text>
      </g>`;
                // inject/replace
                const old = document.getElementById('pw_legend');
                if (old) old.remove();
                axesG.insertAdjacentHTML('beforeend', legend);

                shade.setAttribute('fill-rule', 'evenodd');
            }

            function activeIndex(breaks, y) {
                for (let i = 0; i < breaks.length - 1; i++) if (y >= breaks[i] && y <= breaks[i + 1]) return i;
                if (y < breaks[0]) return 0;
                if (y > breaks[breaks.length - 1]) return breaks.length - 2;
                return 0;
            }
            function findXCell(xBreaks, x) {
                for (let i = 0; i < xBreaks.length - 1; i++) if (x >= xBreaks[i] && x <= xBreaks[i + 1]) return i;
                if (x < xBreaks[0]) return 0;
                if (x > xBreaks[xBreaks.length - 1]) return xBreaks.length - 2;
                return 0;
            }

            function update() {
                let xL = n(xLIn, 'xL'), xU = n(xUIn, 'xU');
                let yL = n(yLIn, 'yL'), yU = n(yUIn, 'yU');
                let Nx = Math.max(1, parseInt(NxIn.value || '1', 10));
                let Ny = Math.max(1, parseInt(NyIn.value || '1', 10));
                if (xU <= xL) xU = xL + 1e-6;
                if (yU <= yL) yU = yL + 1e-6;

                const y = yL + (yU - yL) * parseFloat(yFix.value || '0.5');
                yVal.textContent = (+y).toFixed(2);

                // partitions for current domain
                const xB = uniformBreaks(xL, xU, Nx);
                const yB = uniformBreaks(yL, yU, Ny);
                const m = activeIndex(yB, y);
                const yLloc = yB[m], yUloc = yB[m + 1];

                // Partition lines (vertical over full frame, horizontal tick on left)
                let partitionPath = '';
                for (let k = 1; k < xB.length - 1; k++) {
                    if (xB[k] >= FIX.xMin && xB[k] <= FIX.xMax) {
                        partitionPath += `M ${FIX.sx(xB[k])} ${PAD.t} L ${FIX.sx(xB[k])} ${PAD.t + plotH} `;
                    }
                }
                if (yLloc <= FIX.wMax && yUloc >= FIX.wMin) {
                    const yLclamped = Math.max(FIX.wMin, yLloc);
                    const yUclamped = Math.min(FIX.wMax, yUloc);
                    partitionPath += `M ${PAD.l - 15} ${FIX.sy(yLclamped)} L ${PAD.l - 5} ${FIX.sy(yLclamped)} `;
                    partitionPath += `M ${PAD.l - 15} ${FIX.sy(yUclamped)} L ${PAD.l - 5} ${FIX.sy(yUclamped)} `;
                    partitionPath += `M ${PAD.l - 10} ${FIX.sy(yLclamped)} L ${PAD.l - 10} ${FIX.sy(yUclamped)} `;
                }
                partsG.innerHTML = partitionPath ? `<path d="${partitionPath}" stroke="#10b981" stroke-width="1.3" fill="none"/>` : '';

                // Sample across full fixed x-axis span (to keep axes fixed)
                const Npts = 600;
                const xsAxis = Array.from({ length: Npts }, (_, i) => FIX.xMin + (FIX.xMax - FIX.xMin) * i / (Npts - 1));

                // True slice (only inside current domain)
                const xsTrue = xsAxis.filter(x => x >= xL && x <= xU);
                const trueWTrue = xsTrue.map(x => x * y);
                pTrue.setAttribute('d', path(xsTrue, trueWTrue));
                pTrue.setAttribute('stroke', '#0f172a');
                pTrue.setAttribute('stroke-width', '2');
                pTrue.setAttribute('fill', 'none');

                // -------- Standard McCormick envelope over CURRENT domain --------
                const xsStd = xsTrue;
                const stdLo = xsStd.map(x => Math.max(xL * y + x * yL - xL * yL, xU * y + x * yU - xU * yU));
                const stdUp = xsStd.map(x => Math.min(xL * y + x * yU - xL * yU, xU * y + x * yL - xU * yL));

                pStdLo.setAttribute('d', path(xsStd, stdLo));
                pStdUp.setAttribute('d', path(xsStd, stdUp));

                if (xsStd.length) {
                    const top = path(xsStd, stdUp);
                    const bot = path([...xsStd].reverse(), [...stdLo].reverse());
                    shadeStd.setAttribute('d', top + ' ' + bot + ' Z');
                } else {
                    shadeStd.setAttribute('d', '');
                }

                // -------- Piecewise McCormick envelope (both-dim piecewise for fixed y) --------
                const underAxis = [], overAxis = [], xsValid = [];
                for (let i = 0; i < xsAxis.length; i++) {
                    const x = xsAxis[i];
                    if (x < xL || x > xU) continue;             // outside domain: skip
                    const c = findXCell(xB, x);
                    const xLloc = xB[c], xUloc = xB[c + 1];

                    const u1 = xLloc * y + x * yLloc - xLloc * yLloc;
                    const u2 = xUloc * y + x * yUloc - xUloc * yUloc;
                    const o1 = xUloc * y + x * yLloc - xUloc * yLloc;
                    const o2 = x * yUloc + xLloc * y - xLloc * yUloc;

                    xsValid.push(x);
                    underAxis.push(Math.max(u1, u2));
                    overAxis.push(Math.min(o1, o2));
                }

                pUnder.setAttribute('d', path(xsValid, underAxis));
                pOver.setAttribute('d', path(xsValid, overAxis));
                pUnder.setAttribute('stroke', '#2563eb'); // blue
                pOver.setAttribute('stroke', '#2563eb');
                pUnder.setAttribute('stroke-width', '2');
                pOver.setAttribute('stroke-width', '2');
                pUnder.setAttribute('fill', 'none');
                pOver.setAttribute('fill', 'none');

                if (xsValid.length > 0) {
                    const top = path(xsValid, overAxis);
                    const bot = path([...xsValid].reverse(), [...underAxis].reverse());
                    shade.setAttribute('d', top + ' ' + bot + ' Z');
                    shade.setAttribute('fill', '#2563eb');
                    shade.setAttribute('fill-opacity', '0.20');
                    shade.setAttribute('stroke', 'none');
                } else {
                    shade.setAttribute('d', '');
                }

                // y label near top-left inside frame
                const yLblId = 'pw_y_label';
                let yLbl = document.getElementById(yLblId);
                if (!yLbl) { yLbl = document.createElementNS(NS, 'text'); yLbl.setAttribute('id', yLblId); axesG.appendChild(yLbl); }
                yLbl.setAttribute('x', String(PAD.l + 8));
                yLbl.setAttribute('y', String(PAD.t + 16));
                yLbl.setAttribute('fill', '#334155');
                yLbl.setAttribute('font-size', '12');
                yLbl.textContent = `y = ${y.toFixed(3)}`;

                // Error bound (theoretical, uniform Nx×Ny)
                const err = ((xU - xL) * (yU - yL)) / (4 * Nx * Ny);
                errB.textContent = `≤ ${err.toExponential(2)}  (uniform ${Nx}×${Ny})`;
            }

            ['input', 'change'].forEach(evt => {
                [xLIn, xUIn, yLIn, yUIn, NxIn, NyIn, yFix].forEach(el => el.addEventListener(evt, update));
            });

            renderAxesFixed();
            update();
        })();
    </script>
    <script>
        (function () {
            const svg = document.getElementById('mcPlot');
            if (!svg) return;

            const PAD = { l: 50, r: 15, t: 15, b: 40 };
            const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
            const plotW = W - PAD.l - PAD.r, plotH = H - PAD.t - PAD.b;

            const axesG = document.getElementById('axes');
            const shade = document.getElementById('shade');
            const pTrue = document.getElementById('trueW');
            const pU1 = document.getElementById('u1');
            const pU2 = document.getElementById('u2');
            const pO1 = document.getElementById('o1');
            const pO2 = document.getElementById('o2');

            const inputs = {
                xL: document.getElementById('xL'),
                xU: document.getElementById('xU'),
                yL: document.getElementById('yL'),
                yU: document.getElementById('yU'),
                yFix: document.getElementById('yFix'),
                yVal: document.getElementById('yVal')
            };

            // helpers
            const LAST = {};
            function n(el, key) {
                const v = parseFloat(el.value);
                if (Number.isFinite(v)) { LAST[key] = v; return v; }
                return Number.isFinite(LAST[key]) ? LAST[key] : 0;
            }
            function niceTicks(min, max, count = 6) {
                const span = max - min || 1;
                const raw = span / count;
                const p10 = Math.pow(10, Math.floor(Math.log10(raw)));
                const steps = [1, 2, 2.5, 5, 10].map(k => k * p10);
                const step = steps.reduce((a, b) => Math.abs(raw - a) < Math.abs(raw - b) ? a : b);
                const lo = Math.floor(min / step) * step, hi = Math.ceil(max / step) * step;
                const ticks = []; for (let v = lo; v <= hi + 1e-12; v += step) ticks.push(+v.toFixed(12));
                return { ticks, lo, hi };
            }

            // Fixed axis extents from initial values
            LAST.xL = parseFloat(inputs.xL.value);
            LAST.xU = parseFloat(inputs.xU.value);
            LAST.yL = parseFloat(inputs.yL.value);
            LAST.yU = parseFloat(inputs.yU.value);

            const xL0 = n(inputs.xL, 'xL'), xU0 = n(inputs.xU, 'xU');
            const yL0 = n(inputs.yL, 'yL'), yU0 = n(inputs.yU, 'yU');

            const FIX = (() => {
                const xMin = Math.min(xL0, xU0), xMax = Math.max(xL0, xU0);
                const corners = [xL0 * yL0, xL0 * yU0, xU0 * yL0, xU0 * yU0];
                let wMin = Math.min(...corners), wMax = Math.max(...corners);
                const pad = 0.05 * (wMax - wMin || 1);
                wMin -= pad; wMax += pad;
                const sx = x => PAD.l + (x - xMin) / (xMax - xMin) * plotW;
                const sy = w => PAD.t + (wMax - w) / (wMax - wMin) * plotH;
                return { xMin, xMax, wMin, wMax, sx, sy };
            })();

            function path(xs, ys) {
                if (!xs.length) return '';
                let d = `M ${FIX.sx(xs[0])} ${FIX.sy(ys[0])}`;
                for (let i = 1; i < xs.length; i++) d += ` L ${FIX.sx(xs[i])} ${FIX.sy(ys[i])}`;
                return d;
            }

            function renderAxesFixed() {
                const xt = niceTicks(FIX.xMin, FIX.xMax);
                const yt = niceTicks(FIX.wMin, FIX.wMax);

                const frame = `
      M ${PAD.l} ${PAD.t} L ${PAD.l + plotW} ${PAD.t}
      L ${PAD.l + plotW} ${PAD.t + plotH}
      L ${PAD.l} ${PAD.t + plotH} Z`;

                let ticks = '';
                xt.ticks.forEach(v => ticks += `M ${FIX.sx(v)} ${PAD.t + plotH} v 6 `);
                yt.ticks.forEach(v => ticks += `M ${PAD.l} ${FIX.sy(v)} h -6 `);

                let labels = '';
                xt.ticks.forEach(v => labels += `<text x="${FIX.sx(v)}" y="${PAD.t + plotH + 20}" text-anchor="middle" font-size="10" fill="#64748b">${v}</text>`);
                yt.ticks.forEach(v => labels += `<text x="${PAD.l - 8}" y="${FIX.sy(v) + 3}" text-anchor="end" font-size="10" fill="#64748b">${v}</text>`);

                let zero = '';
                if (FIX.wMin <= 0 && 0 <= FIX.wMax) zero += `M ${PAD.l} ${FIX.sy(0)} L ${PAD.l + plotW} ${FIX.sy(0)}`;
                if (FIX.xMin <= 0 && 0 <= FIX.xMax) zero += ` M ${FIX.sx(0)} ${PAD.t} L ${FIX.sx(0)} ${PAD.t + plotH}`;

                shade.setAttribute('fill-rule', 'evenodd');
                axesG.innerHTML = `
      <path d="${frame}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${ticks}" stroke="#cbd5e1" stroke-width="1" fill="none"/>
      <path d="${zero}"  stroke="#94a3b8" stroke-width="1.2" fill="none"/>
      ${labels}
    `;
            }

            function update() {
                let xL = n(inputs.xL, 'xL'), xU = n(inputs.xU, 'xU');
                let yL = n(inputs.yL, 'yL'), yU = n(inputs.yU, 'yU');
                if (xU <= xL) xU = xL + 1e-6;
                if (yU <= yL) yU = yL + 1e-6;

                const y = yL + (yU - yL) * parseFloat(inputs.yFix.value || '0.5');
                inputs.yVal.textContent = (+y).toFixed(2);

                // Sample over the fixed axis range for display
                const N = 400;
                const xsAxis = Array.from({ length: N }, (_, i) => FIX.xMin + (FIX.xMax - FIX.xMin) * i / (N - 1));
                const trueWAxis = xsAxis.map(x => x * y);
                const under1Axis = xsAxis.map(x => xL * y + x * yL - xL * yL);
                const under2Axis = xsAxis.map(x => xU * y + x * yU - xU * yU);
                const over1Axis = xsAxis.map(x => xU * y + x * yL - xU * yL);
                const over2Axis = xsAxis.map(x => x * yU + xL * y - xL * yU);

                // Constraint lines: always draw across full axis range (not clipped)
                pU1.setAttribute('d', path(xsAxis, under1Axis));
                pU2.setAttribute('d', path(xsAxis, under2Axis));
                pO1.setAttribute('d', path(xsAxis, over1Axis));
                pO2.setAttribute('d', path(xsAxis, over2Axis));

                // True line: crop to domain bounds [xL, xU]
                const xsTrue = xsAxis.filter(x => x >= xL && x <= xU);
                if (xsTrue.length > 0) {
                    const trueWTrue = xsTrue.map(x => x * y);
                    pTrue.setAttribute('d', path(xsTrue, trueWTrue));
                } else {
                    pTrue.setAttribute('d', '');
                }

                // Shaded area: compute envelope directly at axis points using extended constraint logic
                const underAxis = xsAxis.map(x => {
                    const u1 = xL * y + x * yL - xL * yL;
                    const u2 = xU * y + x * yU - xU * yU;
                    return Math.max(u1, u2);
                });

                const overAxis = xsAxis.map(x => {
                    const o1 = xU * y + x * yL - xU * yL;
                    const o2 = x * yU + xL * y - xL * yU;
                    return Math.min(o1, o2);
                });

                // Filter to domain and feasible region
                const xsForShade = [];
                const underForShade = [];
                const overForShade = [];

                for (let i = 0; i < xsAxis.length; i++) {
                    const x = xsAxis[i];
                    if (x >= xL && x <= xU && underAxis[i] <= overAxis[i]) {
                        xsForShade.push(x);
                        underForShade.push(underAxis[i]);
                        overForShade.push(overAxis[i]);
                    }
                }

                if (xsForShade.length > 0) {
                    const top = path(xsForShade, overForShade);
                    const bot = path([...xsForShade].reverse(), [...underForShade].reverse());
                    shade.setAttribute('d', top + ' ' + bot + ' Z');
                } else {
                    shade.setAttribute('d', '');
                }
            }

            ['input', 'change'].forEach(evt => {
                Object.values(inputs).forEach(el => {
                    if (el && el.tagName === 'INPUT') el.addEventListener(evt, update);
                });
            });

            renderAxesFixed();
            update();
        })();
    </script>

</body>

</html>