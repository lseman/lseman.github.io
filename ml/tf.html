<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Transformers — Illustrated Cheatsheet</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Alpine.js -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- Chart.js (for tiny demo plots) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

    <!-- MathJax (v3) -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                tags: 'none'
            },
            chtml: {
                linebreaks: { automatic: false },
                matchFontHeight: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <style>
        .transformer-diagram {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 40px;
            margin-top: 20px;
        }

        .encoder,
        .decoder {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section-title {
            color: #000000;
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .block {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
            backdrop-filter: blur(5px);
            min-height: 120px;
        }

        .sub-blocks {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            justify-content: center;
        }

        .sub-block {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgb(255, 255, 255);
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 0.75rem;
            color: rgba(0, 0, 0, 0.9);
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .sub-block:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .block:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .block-title {
            color: #000000;
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .block-desc {
            color: #000000;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .attention {
            background: #fce8e6;
            border-color: #f5c2c7;
        }

        .feedforward {
            background: #e7f1ff;
            border-color: #b6d7ff;
        }

        .normalization {
            background: #fff3cd;
            border-color: #ffda6a;
        }

        .embedding {
            background: #e2f4fd;
            border-color: #b3e0ff;
        }

        .output {
            background: #f8d7da;
            border-color: #f1aeb5;
        }

        .arrow {
            position: absolute;
            color: #000000;
            font-size: 2rem;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .cross-attention-arrow {
            position: absolute;
            top: 50%;
            left: calc(50% - 20px);
            transform: translateY(-50%);
            width: 40px;
            height: 2px;
            background: #b19cd9;
            border-radius: 2px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .cross-attention-arrow::before {
            content: '';
            position: absolute;
            right: -10px;
            top: -5px;
            width: 0;
            height: 0;
            border-left: 10px solid #b19cd9;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
        }

        .stack-indicator {
            position: absolute;
            top: 10px;
            right: 15px;
            background: #6c757d;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .connection-line {
            position: relative;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .connection-line::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 100%;
            background: #dee2e6;
            border-radius: 2px;
        }

        .connection-line::after {
            content: '▼';
            color: #000000;
            font-size: 1.2rem;
        }

        .cross-connection {
            position: absolute;
            top: 50%;
            left: 100%;
            width: 40px;
            height: 2px;
            background: #b19cd9;
            transform: translateY(-50%);
            border-radius: 2px;
        }

        .cross-connection::after {
            content: '▶';
            position: absolute;
            right: -15px;
            top: -10px;
            color: #b19cd9;
            font-size: 1.2rem;
        }

        @media (max-width: 768px) {
            .transformer-diagram {
                flex-direction: column;
                gap: 30px;
            }

            h1 {
                font-size: 2rem;
            }

            .container {
                padding: 20px;
            }
        }

        .info-panel {
            margin-top: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }

        .info-title {
            color: #000000;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-align: center;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: #ffffff;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #a8d8ea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .info-item h4 {
            color: #000000;
            margin-bottom: 5px;
        }

        .info-item p {
            color: #000000;
            font-size: 0.9rem;
        }
    </style>
    <style>
        :root {
            color-scheme: light;
        }

        html {
            scroll-behavior: smooth;
        }

        .bg-hero {
            background: linear-gradient(120deg, #eef2ff, #f0fdf4, #ecfeff);
            background-size: 200% 200%;
            animation: grad 18s ease infinite;
        }

        @keyframes grad {
            0% {
                background-position: 0% 50%
            }

            50% {
                background-position: 100% 50%
            }

            100% {
                background-position: 0% 50%
            }
        }

        .code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .card {
            backdrop-filter: blur(6px);
        }

        .node {
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, .06));
        }

        .fade-in {
            animation: fade .25s ease-in;
        }

        @keyframes fade {
            from {
                opacity: .2
            }

            to {
                opacity: 1
            }
        }

        .grid-auto {
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        }

        .mono {
            font-feature-settings: "tnum" 1, "lnum" 1;
        }

        .hint {
            font-size: .875rem;
            color: #64748b
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: .125rem .375rem;
            border-radius: .375rem
        }

        .mask-cell {
            stroke: #e5e7eb
        }

        .mjx-assistive-mml {
            position: absolute !important;
            width: 1px;
            height: 1px;
            overflow: hidden !important;
            clip: rect(1px, 1px, 1px, 1px);
            clip-path: inset(50%);
            pointer-events: none !important;
            margin: 0 !important;
            padding: 0 !important;
            border: 0 !important;
        }

        mjx-container[display="inline"] {
            white-space: nowrap;
        }

        mjx-container[display="block"] {
            overflow-x: auto;
            overflow-y: hidden;
        }
    </style>
</head>

<body class="min-h-screen text-slate-800">

    <!-- Header -->
    <header class="bg-hero">
        <div class="max-w-7xl mx-auto px-6 py-12 lg:py-16">
            <div class="flex flex-col lg:flex-row items-center gap-10">
                <div class="flex-1">
                    <h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900">
                        <span class="text-indigo-600">Transformers</span> — Illustrated Cheatsheet
                    </h1>
                    <p class="mt-3 text-lg md:text-xl text-slate-700 max-w-2xl">
                        A single-file visual guide to the Transformer: self-attention, multi-head attention, positional
                        encoding,
                        encoder/decoder stacks, masking, training tips, and efficiency tricks — with equations and
                        interactive demos.
                    </p>
                    <div class="mt-5 flex flex-wrap gap-3">
                        <a href="#primer"
                            class="px-5 py-3 rounded-xl bg-indigo-600 text-white font-semibold shadow hover:bg-indigo-700">Start
                            here</a>
                        <a href="#attention"
                            class="px-5 py-3 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50">Self-Attention</a>
                        <a href="#posenc"
                            class="px-5 py-3 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50">Positional
                            Encoding</a>
                        <a href="#encoderdecoder"
                            class="px-5 py-3 rounded-xl bg-white ring-1 ring-slate-200 shadow-sm font-semibold hover:bg-slate-50">Encoder/Decoder</a>
                    </div>
                    <p class="mt-4 text-sm text-slate-500">Single file • Tailwind + Alpine + Chart.js • MathJax •
                        SVG/Canvas</p>
                </div>
                <div class="flex-1 w-full">
                    <div class="bg-white/70 card rounded-2xl p-6 shadow border border-slate-100">
                        <canvas id="sparkTrain" height="220"></canvas>
                        <p class="mt-3 text-center text-sm text-slate-600">Toy training curves (loss & cosine lr) +
                            warmup preview.</p>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Primer -->
    <section id="primer" class="py-12">
        <div class="max-w-7xl mx-auto px-6">
            <div class="mb-8">
                <h2 class="text-3xl font-bold tracking-tight text-slate-900">What is a Transformer?</h2>
                <p class="mt-2 text-slate-600 max-w-3xl">
                    A Transformer layers <span class="font-semibold">self-attention</span> and <span
                        class="font-semibold">feed-forward</span> blocks with residual connections and normalization.
                    Unlike RNNs, it processes tokens in parallel; unlike CNNs, it learns long-range dependencies
                    directly via attention weights.
                </p>
            </div>

            <div class="grid lg:grid-cols-2 gap-6">
                <!-- Diagram -->
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Encoder Block (Pre-LN)</h3>
                    <svg viewBox="0 0 760 300" class="w-full h-auto mt-3">
                        <!-- tokens -->
                        <g font-size="12" fill="#334155">
                            <rect x="20" y="40" width="80" height="28" rx="8" fill="#eef2ff" stroke="#c7d2fe" /><text
                                x="60" y="58" text-anchor="middle">x₁</text>
                            <rect x="20" y="90" width="80" height="28" rx="8" fill="#eef2ff" stroke="#c7d2fe" /><text
                                x="60" y="108" text-anchor="middle">x₂</text>
                            <rect x="20" y="140" width="80" height="28" rx="8" fill="#eef2ff" stroke="#c7d2fe" /><text
                                x="60" y="158" text-anchor="middle">x₃</text>
                            <rect x="20" y="190" width="80" height="28" rx="8" fill="#eef2ff" stroke="#c7d2fe" /><text
                                x="60" y="208" text-anchor="middle">x₄</text>
                        </g>
                        <!-- block -->
                        <g>
                            <rect x="140" y="20" width="580" height="240" rx="16" fill="#fff" stroke="#e2e8f0" />
                            <text x="430" y="45" text-anchor="middle" font-size="13" fill="#475569">Transformer Encoder
                                Block</text>
                        </g>
                        <!-- sublayers -->
                        <g>
                            <rect x="170" y="70" width="220" height="60" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="280" y="98" text-anchor="middle" font-size="12" fill="#334155">Multi-Head
                                Self-Attention</text>
                            <rect x="420" y="70" width="260" height="60" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="550" y="98" text-anchor="middle" font-size="12" fill="#334155">Residual +
                                LayerNorm</text>

                            <rect x="170" y="150" width="220" height="60" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="280" y="178" text-anchor="middle" font-size="12" fill="#334155">Feed-Forward
                                (MLP)</text>
                            <rect x="420" y="150" width="260" height="60" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="550" y="178" text-anchor="middle" font-size="12" fill="#334155">Residual +
                                LayerNorm</text>
                        </g>
                        <!-- arrows -->
                        <defs>
                            <marker id="arr" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"
                                markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L6,3 z" fill="#94a3b8" />
                            </marker>
                        </defs>
                        <g stroke="#94a3b8" stroke-width="2" fill="none" marker-end="url(#arr)">
                            <path d="M100,54 C120,54 130,54 140,54" />
                            <path d="M100,104 C120,104 130,104 140,104" />
                            <path d="M100,154 C120,154 130,154 140,154" />
                            <path d="M100,204 C120,204 130,204 140,204" />
                            <path d="M640,100 C660,100 700,100 720,100" />
                            <path d="M640,180 C660,180 700,180 720,180" />
                        </g>
                    </svg>
                    <p class="mt-3 text-sm text-slate-600">Pre-LayerNorm variant shown (LN before sublayer). Post-LN is
                        also used in practice.</p>
                </article>

                <!-- Math -->
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Core Equations (Single Head)</h3>
                    <div class="mt-3 text-sm leading-7 text-slate-700 space-y-3">
                        <p>Embeddings + positions: \( X \in \mathbb{R}^{T \times d} \), \( E \in \mathbb{R}^{V \times d}
                            \), \( P \in \mathbb{R}^{T \times d} \). Tokens map to rows in \( E \) and are summed with
                            \( P \).</p>
                        <p class="whitespace-nowrap overflow-x-auto">
                            Queries/Keys/Values:
                            \( Q = X W_Q,\; K = X W_K,\; V = X W_V \), with \( W_*\in \mathbb{R}^{d \times d_k} \).
                        </p>
                        <p class="whitespace-nowrap overflow-x-auto">
                            Self-attention (scaled dot-product):
                            $$\mathrm{Attn}(Q,K,V)=\mathrm{softmax}\!\left(\frac{QK^{\mathsf
                            T}}{\sqrt{d_k}}\right)\,V.$$
                        </p>
                        <p>Multi-Head: compute $h$ heads in parallel, then concatenate and project: \(
                            \mathrm{MHA}(X)=\mathrm{Concat}(H_1,\dots,H_h)W_O \).</p>
                        <p>FFN (per token): \( \mathrm{FFN}(x)=\sigma(xW_1+b_1)W_2+b_2 \) (often GELU + dropout).</p>
                    </div>
                </article>
            </div>
        </div>
    </section>

    <section>

        <div class="max-w-7xl mx-auto px-6">
            <div class="bg-white rounded-2xl shadow p-6 border border-slate-200">

                <h1>🤖 Transformer Architecture</h1>

                <div class="transformer-diagram">
                    <!-- Encoder Stack -->
                    <div class="encoder">
                        <div class="section-title">📥 ENCODER</div>

                        <div class="block embedding">
                            <div class="block-title">Input Embeddings + Positional Encoding</div>
                            <div class="block-desc">Converts tokens to dense vectors and adds position information</div>
                            <div class="sub-blocks">
                                <div class="sub-block">Token Embedding</div>
                                <div class="sub-block">Sine/Cosine PE</div>
                                <div class="sub-block">Learned PE</div>
                                <div class="sub-block">Dropout</div>
                            </div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block attention">
                            <div class="stack-indicator">×N</div>
                            <div class="block-title">Multi-Head Self-Attention</div>
                            <div class="block-desc">Allows each position to attend to all positions in the input</div>
                            <div class="sub-blocks">
                                <div class="sub-block">Q, K, V Linear</div>
                                <div class="sub-block">Scaled Dot-Product</div>
                                <div class="sub-block">Softmax</div>
                                <div class="sub-block">Concat Heads</div>
                                <div class="sub-block">Output Linear</div>
                            </div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block normalization">
                            <div class="block-title">Add & Normalize</div>
                            <div class="block-desc">Residual connection + Layer normalization</div>
                            <div class="sub-blocks">
                                <div class="sub-block">Residual (+)</div>
                                <div class="sub-block">LayerNorm</div>
                                <div class="sub-block">γ, β params</div>
                            </div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block feedforward">
                            <div class="block-title">Feed Forward Network</div>
                            <div class="block-desc">Position-wise fully connected layers with ReLU activation</div>
                            <div class="sub-blocks">
                                <div class="sub-block">Linear (d_model → d_ff)</div>
                                <div class="sub-block">ReLU/GELU</div>
                                <div class="sub-block">Dropout</div>
                                <div class="sub-block">Linear (d_ff → d_model)</div>
                            </div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block normalization">
                            <div class="block-title">Add & Normalize</div>
                            <div class="block-desc">Residual connection + Layer normalization</div>
                        </div>
                    </div>

                    <!-- Cross-Connection Arrow -->
                    <div style="position: relative; display: flex; align-items: center; margin-top: 200px;">
                        <div class="arrow">➡️</div>
                    </div>

                    <!-- Decoder Stack -->
                    <div class="decoder">
                        <div class="section-title">📤 DECODER</div>

                        <div class="block embedding">
                            <div class="block-title">Output Embeddings + Positional Encoding</div>
                            <div class="block-desc">Target sequence embeddings with position encoding</div>
                            <div class="sub-blocks">
                                <div class="sub-block">Token Embedding</div>
                                <div class="sub-block">Positional Encoding</div>
                                <div class="sub-block">Dropout</div>
                            </div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block attention">
                            <div class="stack-indicator">×N</div>
                            <div class="block-title">Masked Multi-Head Self-Attention</div>
                            <div class="block-desc">Prevents attention to future positions during training</div>
                            <div class="sub-blocks">
                                <div class="sub-block">Q, K, V Linear</div>
                                <div class="sub-block">Causal Mask</div>
                                <div class="sub-block">Scaled Dot-Product</div>
                                <div class="sub-block">Softmax</div>
                                <div class="sub-block">Output Linear</div>
                            </div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block normalization">
                            <div class="block-title">Add & Normalize</div>
                            <div class="block-desc">Residual connection + Layer normalization</div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block attention" style="background: #f3e8ff; border-color: #d8b4fe;">
                            <div class="block-title">Multi-Head Cross-Attention</div>
                            <div class="block-desc">Attends to encoder output (K,V) using decoder queries (Q)</div>
                            <div class="sub-blocks">
                                <div class="sub-block">Q from Decoder</div>
                                <div class="sub-block">K, V from Encoder</div>
                                <div class="sub-block">Scaled Dot-Product</div>
                                <div class="sub-block">Softmax</div>
                                <div class="sub-block">Output Linear</div>
                            </div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block normalization">
                            <div class="block-title">Add & Normalize</div>
                            <div class="block-desc">Residual connection + Layer normalization</div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block feedforward">
                            <div class="block-title">Feed Forward Network</div>
                            <div class="block-desc">Position-wise fully connected layers</div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block normalization">
                            <div class="block-title">Add & Normalize</div>
                            <div class="block-desc">Residual connection + Layer normalization</div>
                        </div>

                        <div class="connection-line"></div>

                        <div class="block output">
                            <div class="block-title">Linear + Softmax</div>
                            <div class="block-desc">Projects to vocabulary size and applies softmax for probabilities
                            </div>
                            <div class="sub-blocks">
                                <div class="sub-block">Linear (d_model → vocab_size)</div>
                                <div class="sub-block">Softmax</div>
                                <div class="sub-block">Probability Distribution</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="info-panel">
                    <div class="info-title">🔍 Key Components Explained</div>
                    <div class="info-grid">
                        <div class="info-item">
                            <h4>Multi-Head Attention</h4>
                            <p>Parallel attention mechanisms that capture different types of relationships</p>
                        </div>
                        <div class="info-item">
                            <h4>Positional Encoding</h4>
                            <p>Sine/cosine patterns that inject sequence position information</p>
                        </div>
                        <div class="info-item">
                            <h4>Layer Normalization</h4>
                            <p>Stabilizes training by normalizing inputs across features</p>
                        </div>
                        <div class="info-item">
                            <h4>Residual Connections</h4>
                            <p>Skip connections that help with gradient flow in deep networks</p>
                        </div>
                    </div>
                </div>
            </div>

            <script>
                // Add interactive hover effects
                document.querySelectorAll('.block').forEach(block => {
                    block.addEventListener('mouseenter', function () {
                        this.style.transform = 'translateY(-8px) scale(1.02)';
                        this.style.zIndex = '10';
                    });

                    block.addEventListener('mouseleave', function () {
                        this.style.transform = 'translateY(0) scale(1)';
                        this.style.zIndex = '1';
                    });
                });

                // Add click interactions with detailed explanations
                const detailedInfo = {
                    'Input Embeddings + Positional Encoding': {
                        description: 'Converts discrete tokens into continuous vector representations and adds positional information to enable the model to understand sequence order.',
                        components: [
                            'Token Embedding: Maps each token to a d_model dimensional vector using learned embedding matrix E',
                            'Positional Encoding: PE(pos,2i) = sin(pos/10000^(2i/d_model)), PE(pos,2i+1) = cos(pos/10000^(2i/d_model))',
                            'Learned PE: Alternative learnable position embeddings',
                            'Dropout: Applied to sum of embeddings and positional encodings'
                        ],
                        formula: 'output = Embedding(x) + PositionalEncoding(pos)',
                        purpose: 'Provides semantic and positional context for each token in the sequence'
                    },
                    'Multi-Head Self-Attention': {
                        description: 'Allows each position to attend to all positions in the input sequence through multiple parallel attention heads.',
                        components: [
                            'Q, K, V Linear: Three linear projections W_Q, W_K, W_V to create queries, keys, values',
                            'Scaled Dot-Product: Attention(Q,K,V) = softmax(QK^T/√d_k)V',
                            'Softmax: Normalizes attention scores to probabilities',
                            'Concat Heads: Concatenate outputs from h parallel attention heads',
                            'Output Linear: Final linear projection W_O to combine multi-head outputs'
                        ],
                        formula: 'MultiHead(Q,K,V) = Concat(head_1,...,head_h)W_O where head_i = Attention(QW_Q^i, KW_K^i, VW_V^i)',
                        purpose: 'Captures different types of relationships and dependencies in parallel'
                    },
                    'Masked Multi-Head Self-Attention': {
                        description: 'Self-attention with causal masking to prevent attention to future positions during training.',
                        components: [
                            'Q, K, V Linear: Same as regular attention but for decoder input',
                            'Causal Mask: Lower triangular mask to hide future tokens',
                            'Scaled Dot-Product: Same computation but with masking applied',
                            'Softmax: Applied after masking (masked positions → -∞ → 0 after softmax)',
                            'Output Linear: Final projection after attention computation'
                        ],
                        formula: 'Attention(Q,K,V) = softmax((QK^T + M)/√d_k)V where M is causal mask',
                        purpose: 'Maintains autoregressive property during training and generation'
                    },
                    'Multi-Head Cross-Attention': {
                        description: 'Attention mechanism where decoder queries attend to encoder key-value pairs.',
                        components: [
                            'Q from Decoder: Queries computed from decoder hidden states',
                            'K, V from Encoder: Keys and values from final encoder layer output',
                            'Scaled Dot-Product: Standard attention computation between decoder and encoder',
                            'Softmax: Normalizes attention over encoder positions',
                            'Output Linear: Projects concatenated multi-head output'
                        ],
                        formula: 'CrossAttention: Q_decoder attends to K_encoder, V_encoder',
                        purpose: 'Allows decoder to focus on relevant parts of the input sequence'
                    },
                    'Add & Normalize': {
                        description: 'Residual connections combined with layer normalization for stable training.',
                        components: [
                            'Residual (+): Element-wise addition of input and sublayer output',
                            'LayerNorm: Normalizes across the feature dimension',
                            'γ, β params: Learnable scale and shift parameters'
                        ],
                        formula: 'LayerNorm(x + Sublayer(x)) where LayerNorm(x) = γ * (x-μ)/σ + β',
                        purpose: 'Stabilizes training, enables gradient flow, and reduces internal covariate shift'
                    },
                    'Feed Forward Network': {
                        description: 'Position-wise fully connected feed-forward network applied to each position separately.',
                        components: [
                            'Linear (d_model → d_ff): First linear transformation, typically d_ff = 4 * d_model',
                            'ReLU/GELU: Non-linear activation function (ReLU or GELU)',
                            'Dropout: Regularization applied after activation',
                            'Linear (d_ff → d_model): Second linear transformation back to model dimension'
                        ],
                        formula: 'FFN(x) = max(0, xW_1 + b_1)W_2 + b_2 or GELU(xW_1 + b_1)W_2 + b_2',
                        purpose: 'Adds non-linearity and increases model capacity for complex transformations'
                    },
                    'Output Embeddings + Positional Encoding': {
                        description: 'Same as input embeddings but for the target sequence in decoder.',
                        components: [
                            'Token Embedding: Same embedding matrix as encoder (usually shared)',
                            'Positional Encoding: Same positional encoding scheme',
                            'Dropout: Applied to sum of embeddings'
                        ],
                        formula: 'Same as input: Embedding(x) + PositionalEncoding(pos)',
                        purpose: 'Provides semantic and positional context for target sequence tokens'
                    },
                    'Linear + Softmax': {
                        description: 'Final output layer that projects to vocabulary size and produces probability distribution.',
                        components: [
                            'Linear (d_model → vocab_size): Projects hidden states to vocabulary logits',
                            'Softmax: Converts logits to probability distribution',
                            'Probability Distribution: Final probabilities over vocabulary for next token'
                        ],
                        formula: 'P(w) = softmax(h * W_vocab + b_vocab) where h is final hidden state',
                        purpose: 'Generates probability distribution over vocabulary for next token prediction'
                    }
                };

                document.querySelectorAll('.block').forEach(block => {
                    block.addEventListener('click', function () {
                        const title = this.querySelector('.block-title').textContent;
                        const info = detailedInfo[title];

                        if (!info) return;

                        // Create detailed modal
                        const existingModal = document.querySelector('.detailed-modal');
                        if (existingModal) existingModal.remove();

                        const modal = document.createElement('div');
                        modal.className = 'detailed-modal';
                        modal.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #ffffff;
                    color: #000000;
                    padding: 40px;
                    border-radius: 20px;
                    max-width: 800px;
                    max-height: 90vh;
                    overflow-y: auto;
                    z-index: 1000;
                    border: 2px solid #e9ecef;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
                `;

                        let componentsHtml = info.components.map(comp =>
                            `<li style="margin-bottom: 10px; line-height: 1.5;">${comp}</li>`
                        ).join('');

                        modal.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                        <h2 style="color: #000000; font-size: 1.8rem; margin: 0; font-weight: bold;">${title}</h2>
                        <button onclick="this.closest('.detailed-modal').remove()" style="
                            background: #f7fafc;
                            border: 1px solid #e2e8f0;
                            color: #000000;
                            width: 40px;
                            height: 40px;
                            border-radius: 50%;
                            cursor: pointer;
                            font-size: 18px;
                            font-weight: bold;
                        ">×</button>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #000000; margin-bottom: 10px; font-weight: bold;">📝 Description</h3>
                        <p style="line-height: 1.6; color: #000000;">${info.description}</p>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #000000; margin-bottom: 15px; font-weight: bold;">🔧 Sub-Components</h3>
                        <ul style="padding-left: 20px; color: #000000;">
                            ${componentsHtml}
                        </ul>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #000000; margin-bottom: 10px; font-weight: bold;">📐 Mathematical Formula</h3>
                        <div style="
                            background: #f7fafc;
                            padding: 15px;
                            border-radius: 10px;
                            font-family: 'Courier New', monospace;
                            color: #000000;
                            border-left: 4px solid #319795;
                            border: 1px solid #e2e8f0;
                        ">${info.formula}</div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #000000; margin-bottom: 10px; font-weight: bold;">🎯 Purpose</h3>
                        <p style="line-height: 1.6; color: #000000;">${info.purpose}</p>
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px;">
                        <button onclick="this.closest('.detailed-modal').remove()" style="
                            background: #5a67d8;
                            border: none;
                            color: white;
                            padding: 12px 24px;
                            border-radius: 10px;
                            cursor: pointer;
                            font-weight: bold;
                            font-size: 16px;
                        ">Got it! 👍</button>
                    </div>
                `;

                        document.body.appendChild(modal);

                        // Add backdrop
                        const backdrop = document.createElement('div');
                        backdrop.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    z-index: 999;
                `;
                        backdrop.onclick = () => {
                            modal.remove();
                            backdrop.remove();
                        };
                        document.body.appendChild(backdrop);

                        // Auto-close after 30 seconds
                        setTimeout(() => {
                            if (modal.parentElement) {
                                modal.remove();
                                backdrop.remove();
                            }
                        }, 30000);
                    });
                });

                // Add floating animation to arrows
                setInterval(() => {
                    document.querySelectorAll('.arrow').forEach(arrow => {
                        arrow.style.transform = 'translate(-50%, -50%) scale(1.1)';
                        setTimeout(() => {
                            arrow.style.transform = 'translate(-50%, -50%) scale(1)';
                        }, 500);
                    });
                }, 2000);
            </script>
    </section>
    <!-- Self-Attention Interactive -->
    <section id="attention" class="py-12 bg-slate-50">
        <div class="max-w-7xl mx-auto px-6">
            <h2 class="text-3xl font-bold tracking-tight text-slate-900">Self-Attention — Interactive Demo</h2>
            <p class="mt-2 text-slate-600 max-w-3xl">
                Explore how the query at a position attends to other tokens. We build tiny $Q, K, V$ from low-dim
                vectors and show the attention heatmap and the resulting value mix. Change <span
                    class="kbd">temperature</span> to sharpen or smooth attention and toggle <span class="kbd">causal
                    mask</span>.
            </p>

            <div x-data="attentionDemo()" x-init="init()" class="mt-6 grid grid-auto gap-6">
                <div class="bg-white rounded-2xl shadow p-6 border">
                    <div class="flex items-center gap-4 flex-wrap">
                        <label class="text-sm">Tokens:
                            <select x-model.number="T" @change="randomize()"
                                class="ml-2 text-sm border rounded-lg px-2 py-1">
                                <option>4</option>
                                <option>5</option>
                                <option>6</option>
                                <option>8</option>
                            </select>
                        </label>
                        <label class="text-sm">d<sub>k</sub>:
                            <select x-model.number="dk" @change="randomize()"
                                class="ml-2 text-sm border rounded-lg px-2 py-1">
                                <option>2</option>
                                <option>3</option>
                                <option>4</option>
                            </select>
                        </label>
                        <label class="text-sm">Query pos:
                            <input type="range" min="0" :max="T-1" x-model.number="qpos" @input="recompute()" />
                            <span class="ml-2 mono text-slate-700" x-text="qpos"></span>
                        </label>
                        <label class="text-sm">Temp:
                            <input type="range" min="0.3" max="2.5" step="0.1" x-model.number="temp"
                                @input="recompute()" />
                            <span class="ml-2 mono text-slate-700" x-text="temp.toFixed(1)"></span>
                        </label>
                        <label class="text-sm inline-flex items-center gap-2">
                            <input type="checkbox" x-model="causal" @change="recompute()" />
                            causal mask
                        </label>
                        <button class="text-sm px-3 py-1 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700"
                            @click="randomize()">Randomize</button>
                    </div>

                    <div class="grid md:grid-cols-1 gap-4 mt-5">
                        <div>
                            <div class="text-sm text-slate-500 mb-2"><b>Attention Weights (softmax of $q_{t}\!\cdot\!K /
                                    \sqrt{d_k}$)</b></div>
                            <canvas id="attHeat" width="360" height="180" class="border rounded-lg"></canvas>
                            <div class="hint mt-2">Row = query position (we highlight current), Col = key position.
                            </div>
                            <br><br>
                            <div class="text-sm text-slate-500 mb-2"><b>Weighted Sum of Values for the current query</b>
                            </div>
                            <canvas id="valueBar" width="360" height="180" class="border rounded-lg"></canvas>
                            <div class="hint mt-2">We show the resulting $y_t = \sum_j \alpha_{t,j} v_j$ components.
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-2xl shadow p-6 border">
                    <h3 class="text-xl font-semibold">Equations with Masking & Temperature</h3>
                    <p class="mt-3 text-sm leading-7 text-slate-700">
                        With temperature $\tau$ (default $\tau=\sqrt{d_k}$) and an additive mask $M$ (0 = allowed,
                        $-\infty$ = blocked):
                    </p>
                    <p class="whitespace-nowrap overflow-x-auto">
                        $$A = \mathrm{softmax}\!\left(\tfrac{QK^\top}{\tau} + M\right), \quad Y = A\,V.$$
                    </p>
                    <p class="text-sm text-slate-700">For causal decoding, $M_{ij}=-\infty$ when $j>i$ so future
                        positions are hidden.</p>

                    <!-- Causal mask tiny SVG -->
                    <div class="mt-4">
                        <div class="text-sm text-slate-500 mb-1">Causal mask (T=6): white = allowed, gray = masked</div>
                        <svg viewBox="0 0 240 240" class="w-56 h-auto">
                            <defs>
                                <pattern id="hatch" patternUnits="userSpaceOnUse" width="6" height="6">
                                    <path d="M0,6 l6,-6 M-1,1 l2,-2 M5,7 l2,-2" stroke="#e2e8f0" stroke-width="1" />
                                </pattern>
                            </defs>
                            <g>
                                <!-- grid -->
                                <g stroke="#e5e7eb" fill="none">
                                    <rect x="0" y="0" width="240" height="240" fill="#ffffff" />
                                    <!-- cells -->
                                    <g>
                                        <!-- draw lower triangle white, upper masked -->
                                        <script type="application/ecmascript">< ![CDATA[]] ></script>
                                    </g>
                                </g>
                                <!-- programmatic rectangles -->
                                <g id="mask-cells"></g>
                            </g>
                        </svg>
                        <script>
                                // draw the mask matrix (T=6)
                                (function drawMask() {
                                    const T = 6, size = 40;
                                    const g = document.currentScript.previousElementSibling.querySelector('#mask-cells');
                                    for (let i = 0; i < T; i++) {
                                        for (let j = 0; j < T; j++) {
                                            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                            rect.setAttribute('x', j * size); rect.setAttribute('y', i * size);
                                            rect.setAttribute('width', size); rect.setAttribute('height', size);
                                            rect.setAttribute('class', 'mask-cell');
                                            if (j > i) rect.setAttribute('fill', '#f1f5f9'); else rect.setAttribute('fill', '#ffffff');
                                            rect.setAttribute('stroke', '#e5e7eb');
                                            g.appendChild(rect);
                                        }
                                    }
                                })();
                        </script>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </section>

    <section class="py-4 bg-slate-50">
        <div class="container mx-auto px-4 max-w-7xl">

            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">

                <style>
                    .step-container {
                        display: none;
                        animation: slideIn 0.6s ease-out;
                    }

                    .step-container.active {
                        display: block;
                    }

                    @keyframes slideIn {
                        from {
                            opacity: 0;
                            transform: translateX(30px);
                        }

                        to {
                            opacity: 1;
                            transform: translateX(0);
                        }
                    }

                    .step-title {
                        font-size: 2.2em;
                        color: #2c3e50;
                        margin-bottom: 25px;
                        border-left: 5px solid #3498db;
                        padding-left: 25px;
                        display: flex;
                        align-items: center;
                        gap: 15px;
                    }

                    .architecture-container {
                        display: flex;
                        gap: 30px;
                        margin: 30px 0;
                        justify-content: center;
                    }

                    .encoder,
                    .decoder {
                        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                        border-radius: 20px;
                        padding: 30px;
                        border: 3px solid #dee2e6;
                        min-width: 300px;
                        position: relative;
                        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
                    }

                    .encoder {
                        border-color: #28a745;
                    }

                    .decoder {
                        border-color: #dc3545;
                    }

                    .component-title {
                        text-align: center;
                        font-size: 1.5em;
                        font-weight: bold;
                        margin-bottom: 20px;
                        padding: 10px;
                        border-radius: 10px;
                    }

                    .encoder .component-title {
                        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
                        color: white;
                    }

                    .decoder .component-title {
                        background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%);
                        color: white;
                    }

                    .attention-layer {
                        background: white;
                        border-radius: 15px;
                        padding: 20px;
                        margin: 15px 0;
                        border: 2px solid #e9ecef;
                        transition: all 0.3s ease;
                        cursor: pointer;
                    }

                    .attention-layer:hover {
                        border-color: #3498db;
                        box-shadow: 0 5px 15px rgba(52, 152, 219, 0.2);
                        transform: translateY(-2px);
                    }

                    .attention-layer.active {
                        border-color: #3498db;
                        background: linear-gradient(135deg, #e3f2fd 0%, #f8f9fa 100%);
                        box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
                    }

                    .layer-title {
                        font-weight: bold;
                        color: #2c3e50;
                        margin-bottom: 10px;
                        font-size: 1.1em;
                    }

                    .layer-description {
                        color: #6c757d;
                        font-size: 0.9em;
                        line-height: 1.4;
                    }

                    .attention-heads-grid {
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                        gap: 15px;
                        margin: 25px 0;
                        padding: 20px;
                        background: #f8f9fa;
                        border-radius: 15px;
                    }

                    .attention-head {
                        background: white;
                        border-radius: 15px;
                        padding: 20px;
                        text-align: center;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        border: 2px solid transparent;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
                    }

                    .attention-head:hover {
                        transform: translateY(-3px) scale(1.05);
                        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
                    }

                    .attention-head.active {
                        border-color: #3498db;
                        background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                        color: white;
                        transform: scale(1.1);
                    }

                    .head-number {
                        font-size: 1.4em;
                        font-weight: bold;
                        margin-bottom: 5px;
                    }

                    .head-focus {
                        font-size: 0.85em;
                        opacity: 0.8;
                    }

                    .visualization-panel {
                        background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
                        border-radius: 20px;
                        padding: 30px;
                        margin: 30px 0;
                        border: 2px solid #e9ecef;
                        min-height: 400px;
                    }

                    .tokens-container {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                        justify-content: center;
                        margin: 25px 0;
                    }

                    .token {
                        padding: 15px 25px;
                        border-radius: 25px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.4s ease;
                        position: relative;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                    }

                    .token:hover {
                        transform: translateY(-3px);
                        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
                    }

                    .token.query {
                        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
                        color: white;
                    }

                    .token.key {
                        background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
                        color: white;
                    }

                    .token.attending {
                        background: linear-gradient(135deg, #feca57 0%, #ff9ff3 100%);
                        color: #2c3e50;
                        animation: glow 2s infinite;
                    }

                    @keyframes glow {

                        0%,
                        100% {
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                        }

                        50% {
                            box-shadow: 0 8px 20px rgba(254, 202, 87, 0.6);
                        }
                    }

                    .attention-matrix {
                        display: grid;
                        gap: 2px;
                        margin: 25px auto;
                        max-width: 500px;
                        background: #2c3e50;
                        padding: 10px;
                        border-radius: 15px;
                    }

                    .matrix-5x5 {
                        grid-template-columns: repeat(5, 1fr);
                        grid-template-rows: repeat(5, 1fr);
                    }

                    .matrix-cell {
                        aspect-ratio: 1;
                        background: #ecf0f1;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 0.8em;
                        transition: all 0.3s ease;
                        cursor: pointer;
                        border-radius: 4px;
                    }

                    .matrix-cell:hover {
                        transform: scale(1.1);
                        z-index: 10;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                    }

                    .connection-lines {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                        z-index: 5;
                    }

                    .connection-line {
                        stroke: #3498db;
                        stroke-width: 3;
                        opacity: 0;
                        transition: opacity 0.5s ease;
                    }

                    .connection-line.active {
                        opacity: 0.8;
                        animation: pulse-line 2s infinite;
                    }

                    @keyframes pulse-line {

                        0%,
                        100% {
                            stroke-width: 3;
                            opacity: 0.8;
                        }

                        50% {
                            stroke-width: 5;
                            opacity: 1;
                        }
                    }

                    .controls {
                        text-align: center;
                        margin: 40px 0;
                    }

                    .btn {
                        padding: 15px 35px;
                        margin: 0 10px;
                        border: none;
                        border-radius: 30px;
                        font-size: 1.1em;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    }

                    .btn-primary {
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                    }

                    .btn-secondary {
                        background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
                        color: white;
                    }

                    .btn:hover {
                        transform: translateY(-2px);
                        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
                    }

                    .btn:disabled {
                        opacity: 0.5;
                        cursor: not-allowed;
                        transform: none;
                    }

                    .explanation {
                        background: linear-gradient(135deg, #e8f4fd 0%, #f0f8ff 100%);
                        border-left: 5px solid #3498db;
                        padding: 25px;
                        border-radius: 0 15px 15px 0;
                        margin: 25px 0;
                        font-size: 1.1em;
                        line-height: 1.7;
                    }

                    .math-formula {
                        background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                        color: white;
                        padding: 20px;
                        border-radius: 15px;
                        font-family: 'Courier New', monospace;
                        text-align: center;
                        margin: 20px 0;
                        font-size: 1.3em;
                        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
                    }

                    .progress-bar {
                        width: 100%;
                        height: 8px;
                        background: #ecf0f1;
                        border-radius: 4px;
                        margin: 25px 0;
                        overflow: hidden;
                    }

                    .progress-fill {
                        height: 100%;
                        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
                        border-radius: 4px;
                        transition: width 0.5s ease;
                    }

                    .demo-controls {
                        text-align: center;
                        margin: 30px 0;
                    }

                    .demo-btn {
                        padding: 12px 25px;
                        margin: 0 8px;
                        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
                        color: white;
                        border: none;
                        border-radius: 20px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    }

                    .demo-btn:hover {
                        transform: translateY(-2px);
                        box-shadow: 0 6px 12px rgba(40, 167, 69, 0.3);
                    }

                    .cross-attention-viz {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin: 30px 0;
                        position: relative;
                    }

                    .source-tokens,
                    .target-tokens {
                        flex: 1;
                    }

                    .arrow-container {
                        flex: 0 0 100px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    }

                    .attention-arrow {
                        font-size: 3em;
                        color: #3498db;
                        animation: pulse 2s infinite;
                    }

                    @keyframes pulse {

                        0%,
                        100% {
                            transform: scale(1);
                        }

                        50% {
                            transform: scale(1.1);
                        }
                    }
                </style>


                <div class="progress-bar">
                    <div class="progress-fill" id="progress"></div>
                </div>

                <!-- Step 1: Transformer Architecture Overview -->
                <div class="step-container active" id="step-1">
                    <h2 class="step-title">🏗️ Attention Architecture</h2>
                    <div class="explanation">
                        The Transformer architecture consists of an Encoder (processes input) and a Decoder (generates
                        output). Each uses multi-head attention but in different ways. Let's explore how attention works
                        in each component.
                    </div>

                    <div class="architecture-container">
                        <div class="encoder">
                            <div class="component-title">🔍 ENCODER</div>
                            <div class="attention-layer" data-layer="encoder-self">
                                <div class="layer-title">Multi-Head Self-Attention</div>
                                <div class="layer-description">Each token attends to all tokens in the input sequence,
                                    including itself</div>
                            </div>
                        </div>

                        <div class="decoder">
                            <div class="component-title">🎯 DECODER</div>
                            <div class="attention-layer" data-layer="decoder-masked">
                                <div class="layer-title">Masked Self-Attention</div>
                                <div class="layer-description">Tokens can only attend to previous positions (causal
                                    masking)</div>
                            </div>
                            <div class="attention-layer" data-layer="decoder-cross">
                                <div class="layer-title">Cross-Attention</div>
                                <div class="layer-description">Decoder queries attend to encoder keys and values</div>
                            </div>
                        </div>
                    </div>

                    <div class="explanation">
                        Click on any attention layer above to explore how different attention mechanisms work. The
                        encoder uses bidirectional self-attention, while the decoder uses both masked self-attention and
                        cross-attention to the encoder.
                    </div>
                </div>

                <!-- Step 2: Encoder Self-Attention -->
                <div class="step-container" id="step-2">
                    <h2 class="step-title">🔄 Encoder Self-Attention</h2>
                    <div class="explanation">
                        In encoder self-attention, each token can attend to ALL other tokens in the sequence, including
                        itself. This allows the model to understand relationships between any pair of words, regardless
                        of their distance.
                    </div>

                    <div class="visualization-panel">
                        <h3 style="text-align: center; margin-bottom: 20px;">🎯 8 Attention Heads in Encoder</h3>
                        <div class="attention-heads-grid">
                            <div class="attention-head" data-head="1" data-focus="Syntactic Relations">
                                <div class="head-number">Head 1</div>
                                <div class="head-focus">Syntax</div>
                            </div>
                            <div class="attention-head" data-head="2" data-focus="Semantic Similarity">
                                <div class="head-number">Head 2</div>
                                <div class="head-focus">Semantics</div>
                            </div>
                            <div class="attention-head" data-head="3" data-focus="Positional Relations">
                                <div class="head-number">Head 3</div>
                                <div class="head-focus">Position</div>
                            </div>
                            <div class="attention-head" data-head="4" data-focus="Long Dependencies">
                                <div class="head-number">Head 4</div>
                                <div class="head-focus">Long-range</div>
                            </div>
                            <div class="attention-head" data-head="5" data-focus="Entity Relations">
                                <div class="head-number">Head 5</div>
                                <div class="head-focus">Entities</div>
                            </div>
                            <div class="attention-head" data-head="6" data-focus="Coreference">
                                <div class="head-number">Head 6</div>
                                <div class="head-focus">Coreference</div>
                            </div>
                            <div class="attention-head" data-head="7" data-focus="Discourse">
                                <div class="head-number">Head 7</div>
                                <div class="head-focus">Discourse</div>
                            </div>
                            <div class="attention-head" data-head="8" data-focus="Context">
                                <div class="head-number">Head 8</div>
                                <div class="head-focus">Context</div>
                            </div>
                        </div>

                        <div class="tokens-container" id="encoder-tokens">
                            <div class="token" data-pos="0">The</div>
                            <div class="token" data-pos="1">cat</div>
                            <div class="token" data-pos="2">sat</div>
                            <div class="token" data-pos="3">on</div>
                            <div class="token" data-pos="4">mat</div>
                        </div>

                        <div id="attention-matrix-encoder" class="attention-matrix matrix-5x5"></div>
                    </div>

                    <div class="demo-controls">
                        <button class="demo-btn" onclick="animateEncoderAttention()">🎬 Show Attention Flow</button>
                        <button class="demo-btn" onclick="resetVisualization()">🔄 Reset</button>
                    </div>
                </div>

                <!-- Step 3: Decoder Masked Self-Attention -->
                <div class="step-container" id="step-3">
                    <h2 class="step-title">🎭 Decoder Masked Self-Attention</h2>
                    <div class="explanation">
                        In decoder self-attention, tokens can only attend to previous positions (left-to-right). This
                        prevents the model from "cheating" by looking at future tokens during training, ensuring
                        autoregressive generation.
                    </div>

                    <div class="visualization-panel">
                        <h3 style="text-align: center; margin-bottom: 20px;">🎭 Masked Attention Pattern</h3>

                        <div class="tokens-container" id="decoder-tokens">
                            <div class="token" data-pos="0">I</div>
                            <div class="token" data-pos="1">am</div>
                            <div class="token" data-pos="2">learning</div>
                            <div class="token" data-pos="3">about</div>
                            <div class="token" data-pos="4">transformers</div>
                        </div>

                        <div id="attention-matrix-decoder" class="attention-matrix matrix-5x5"></div>

                        <div class="explanation" style="background: #fff3cd; border-left-color: #ffc107;">
                            <strong>🚨 Causal Masking:</strong> Notice how the upper triangle of the attention matrix is
                            masked (grayed out). Each token can only attend to itself and previous tokens, ensuring the
                            model generates text sequentially.
                        </div>
                    </div>

                    <div class="demo-controls">
                        <button class="demo-btn" onclick="animateDecoderMasking()">🎭 Show Masking Effect</button>
                        <button class="demo-btn" onclick="demonstrateCausal()">⚡ Causal Generation</button>
                    </div>
                </div>

                <!-- Step 4: Cross-Attention -->
                <div class="step-container" id="step-4">
                    <h2 class="step-title">🌉 Cross-Attention (Encoder-Decoder)</h2>
                    <div class="explanation">
                        Cross-attention is where the magic happens! The decoder's queries attend to the encoder's keys
                        and values. This allows the decoder to focus on relevant parts of the input when generating each
                        output token.
                    </div>

                    <div class="math-formula">
                        Q = Decoder × W<sub>Q</sub> &nbsp;&nbsp; K,V = Encoder × W<sub>K,V</sub>
                    </div>

                    <div class="visualization-panel">
                        <div class="cross-attention-viz">
                            <div class="source-tokens">
                                <h4 style="text-align: center; margin-bottom: 15px;">📥 Source (Encoder)</h4>
                                <div class="tokens-container">
                                    <div class="token key" data-pos="0">The</div>
                                    <div class="token key" data-pos="1">cat</div>
                                    <div class="token key" data-pos="2">is</div>
                                    <div class="token key" data-pos="3">sleeping</div>
                                </div>
                            </div>

                            <div class="arrow-container">
                                <div class="attention-arrow">→</div>
                            </div>

                            <div class="target-tokens">
                                <h4 style="text-align: center; margin-bottom: 15px;">📤 Target (Decoder)</h4>
                                <div class="tokens-container">
                                    <div class="token query" data-pos="0">Le</div>
                                    <div class="token query" data-pos="1">chat</div>
                                    <div class="token query" data-pos="2">dort</div>
                                    <div class="token query attending" data-pos="3">?</div>
                                </div>
                            </div>
                        </div>

                        <div class="explanation">
                            <strong>Translation Example:</strong> English → French<br>
                            The decoder token "?" (being generated) attends to all encoder tokens to decide what comes
                            next. Different attention heads focus on different aspects of the source sentence.
                        </div>
                    </div>

                    <div class="demo-controls">
                        <button class="demo-btn" onclick="animateCrossAttention()">🌉 Show Cross-Attention</button>
                        <button class="demo-btn" onclick="showTranslationAlignment()">🔗 Word Alignment</button>
                    </div>
                </div>

                <!-- Step 5: Multi-Head Attention in Action -->
                <div class="step-container" id="step-5">
                    <h2 class="step-title">🎯 Multi-Head Attention: The Complete Picture</h2>
                    <div class="explanation">
                        Now let's see how all attention mechanisms work together in a complete transformer. Each head
                        captures different linguistic phenomena, and their combination provides rich, contextual
                        representations.
                    </div>

                    <div class="visualization-panel">
                        <h3 style="text-align: center; margin-bottom: 20px;">🧠 Attention Head Specializations</h3>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div style="background: #e8f5e8; padding: 20px; border-radius: 15px;">
                                <h4>🔍 Self-Attention Heads Focus On:</h4>
                                <ul style="list-style: none; padding: 0; margin-top: 15px;">
                                    <li>📝 Subject-verb relationships</li>
                                    <li>🔗 Noun-adjective pairs</li>
                                    <li>📍 Positional dependencies</li>
                                    <li>🔄 Coreference resolution</li>
                                    <li>🏗️ Syntactic structure</li>
                                </ul>
                            </div>
                            <div style="background: #ffe8e8; padding: 20px; border-radius: 15px;">
                                <h4>🌉 Cross-Attention Heads Focus On:</h4>
                                <ul style="list-style: none; padding: 0; margin-top: 15px;">
                                    <li>🎯 Word-to-word alignment</li>
                                    <li>📖 Phrase-level translation</li>
                                    <li>🔄 Reordering patterns</li>
                                    <li>🎭 Style and tone transfer</li>
                                    <li>🧩 Compositional meaning</li>
                                </ul>
                            </div>
                        </div>

                        <div class="math-formula">
                            MultiHead(Q,K,V) = Concat(head₁, head₂, ..., head₈)W<sup>O</sup>
                        </div>

                        <div class="explanation">
                            <strong>Key Insights:</strong>
                            <br>• Each head learns to focus on different relationships
                            <br>• Parallel processing of multiple attention patterns
                            <br>• Final output combines all head representations
                            <br>• Enables rich, multi-faceted understanding of text
                        </div>
                    </div>

                    <div class="demo-controls">
                        <button class="demo-btn" onclick="showAllHeads()">👁️ Show All Heads</button>
                        <button class="demo-btn" onclick="compareAttentionTypes()">⚖️ Compare Attention Types</button>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-secondary" id="prev-btn" onclick="previousStep()">← Previous</button>
                    <span id="step-counter">Step 1 of 5</span>
                    <button class="btn btn-primary" id="next-btn" onclick="nextStep()">Next →</button>
                </div>
            </div>
        </div>

        <script>
            let currentStep = 1;
            const totalSteps = 5;
            let activeHead = null;
            let animationRunning = false;

            function updateProgress() {
                const progress = (currentStep / totalSteps) * 100;
                document.getElementById('progress').style.width = progress + '%';
            }

            function showStep(step) {
                for (let i = 1; i <= totalSteps; i++) {
                    document.getElementById(`step-${i}`).classList.remove('active');
                }

                document.getElementById(`step-${step}`).classList.add('active');
                document.getElementById('step-counter').textContent = `Step ${step} of ${totalSteps}`;

                document.getElementById('prev-btn').disabled = step === 1;
                document.getElementById('next-btn').disabled = step === totalSteps;

                updateProgress();

                // Initialize step-specific content
                if (step === 2) {
                    initializeEncoderVisualization();
                } else if (step === 3) {
                    initializeDecoderVisualization();
                }
            }

            function nextStep() {
                if (currentStep < totalSteps) {
                    currentStep++;
                    showStep(currentStep);
                }
            }

            function previousStep() {
                if (currentStep > 1) {
                    currentStep--;
                    showStep(currentStep);
                }
            }

            // Attention layer interaction
            document.addEventListener('click', function (e) {
                if (e.target.closest('.attention-layer')) {
                    const layer = e.target.closest('.attention-layer');
                    const layerType = layer.dataset.layer;

                    // Remove active class from all layers
                    document.querySelectorAll('.attention-layer').forEach(l => l.classList.remove('active'));
                    layer.classList.add('active');

                    showLayerExplanation(layerType);
                }
            });

            function showLayerExplanation(layerType) {
                const explanations = {
                    'encoder-self': 'Encoder self-attention allows each token to attend to all tokens in the input sequence, capturing bidirectional relationships.',
                    'decoder-masked': 'Masked self-attention in decoder prevents tokens from attending to future positions, ensuring autoregressive generation.',
                    'decoder-cross': 'Cross-attention allows decoder to focus on relevant encoder representations when generating output.'
                };

                console.log(explanations[layerType]);
            }

            // Attention head interaction
            document.addEventListener('click', function (e) {
                if (e.target.closest('.attention-head')) {
                    const head = e.target.closest('.attention-head');
                    const headNum = head.dataset.head;
                    const focus = head.dataset.focus;

                    // Remove active class from all heads
                    document.querySelectorAll('.attention-head').forEach(h => h.classList.remove('active'));
                    head.classList.add('active');

                    activeHead = headNum;
                    showHeadAttention(headNum, focus);
                }
            });

            function showHeadAttention(headNum, focus) {
                // Simulate different attention patterns for each head
                const patterns = {
                    '1': [[0.8, 0.1, 0.05, 0.03, 0.02], [0.2, 0.6, 0.15, 0.03, 0.02], [0.1, 0.4, 0.4, 0.08, 0.02], [0.05, 0.1, 0.2, 0.6, 0.05], [0.03, 0.1, 0.02, 0.2, 0.65]], // Syntax
                    '2': [[0.3, 0.2, 0.2, 0.2, 0.1], [0.15, 0.4, 0.2, 0.15, 0.1], [0.2, 0.3, 0.3, 0.15, 0.05], [0.25, 0.25, 0.25, 0.2, 0.05], [0.1, 0.2, 0.1, 0.3, 0.3]], // Semantics
                    '3': [[0.7, 0.2, 0.05, 0.03, 0.02], [0.3, 0.5, 0.15, 0.03, 0.02], [0.1, 0.3, 0.5, 0.08, 0.02], [0.05, 0.1, 0.3, 0.5, 0.05], [0.03, 0.05, 0.1, 0.3, 0.52]], // Position
                    '4': [[0.2, 0.1, 0.1, 0.1, 0.5], [0.1, 0.3, 0.1, 0.1, 0.4], [0.3, 0.1, 0.2, 0.1, 0.3], [0.2, 0.2, 0.1, 0.3, 0.2], [0.4, 0.1, 0.1, 0.1, 0.3]], // Long-range
                    '5': [[0.15, 0.6, 0.1, 0.1, 0.05], [0.5, 0.3, 0.1, 0.05, 0.05], [0.1, 0.1, 0.4, 0.3, 0.1], [0.05, 0.05, 0.2, 0.6, 0.1], [0.05, 0.05, 0.1, 0.2, 0.6]], // Entities
                    '6': [[0.2, 0.3, 0.2, 0.2, 0.1], [0.25, 0.25, 0.25, 0.15, 0.1], [0.3, 0.2, 0.3, 0.15, 0.05], [0.2, 0.2, 0.2, 0.3, 0.1], [0.1, 0.1, 0.1, 0.2, 0.5]], // Coreference
                    '7': [[0.25, 0.25, 0.25, 0.15, 0.1], [0.2, 0.3, 0.3, 0.15, 0.05], [0.15, 0.25, 0.35, 0.2, 0.05], [0.1, 0.2, 0.3, 0.35, 0.05], [0.05, 0.15, 0.25, 0.3, 0.25]], // Discourse
                    '8': [[0.2, 0.2, 0.2, 0.2, 0.2], [0.2, 0.2, 0.2, 0.2, 0.2], [0.2, 0.2, 0.2, 0.2, 0.2], [0.2, 0.2, 0.2, 0.2, 0.2], [0.2, 0.2, 0.2, 0.2, 0.2]] // Context
                };

                updateAttentionMatrix('encoder', patterns[headNum] || patterns['1']);
            }

            function initializeEncoderVisualization() {
                createAttentionMatrix('encoder');

                // Token interaction
                const tokens = document.querySelectorAll('#encoder-tokens .token');
                tokens.forEach(token => {
                    token.addEventListener('click', function () {
                        tokens.forEach(t => t.classList.remove('query', 'attending'));
                        this.classList.add('query');

                        const pos = parseInt(this.dataset.pos);
                        highlightAttentionForToken(pos, 'encoder');
                    });
                });

                // Select first head by default
                document.querySelector('.attention-head[data-head="1"]').click();
            }

            function initializeDecoderVisualization() {
                createAttentionMatrix('decoder');
                createMaskedMatrix();

                const tokens = document.querySelectorAll('#decoder-tokens .token');
                tokens.forEach(token => {
                    token.addEventListener('click', function () {
                        tokens.forEach(t => t.classList.remove('query', 'attending'));
                        this.classList.add('query');

                        const pos = parseInt(this.dataset.pos);
                        highlightMaskedAttention(pos);
                    });
                });
            }

            function createAttentionMatrix(type) {
                const matrixId = type === 'encoder' ? 'attention-matrix-encoder' : 'attention-matrix-decoder';
                const matrix = document.getElementById(matrixId);
                matrix.innerHTML = '';

                for (let i = 0; i < 25; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.dataset.row = Math.floor(i / 5);
                    cell.dataset.col = i % 5;
                    matrix.appendChild(cell);
                }
            }

            function createMaskedMatrix() {
                const matrix = document.getElementById('attention-matrix-decoder');
                const cells = matrix.querySelectorAll('.matrix-cell');

                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);

                    if (col > row) {
                        // Mask upper triangle
                        cell.style.background = '#bdc3c7';
                        cell.style.opacity = '0.3';
                        cell.textContent = '—';
                    } else {
                        const weight = Math.random() * 0.8 + 0.1;
                        const opacity = 0.2 + weight * 0.8;
                        cell.style.backgroundColor = `rgba(52, 152, 219, ${opacity})`;
                        cell.textContent = weight.toFixed(2);
                    }
                });
            }

            function updateAttentionMatrix(type, weights) {
                const matrixId = type === 'encoder' ? 'attention-matrix-encoder' : 'attention-matrix-decoder';
                const matrix = document.getElementById(matrixId);
                const cells = matrix.querySelectorAll('.matrix-cell');

                cells.forEach((cell, index) => {
                    const row = Math.floor(index / 5);
                    const col = index % 5;

                    if (weights && weights[row] && weights[row][col] !== undefined) {
                        const weight = weights[row][col];
                        const opacity = 0.2 + weight * 0.8;
                        cell.style.backgroundColor = `rgba(52, 152, 219, ${opacity})`;
                        cell.textContent = weight.toFixed(2);
                    }
                });
            }

            function highlightAttentionForToken(tokenPos, type) {
                const tokens = document.querySelectorAll(`#${type}-tokens .token`);

                // Show which tokens this token attends to
                tokens.forEach((token, index) => {
                    if (index !== tokenPos) {
                        const weight = Math.random();
                        if (weight > 0.3) {
                            token.classList.add('attending');
                        }
                    }
                });
            }

            function highlightMaskedAttention(tokenPos) {
                const tokens = document.querySelectorAll('#decoder-tokens .token');

                tokens.forEach((token, index) => {
                    if (index < tokenPos) {
                        token.classList.add('attending');
                    }
                });
            }

            function animateEncoderAttention() {
                if (animationRunning) return;
                animationRunning = true;

                const tokens = document.querySelectorAll('#encoder-tokens .token');
                let currentToken = 0;

                const animate = () => {
                    // Clear previous
                    tokens.forEach(t => t.classList.remove('query', 'attending'));

                    if (currentToken < tokens.length) {
                        tokens[currentToken].classList.add('query');

                        // Show attention to other tokens
                        tokens.forEach((token, index) => {
                            if (index !== currentToken && Math.random() > 0.4) {
                                setTimeout(() => token.classList.add('attending'), 200);
                            }
                        });

                        currentToken++;
                        setTimeout(animate, 1500);
                    } else {
                        animationRunning = false;
                    }
                };

                animate();
            }

            function animateDecoderMasking() {
                if (animationRunning) return;
                animationRunning = true;

                const tokens = document.querySelectorAll('#decoder-tokens .token');
                let currentToken = 0;

                const animate = () => {
                    tokens.forEach(t => t.classList.remove('query', 'attending'));

                    if (currentToken < tokens.length) {
                        tokens[currentToken].classList.add('query');

                        // Only attend to previous tokens
                        for (let i = 0; i < currentToken; i++) {
                            setTimeout(() => tokens[i].classList.add('attending'), 200);
                        }

                        currentToken++;
                        setTimeout(animate, 1500);
                    } else {
                        animationRunning = false;
                    }
                };

                animate();
            }

            function demonstrateCausal() {
                const matrix = document.getElementById('attention-matrix-decoder');
                const cells = matrix.querySelectorAll('.matrix-cell');

                // Highlight the causal nature
                cells.forEach((cell, index) => {
                    const row = Math.floor(index / 5);
                    const col = index % 5;

                    if (col > row) {
                        cell.style.animation = 'pulse 1s infinite';
                        cell.style.background = '#e74c3c';
                        cell.textContent = '🚫';
                    }
                });

                setTimeout(() => {
                    createMaskedMatrix();
                }, 3000);
            }

            function animateCrossAttention() {
                if (animationRunning) return;
                animationRunning = true;

                const sourceTokens = document.querySelectorAll('.source-tokens .token');
                const targetTokens = document.querySelectorAll('.target-tokens .token');

                let step = 0;
                const steps = targetTokens.length;

                const animate = () => {
                    // Clear previous
                    sourceTokens.forEach(t => t.classList.remove('attending'));
                    targetTokens.forEach(t => t.classList.remove('query'));

                    if (step < steps) {
                        // Highlight current target token
                        targetTokens[step].classList.add('query');

                        // Show attention to source tokens
                        sourceTokens.forEach((token, index) => {
                            const delay = index * 100;
                            setTimeout(() => {
                                token.classList.add('attending');
                            }, delay);
                        });

                        step++;
                        setTimeout(animate, 2000);
                    } else {
                        animationRunning = false;
                    }
                };

                animate();
            }

            function showTranslationAlignment() {
                const alignments = [
                    { source: 0, target: 0 }, // The -> Le
                    { source: 1, target: 1 }, // cat -> chat
                    { source: 3, target: 2 }, // sleeping -> dort
                ];

                const sourceTokens = document.querySelectorAll('.source-tokens .token');
                const targetTokens = document.querySelectorAll('.target-tokens .token');

                // Clear all
                sourceTokens.forEach(t => t.classList.remove('attending'));
                targetTokens.forEach(t => t.classList.remove('query'));

                alignments.forEach(({ source, target }, index) => {
                    setTimeout(() => {
                        sourceTokens[source].classList.add('attending');
                        targetTokens[target].classList.add('query');
                    }, index * 800);
                });
            }

            function resetVisualization() {
                document.querySelectorAll('.token').forEach(token => {
                    token.classList.remove('query', 'attending', 'key');
                });

                document.querySelectorAll('.attention-head').forEach(head => {
                    head.classList.remove('active');
                });

                animationRunning = false;
            }

            function showAllHeads() {
                const heads = document.querySelectorAll('.attention-head');
                heads.forEach((head, index) => {
                    setTimeout(() => {
                        head.classList.add('active');
                        setTimeout(() => head.classList.remove('active'), 1000);
                    }, index * 200);
                });
            }

            function compareAttentionTypes() {
                // Show comparison of different attention mechanisms
                alert('Self-Attention: Tokens attend to other tokens in same sequence\n\nCross-Attention: Decoder tokens attend to encoder representations\n\nMasked Attention: Future positions are masked during training');
            }

            // Keyboard navigation
            document.addEventListener('keydown', function (e) {
                if (e.key === 'ArrowRight' && currentStep < totalSteps) {
                    nextStep();
                } else if (e.key === 'ArrowLeft' && currentStep > 1) {
                    previousStep();
                } else if (e.key === 'Escape') {
                    resetVisualization();
                }
            });

            // Initialize
            updateProgress();
            document.addEventListener('DOMContentLoaded', function () {
                showStep(1);
            });
        </script>
        </div>
        </div>
    </section>

    <!-- Positional Encoding -->
    <section id="posenc" class="py-12">
        <div x-data="positionalEncodingTool()" x-init="init()" class="container mx-auto px-4 py-8 max-w-7xl">
            <h1 class="text-4xl font-bold text-gray-900 mb-4">Positional Encoding Deep Dive</h1>
            <p class="text-gray-600 mb-8 max-w-4xl">
                Explore how positional encodings inject sequence order information into transformer models.
                Understand sinusoidal patterns, frequency decomposition, relative position effects, and RoPE.
            </p>

            <!-- Controls -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-xl font-semibold mb-4">Parameters</h2>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Sequence Length</label>
                        <input type="range" min="8" max="64" x-model.number="seqLen" @input="updateAll()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="seqLen"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Model Dimension</label>
                        <input type="range" min="8" max="128" step="8" x-model.number="dModel" @input="updateAll()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="dModel"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Base Frequency</label>
                        <input type="range" min="100" max="50000" step="100" x-model.number="baseFreq"
                            @input="updateAll()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="baseFreq"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Position Offset (k)</label>
                        <input type="range" min="-10" max="10" x-model.number="posOffset" @input="updateRelative()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="posOffset"></span>
                    </div>
                </div>
            </div>

            <!-- Main Content Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- 1. 2D Heatmap -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">2D Positional Encoding Heatmap</h2>
                    <p class="text-gray-600 mb-4 text-sm">
                        Each cell shows PE(pos, dim). Blue = positive values, Red = negative values.
                        $PE_{(pos,2i)} = \sin(pos/10000^{2i/d})$, $PE_{(pos,2i+1)} = \cos(pos/10000^{2i/d})$
                    </p>
                    <div class="relative">
                        <svg id="heatmap" class="border rounded-lg w-full" style="height: 400px;"></svg>
                        <div class="mt-2 text-xs text-gray-500">
                            X-axis: Dimension index | Y-axis: Position in sequence
                        </div>
                    </div>
                </div>

                <!-- 2. Frequency Decomposition -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Frequency Decomposition</h2>
                    <p class="text-gray-600 mb-4 text-sm">
                        Different dimensions capture different frequency scales. Lower dimensions = higher frequency.
                    </p>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Selected Position</label>
                        <input type="range" min="0" :max="seqLen-1" x-model.number="selectedPos"
                            @input="updateFrequency()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="`Position ${selectedPos}`"></span>
                    </div>
                    <canvas id="frequencyChart" class="w-full" style="height: 300px;"></canvas>
                </div>

                <!-- 3. Relative Position Calculator -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Relative Position Effects</h2>
                    <p class="text-gray-600 mb-4 text-sm">
                        Shows $PE(pos+k) - PE(pos)$ for different offsets k. This reveals how position differences are
                        encoded.
                    </p>
                    <div class="mb-4 grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Reference Position</label>
                            <input type="range" min="0" :max="seqLen-10" x-model.number="refPos"
                                @input="updateRelative()"
                                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <span class="text-sm text-gray-500" x-text="refPos"></span>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Show First N Dims</label>
                            <input type="range" min="4" max="32" step="4" x-model.number="showDims"
                                @input="updateRelative()"
                                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <span class="text-sm text-gray-500" x-text="showDims"></span>
                        </div>
                    </div>
                    <canvas id="relativeChart" class="w-full" style="height: 300px;"></canvas>
                </div>

                <!-- 4. RoPE vs Sinusoidal -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">RoPE vs Sinusoidal Comparison</h2>
                    <p class="text-gray-600 mb-4 text-sm">
                        RoPE rotates query/key vectors while sinusoidal adds position. Both encode relative positions
                        differently.
                    </p>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Rotation Angle (RoPE)</label>
                        <input type="range" min="0" max="6.28" step="0.1" x-model.number="ropeAngle"
                            @input="updateRoPE()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500"
                            x-text="`${(ropeAngle * 180 / Math.PI).toFixed(1)}°`"></span>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <h3 class="text-sm font-medium text-gray-700 mb-2">Sinusoidal Addition</h3>
                            <svg id="sinusoidalViz" class="border rounded w-full" style="height: 200px;"></svg>
                        </div>
                        <div>
                            <h3 class="text-sm font-medium text-gray-700 mb-2">RoPE Rotation</h3>
                            <svg id="ropeViz" class="border rounded w-full" style="height: 200px;"></svg>
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-blue-50 rounded-lg">
                        <p class="text-sm text-blue-800">
                            <strong>Key insight:</strong> RoPE preserves relative position information through rotation,
                            while sinusoidal encoding adds absolute position that can be learned to extract relative
                            information.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Mathematical Formulas -->
            <div class="mt-8 bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-xl font-semibold mb-4">Mathematical Formulations</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-lg font-medium text-gray-800 mb-2">Sinusoidal Positional Encoding</h3>
                        <div class="text-sm">
                            $$PE_{(pos,2i)} = \sin\left(\frac{pos}{10000^{2i/d_{model}}}\right)$$
                            $$PE_{(pos,2i+1)} = \cos\left(\frac{pos}{10000^{2i/d_{model}}}\right)$$
                            <p class="mt-2 text-gray-600">Where $pos$ is position, $i$ is dimension index, $d_{model}$
                                is embedding dimension.</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-lg font-medium text-gray-800 mb-2">RoPE (Rotary Position Embedding)</h3>
                        <div class="text-sm">
                            $$f(x_m, m) = \begin{pmatrix} \cos(m\theta) & -\sin(m\theta) \\ \sin(m\theta) &
                            \cos(m\theta) \end{pmatrix} \begin{pmatrix} x_m^{(1)} \\ x_m^{(2)} \end{pmatrix}$$
                            <p class="mt-2 text-gray-600">Where $m$ is position, $\theta = 10000^{-2i/d}$, and rotation
                                is applied to query/key pairs.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            function positionalEncodingTool() {
                return {
                    // Parameters
                    seqLen: 32,
                    dModel: 64,
                    baseFreq: 10000,
                    posOffset: 3,
                    selectedPos: 16,
                    refPos: 10,
                    showDims: 16,
                    ropeAngle: 1.57, // π/2

                    // Charts
                    frequencyChart: null,
                    relativeChart: null,

                    init() {
                        this.updateAll();
                        setTimeout(() => {
                            if (window.MathJax) {
                                MathJax.typesetPromise();
                            }
                        }, 100);
                    },

                    // Sinusoidal PE calculation
                    calculatePE(pos, dim) {
                        const i = Math.floor(dim / 2);
                        const denominator = Math.pow(this.baseFreq, (2 * i) / this.dModel);
                        const angle = pos / denominator;

                        if (dim % 2 === 0) {
                            return Math.sin(angle); // Even dimensions use sine
                        } else {
                            return Math.cos(angle); // Odd dimensions use cosine
                        }
                    },

                    // Update all visualizations
                    updateAll() {
                        this.updateHeatmap();
                        this.updateFrequency();
                        this.updateRelative();
                        this.updateRoPE();
                    },

                    // 1. Update heatmap
                    updateHeatmap() {
                        const svg = document.getElementById('heatmap');
                        if (!svg) return;

                        svg.innerHTML = '';

                        const margin = { top: 40, right: 60, bottom: 60, left: 60 };
                        const width = svg.clientWidth - margin.left - margin.right;
                        const height = 400 - margin.top - margin.bottom;

                        const cellWidth = width / this.dModel;
                        const cellHeight = height / this.seqLen;

                        // Create main group
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
                        svg.appendChild(g);

                        // Color scale
                        const getColor = (value) => {
                            const intensity = Math.abs(value);
                            if (value > 0) {
                                return `rgb(${Math.round(255 * (1 - intensity))}, ${Math.round(255 * (1 - intensity))}, 255)`;
                            } else {
                                return `rgb(255, ${Math.round(255 * (1 - intensity))}, ${Math.round(255 * (1 - intensity))})`;
                            }
                        };

                        // Draw cells
                        for (let pos = 0; pos < this.seqLen; pos++) {
                            for (let dim = 0; dim < this.dModel; dim++) {
                                const value = this.calculatePE(pos, dim);
                                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                rect.setAttribute('x', dim * cellWidth);
                                rect.setAttribute('y', pos * cellHeight);
                                rect.setAttribute('width', cellWidth - 0.5);
                                rect.setAttribute('height', cellHeight - 0.5);
                                rect.setAttribute('fill', getColor(value));
                                rect.setAttribute('class', 'heatmap-cell');
                                rect.setAttribute('stroke', '#e5e7eb');
                                rect.setAttribute('stroke-width', '0.5');

                                // Add tooltip
                                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                                title.textContent = `pos=${pos}, dim=${dim}, value=${value.toFixed(3)}`;
                                rect.appendChild(title);

                                g.appendChild(rect);
                            }
                        }

                        // Add axes labels
                        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        xLabel.setAttribute('x', width / 2);
                        xLabel.setAttribute('y', height + 45);
                        xLabel.setAttribute('text-anchor', 'middle');
                        xLabel.setAttribute('class', 'text-sm fill-gray-600');
                        xLabel.textContent = 'Dimension Index';
                        g.appendChild(xLabel);

                        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        yLabel.setAttribute('x', -height / 2);
                        yLabel.setAttribute('y', -35);
                        yLabel.setAttribute('text-anchor', 'middle');
                        yLabel.setAttribute('transform', `rotate(-90, ${-height / 2}, -35)`);
                        yLabel.setAttribute('class', 'text-sm fill-gray-600');
                        yLabel.textContent = 'Position';
                        g.appendChild(yLabel);

                        // Add colorbar legend
                        const legendG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        legendG.setAttribute('transform', `translate(${width + 20}, 0)`);
                        g.appendChild(legendG);

                        const legendHeight = 100;
                        const legendWidth = 20;
                        for (let i = 0; i < legendHeight; i++) {
                            const value = (i / legendHeight) * 2 - 1; // -1 to 1
                            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            rect.setAttribute('x', 0);
                            rect.setAttribute('y', legendHeight - i);
                            rect.setAttribute('width', legendWidth);
                            rect.setAttribute('height', 1);
                            rect.setAttribute('fill', getColor(value));
                            legendG.appendChild(rect);
                        }

                        // Legend labels
                        [-1, 0, 1].forEach((val, i) => {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', legendWidth + 5);
                            text.setAttribute('y', legendHeight - (i * legendHeight / 2) + 4);
                            text.setAttribute('class', 'text-xs fill-gray-600');
                            text.textContent = val.toString();
                            legendG.appendChild(text);
                        });
                    },

                    // 2. Update frequency chart
                    updateFrequency() {
                        const ctx = document.getElementById('frequencyChart');
                        if (!ctx) return;

                        if (this.frequencyChart) {
                            this.frequencyChart.destroy();
                        }

                        const frequencies = [];
                        const sineValues = [];
                        const cosineValues = [];
                        const labels = [];

                        // Show both sine and cosine components
                        for (let dim = 0; dim < Math.min(this.dModel, 16); dim += 2) {
                            const i = Math.floor(dim / 2);
                            const freq = 1 / Math.pow(this.baseFreq, (2 * i) / this.dModel);
                            const sineValue = this.calculatePE(this.selectedPos, dim);
                            const cosineValue = this.calculatePE(this.selectedPos, dim + 1);

                            frequencies.push(freq);
                            sineValues.push(sineValue);
                            cosineValues.push(cosineValue);
                            labels.push(`${dim}/${dim + 1}`);
                        }

                        this.frequencyChart = new Chart(ctx.getContext('2d'), {
                            type: 'bar',
                            data: {
                                labels: labels,
                                datasets: [
                                    {
                                        label: 'Sine (even dims)',
                                        data: sineValues,
                                        backgroundColor: 'rgba(59, 130, 246, 0.6)',
                                        borderColor: 'rgba(59, 130, 246, 1)',
                                        borderWidth: 1
                                    },
                                    {
                                        label: 'Cosine (odd dims)',
                                        data: cosineValues,
                                        backgroundColor: 'rgba(239, 68, 68, 0.6)',
                                        borderColor: 'rgba(239, 68, 68, 1)',
                                        borderWidth: 1
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        min: -1,
                                        max: 1,
                                        title: {
                                            display: true,
                                            text: 'PE Value'
                                        }
                                    },
                                    x: {
                                        title: {
                                            display: true,
                                            text: 'Dimension Pairs'
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: true
                                    },
                                    tooltip: {
                                        callbacks: {
                                            afterLabel: (context) => {
                                                const dimPair = context.dataIndex * 2;
                                                const i = Math.floor(dimPair / 2);
                                                const freq = 1 / Math.pow(this.baseFreq, (2 * i) / this.dModel);
                                                return [`Frequency: ${freq.toExponential(2)}`, `Wavelength: ${(1 / freq).toFixed(1)} positions`];
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    },

                    // 3. Update relative position chart
                    updateRelative() {
                        const ctx = document.getElementById('relativeChart');
                        if (!ctx) return;

                        if (this.relativeChart) {
                            this.relativeChart.destroy();
                        }

                        const datasets = [];
                        const offsets = [];
                        for (let k = -10; k <= 10; k++) {
                            offsets.push(k);
                        }

                        // Show multiple dimensions with better distribution
                        const colors = [
                            '#3b82f6',  // blue
                            '#ef4444',  // red  
                            '#10b981',  // emerald
                            '#f59e0b',  // amber
                            '#8b5cf6',  // violet
                            '#ec4899',  // pink
                            '#06b6d4',  // cyan
                            '#84cc16'   // lime
                        ];

                        const dimsToShow = Math.min(this.showDims, 8);
                        const dimStep = Math.max(1, Math.floor(this.showDims / dimsToShow));

                        for (let i = 0; i < dimsToShow; i++) {
                            const dim = i * dimStep;
                            if (dim >= this.dModel) break;

                            const differences = offsets.map(k => {
                                const targetPos = this.refPos + k;
                                if (targetPos < 0 || targetPos >= this.seqLen) {
                                    return null; // Out of bounds
                                }
                                const refPE = this.calculatePE(this.refPos, dim);
                                const offsetPE = this.calculatePE(targetPos, dim);
                                return offsetPE - refPE;
                            });

                            datasets.push({
                                label: `Dim ${dim} (${dim % 2 === 0 ? 'sin' : 'cos'})`,
                                data: differences,
                                borderColor: colors[i % colors.length],
                                backgroundColor: colors[i % colors.length] + '20',
                                fill: false,
                                tension: 0.1,
                                pointRadius: 3,
                                pointHoverRadius: 5,
                                spanGaps: false // Don't connect null values
                            });
                        }

                        this.relativeChart = new Chart(ctx.getContext('2d'), {
                            type: 'line',
                            data: {
                                labels: offsets,
                                datasets: datasets
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    intersect: false,
                                    mode: 'index'
                                },
                                scales: {
                                    x: {
                                        title: {
                                            display: true,
                                            text: 'Position Offset (k)'
                                        },
                                        grid: {
                                            display: true
                                        }
                                    },
                                    y: {
                                        title: {
                                            display: true,
                                            text: 'PE(pos+k) - PE(pos)'
                                        },
                                        grid: {
                                            display: true
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: true,
                                        position: 'top'
                                    },
                                    tooltip: {
                                        mode: 'index',
                                        intersect: false,
                                        callbacks: {
                                            title: (context) => {
                                                const offset = context[0].label;
                                                const targetPos = this.refPos + parseInt(offset);
                                                return `Offset: ${offset}, Target pos: ${targetPos}`;
                                            },
                                            afterBody: () => {
                                                return `Reference position: ${this.refPos}`;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    },

                    // 4. Update RoPE visualization
                    updateRoPE() {
                        this.updateSinusoidalViz();
                        this.updateRoPEViz();
                    },

                    updateSinusoidalViz() {
                        const svg = document.getElementById('sinusoidalViz');
                        if (!svg) return;

                        svg.innerHTML = '';

                        const width = svg.clientWidth;
                        const height = 200;
                        const centerX = width / 2;
                        const centerY = height / 2;
                        const radius = Math.min(width, height) * 0.3;

                        // Draw coordinate system
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        svg.appendChild(g);

                        // Axes
                        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        xAxis.setAttribute('x1', centerX - radius * 1.2);
                        xAxis.setAttribute('x2', centerX + radius * 1.2);
                        xAxis.setAttribute('y1', centerY);
                        xAxis.setAttribute('y2', centerY);
                        xAxis.setAttribute('stroke', '#e5e7eb');
                        xAxis.setAttribute('stroke-width', '1');
                        g.appendChild(xAxis);

                        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        yAxis.setAttribute('x1', centerX);
                        yAxis.setAttribute('x2', centerX);
                        yAxis.setAttribute('y1', centerY - radius * 1.2);
                        yAxis.setAttribute('y2', centerY + radius * 1.2);
                        yAxis.setAttribute('stroke', '#e5e7eb');
                        yAxis.setAttribute('stroke-width', '1');
                        g.appendChild(yAxis);

                        // Unit circle
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', centerX);
                        circle.setAttribute('cy', centerY);
                        circle.setAttribute('r', radius);
                        circle.setAttribute('fill', 'none');
                        circle.setAttribute('stroke', '#d1d5db');
                        circle.setAttribute('stroke-width', '1');
                        g.appendChild(circle);

                        // Original vector (embedding)
                        const origX = centerX + radius * 0.7;
                        const origY = centerY - radius * 0.5;
                        const origLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        origLine.setAttribute('x1', centerX);
                        origLine.setAttribute('x2', origX);
                        origLine.setAttribute('y1', centerY);
                        origLine.setAttribute('y2', origY);
                        origLine.setAttribute('stroke', '#6b7280');
                        origLine.setAttribute('stroke-width', '2');
                        origLine.setAttribute('marker-end', 'url(#arrowhead)');
                        g.appendChild(origLine);

                        // Position encoding vector
                        const peX = centerX + radius * 0.5 * Math.cos(this.ropeAngle);
                        const peY = centerY - radius * 0.5 * Math.sin(this.ropeAngle);
                        const peLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        peLine.setAttribute('x1', centerX);
                        peLine.setAttribute('x2', peX);
                        peLine.setAttribute('y1', centerY);
                        peLine.setAttribute('y2', peY);
                        peLine.setAttribute('stroke', '#3b82f6');
                        peLine.setAttribute('stroke-width', '2');
                        peLine.setAttribute('marker-end', 'url(#arrowhead)');
                        g.appendChild(peLine);

                        // Sum vector (embedding + PE)
                        const sumX = origX + (peX - centerX);
                        const sumY = origY + (peY - centerY);
                        const sumLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        sumLine.setAttribute('x1', centerX);
                        sumLine.setAttribute('x2', sumX);
                        sumLine.setAttribute('y1', centerY);
                        sumLine.setAttribute('y2', sumY);
                        sumLine.setAttribute('stroke', '#10b981');
                        sumLine.setAttribute('stroke-width', '3');
                        sumLine.setAttribute('marker-end', 'url(#arrowhead)');
                        g.appendChild(sumLine);

                        // Add arrowhead marker
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                        marker.setAttribute('id', 'arrowhead');
                        marker.setAttribute('markerWidth', '10');
                        marker.setAttribute('markerHeight', '7');
                        marker.setAttribute('refX', '9');
                        marker.setAttribute('refY', '3.5');
                        marker.setAttribute('orient', 'auto');
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                        polygon.setAttribute('fill', 'currentColor');
                        marker.appendChild(polygon);
                        defs.appendChild(marker);
                        svg.appendChild(defs);

                        // Labels
                        const labels = [
                            { x: origX + 10, y: origY, text: 'Embedding', color: '#6b7280' },
                            { x: peX + 10, y: peY, text: 'PE', color: '#3b82f6' },
                            { x: sumX + 10, y: sumY, text: 'Sum', color: '#10b981' }
                        ];

                        labels.forEach(label => {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', label.x);
                            text.setAttribute('y', label.y);
                            text.setAttribute('class', 'text-xs');
                            text.setAttribute('fill', label.color);
                            text.textContent = label.text;
                            g.appendChild(text);
                        });
                    },

                    updateRoPEViz() {
                        const svg = document.getElementById('ropeViz');
                        if (!svg) return;

                        svg.innerHTML = '';

                        const width = svg.clientWidth;
                        const height = 200;
                        const centerX = width / 2;
                        const centerY = height / 2;
                        const radius = Math.min(width, height) * 0.3;

                        // Draw coordinate system
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        svg.appendChild(g);

                        // Axes
                        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        xAxis.setAttribute('x1', centerX - radius * 1.2);
                        xAxis.setAttribute('x2', centerX + radius * 1.2);
                        xAxis.setAttribute('y1', centerY);
                        xAxis.setAttribute('y2', centerY);
                        xAxis.setAttribute('stroke', '#e5e7eb');
                        xAxis.setAttribute('stroke-width', '1');
                        g.appendChild(xAxis);

                        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        yAxis.setAttribute('x1', centerX);
                        yAxis.setAttribute('x2', centerX);
                        yAxis.setAttribute('y1', centerY - radius * 1.2);
                        yAxis.setAttribute('y2', centerY + radius * 1.2);
                        yAxis.setAttribute('stroke', '#e5e7eb');
                        yAxis.setAttribute('stroke-width', '1');
                        g.appendChild(yAxis);

                        // Unit circle
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', centerX);
                        circle.setAttribute('cy', centerY);
                        circle.setAttribute('r', radius);
                        circle.setAttribute('fill', 'none');
                        circle.setAttribute('stroke', '#d1d5db');
                        circle.setAttribute('stroke-width', '1');
                        g.appendChild(circle);

                        // Original vector
                        const origAngle = Math.PI / 4; // 45 degrees
                        const origX = centerX + radius * 0.8 * Math.cos(origAngle);
                        const origY = centerY - radius * 0.8 * Math.sin(origAngle);
                        const origLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        origLine.setAttribute('x1', centerX);
                        origLine.setAttribute('x2', origX);
                        origLine.setAttribute('y1', centerY);
                        origLine.setAttribute('y2', origY);
                        origLine.setAttribute('stroke', '#6b7280');
                        origLine.setAttribute('stroke-width', '2');
                        origLine.setAttribute('stroke-dasharray', '4,2');
                        origLine.setAttribute('marker-end', 'url(#arrowhead2)');
                        g.appendChild(origLine);

                        // Rotated vector
                        const rotatedAngle = origAngle + this.ropeAngle;
                        const rotX = centerX + radius * 0.8 * Math.cos(rotatedAngle);
                        const rotY = centerY - radius * 0.8 * Math.sin(rotatedAngle);
                        const rotLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        rotLine.setAttribute('x1', centerX);
                        rotLine.setAttribute('x2', rotX);
                        rotLine.setAttribute('y1', centerY);
                        rotLine.setAttribute('y2', rotY);
                        rotLine.setAttribute('stroke', '#ef4444');
                        rotLine.setAttribute('stroke-width', '3');
                        rotLine.setAttribute('marker-end', 'url(#arrowhead2)');
                        rotLine.setAttribute('class', 'rope-vector');
                        g.appendChild(rotLine);

                        // Rotation arc
                        const arcRadius = radius * 0.4;
                        const startAngle = origAngle;
                        const endAngle = rotatedAngle;
                        const startX = centerX + arcRadius * Math.cos(startAngle);
                        const startY = centerY - arcRadius * Math.sin(startAngle);
                        const endX = centerX + arcRadius * Math.cos(endAngle);
                        const endY = centerY - arcRadius * Math.sin(endAngle);

                        const largeArcFlag = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
                        const sweepFlag = endAngle > startAngle ? 1 : 0;

                        const arc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        arc.setAttribute('d', `M ${startX} ${startY} A ${arcRadius} ${arcRadius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`);
                        arc.setAttribute('stroke', '#8b5cf6');
                        arc.setAttribute('stroke-width', '2');
                        arc.setAttribute('fill', 'none');
                        arc.setAttribute('marker-end', 'url(#arrowhead2)');
                        g.appendChild(arc);

                        // Add arrowhead marker
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                        marker.setAttribute('id', 'arrowhead2');
                        marker.setAttribute('markerWidth', '10');
                        marker.setAttribute('markerHeight', '7');
                        marker.setAttribute('refX', '9');
                        marker.setAttribute('refY', '3.5');
                        marker.setAttribute('orient', 'auto');
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                        polygon.setAttribute('fill', 'currentColor');
                        marker.appendChild(polygon);
                        defs.appendChild(marker);
                        svg.appendChild(defs);

                        // Labels
                        const labels = [
                            { x: origX + 10, y: origY, text: 'Original', color: '#6b7280' },
                            { x: rotX + 10, y: rotY, text: 'Rotated', color: '#ef4444' },
                            { x: centerX + 10, y: centerY - arcRadius - 10, text: `θ = ${(this.ropeAngle * 180 / Math.PI).toFixed(1)}°`, color: '#8b5cf6' }
                        ];

                        labels.forEach(label => {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', label.x);
                            text.setAttribute('y', label.y);
                            text.setAttribute('class', 'text-xs');
                            text.setAttribute('fill', label.color);
                            text.textContent = label.text;
                            g.appendChild(text);
                        });
                    }
                }
            }
        </script>
    </section>

    <section id="norm_strategy" class="py-12 bg-slate-50">

        <!-- Controls -->
        <div x-data="normalizationTool()" x-init="init()" class="container mx-auto px-4 py-8 max-w-7xl">
            <h1 class="text-4xl font-bold text-gray-900 mb-4">Normalization Strategies in Transformers</h1>
            <p class="text-gray-600 mb-8 max-w-4xl">
                Explore different normalization techniques used in modern transformers. Compare LayerNorm, RMSNorm,
                BatchNorm,
                and their variants to understand their mathematical differences, computational costs, and effects on
                training stability.
            </p>

            <!-- Normalization Type Selector -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-xl font-semibold mb-4">Normalization Methods</h2>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <template x-for="(norm, key) in normTypes" :key="key">
                        <div class="norm-card rounded-lg p-4 cursor-pointer border-2"
                            :class="activeNorm === key ? 'active' : 'border-gray-200 hover:border-blue-300'"
                            @click="setActiveNorm(key)">
                            <h3 class="font-medium text-gray-900" x-text="norm.name"></h3>
                            <p class="text-sm text-gray-600 mt-1" x-text="norm.description"></p>
                            <div class="mt-2 text-xs text-blue-600" x-text="norm.complexity"></div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Interactive Parameters -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-xl font-semibold mb-4">Parameters & Data</h2>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Batch Size</label>
                        <input type="range" min="4" max="32" x-model.number="batchSize" @input="generateData()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="batchSize"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Feature Dim</label>
                        <input type="range" min="8" max="128" step="8" x-model.number="featureDim"
                            @input="generateData()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="featureDim"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Data Shift</label>
                        <input type="range" min="-3" max="3" step="0.1" x-model.number="dataShift"
                            @input="generateData()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="dataShift.toFixed(1)"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Data Scale</label>
                        <input type="range" min="0.1" max="5" step="0.1" x-model.number="dataScale"
                            @input="generateData()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="dataScale.toFixed(1)"></span>
                    </div>
                </div>

                <!-- Learnable Parameters -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">γ (scale)</label>
                        <input type="range" min="0.1" max="3" step="0.1" x-model.number="gamma"
                            @input="updateNormalization()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="gamma.toFixed(1)"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">β (shift)</label>
                        <input type="range" min="-2" max="2" step="0.1" x-model.number="beta"
                            @input="updateNormalization()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="beta.toFixed(1)"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">ε (epsilon)</label>
                        <input type="range" min="1e-8" max="1e-3" step="1e-8" x-model.number="epsilon"
                            @input="updateNormalization()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="epsilon.toExponential(1)"></span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Momentum (BN)</label>
                        <input type="range" min="0.01" max="0.99" step="0.01" x-model.number="momentum"
                            @input="updateNormalization()"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-500" x-text="momentum.toFixed(2)"></span>
                    </div>
                </div>

                <div class="mt-4 flex gap-4">
                    <button @click="generateData()"
                        class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                        Generate New Data
                    </button>
                    <button @click="resetParameters()"
                        class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors">
                        Reset Parameters
                    </button>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" x-model="showGradients" @change="updateNormalization()" id="gradients">
                        <label for="gradients" class="text-sm text-gray-700">Show Gradient Effects</label>
                    </div>
                </div>
            </div>

            <!-- Main Visualizations -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Distribution Comparison -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Before vs After Normalization</h2>
                    <canvas id="distributionChart" class="w-full" style="height: 350px;"></canvas>
                    <div class="mt-4 grid grid-cols-2 gap-4 text-sm">
                        <div class="bg-red-50 p-3 rounded-lg">
                            <div class="font-medium text-red-800">Before Normalization</div>
                            <div class="text-red-600">
                                Mean: <span x-text="stats.original.mean.toFixed(3)"></span><br>
                                Std: <span x-text="stats.original.std.toFixed(3)"></span>
                            </div>
                        </div>
                        <div class="bg-green-50 p-3 rounded-lg">
                            <div class="font-medium text-green-800">After Normalization</div>
                            <div class="text-green-600">
                                Mean: <span x-text="stats.normalized.mean.toFixed(3)"></span><br>
                                Std: <span x-text="stats.normalized.std.toFixed(3)"></span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Feature-wise Statistics -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Feature-wise Statistics</h2>
                    <canvas id="featureChart" class="w-full" style="height: 350px;"></canvas>
                    <div class="mt-4 text-sm text-gray-600">
                        Shows mean and variance for each feature dimension before/after normalization.
                    </div>
                </div>

                <!-- Gradient Flow Analysis -->
                <div class="bg-white rounded-xl shadow-lg p-6" x-show="showGradients">
                    <h2 class="text-xl font-semibold mb-4">Gradient Flow Analysis</h2>
                    <canvas id="gradientChart" class="w-full" style="height: 350px;"></canvas>
                    <div class="mt-4 text-sm text-gray-600">
                        Simulated gradient magnitudes through the normalization layer. Lower variance indicates more
                        stable training.
                    </div>
                </div>

                <!-- Computational Cost Comparison -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Computational Cost Analysis</h2>
                    <div class="space-y-4">
                        <template x-for="(norm, key) in normTypes" :key="key">
                            <div class="border rounded-lg p-4"
                                :class="activeNorm === key ? 'border-blue-500 bg-blue-50' : 'border-gray-200'">
                                <div class="flex justify-between items-center mb-2">
                                    <h3 class="font-medium" x-text="norm.name"></h3>
                                    <span class="text-sm text-gray-600" x-text="norm.memoryUsage"></span>
                                </div>
                                <div class="grid grid-cols-3 gap-4 text-sm">
                                    <div>
                                        <div class="text-gray-600">FLOPs</div>
                                        <div class="font-mono" x-text="calculateFLOPs(key)"></div>
                                    </div>
                                    <div>
                                        <div class="text-gray-600">Parameters</div>
                                        <div class="font-mono" x-text="calculateParams(key)"></div>
                                    </div>
                                    <div>
                                        <div class="text-gray-600">Memory</div>
                                        <div class="font-mono" x-text="calculateMemory(key)"></div>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
            </div>

            <!-- Mathematical Formulations -->
            <div class="mt-8 bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-xl font-semibold mb-6">Mathematical Formulations</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Layer Normalization -->
                    <div class="border-l-4 border-blue-500 pl-6">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">Layer Normalization</h3>
                        <div class="text-sm space-y-2">
                            <div>$$\mu = \frac{1}{d}\sum_{i=1}^{d} x_i$$</div>
                            <div>$$\sigma^2 = \frac{1}{d}\sum_{i=1}^{d} (x_i - \mu)^2$$</div>
                            <div>$$\text{LN}(x) = \gamma \odot \frac{x - \mu}{\sqrt{\sigma^2 + \epsilon}} + \beta$$
                            </div>
                            <p class="mt-3 text-gray-600">Normalizes across features for each sample independently.</p>
                        </div>
                    </div>

                    <!-- RMS Normalization -->
                    <div class="border-l-4 border-green-500 pl-6">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">RMS Normalization</h3>
                        <div class="text-sm space-y-2">
                            <div>$$\text{RMS} = \sqrt{\frac{1}{d}\sum_{i=1}^{d} x_i^2}$$</div>
                            <div>$$\text{RMSNorm}(x) = \gamma \odot \frac{x}{\text{RMS} + \epsilon}$$</div>
                            <p class="mt-3 text-gray-600">Simpler than LayerNorm - no mean centering, only scaling by
                                RMS.</p>
                        </div>
                    </div>

                    <!-- Batch Normalization -->
                    <div class="border-l-4 border-red-500 pl-6">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">Batch Normalization</h3>
                        <div class="text-sm space-y-2">
                            <div>$$\mu_B = \frac{1}{m}\sum_{i=1}^{m} x_i$$</div>
                            <div>$$\sigma_B^2 = \frac{1}{m}\sum_{i=1}^{m} (x_i - \mu_B)^2$$</div>
                            <div>$$\text{BN}(x) = \gamma \odot \frac{x - \mu_B}{\sqrt{\sigma_B^2 + \epsilon}} + \beta$$
                            </div>
                            <p class="mt-3 text-gray-600">Normalizes across batch dimension. Uses running statistics
                                during inference.</p>
                        </div>
                    </div>

                    <!-- Group Normalization -->
                    <div class="border-l-4 border-purple-500 pl-6">
                        <h3 class="text-lg font-medium text-gray-800 mb-3">Group Normalization</h3>
                        <div class="text-sm space-y-2">
                            <div>$$\mu_G = \frac{1}{|G|}\sum_{i \in G} x_i$$</div>
                            <div>$$\sigma_G^2 = \frac{1}{|G|}\sum_{i \in G} (x_i - \mu_G)^2$$</div>
                            <div>$$\text{GN}(x) = \gamma \odot \frac{x - \mu_G}{\sqrt{\sigma_G^2 + \epsilon}} + \beta$$
                            </div>
                            <p class="mt-3 text-gray-600">Normalizes within groups of channels. Bridges LayerNorm and
                                BatchNorm.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Key Insights -->
            <div class="mt-8 bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl p-6">
                <h2 class="text-xl font-semibold mb-4">Key Insights & Trade-offs</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <div class="bg-white rounded-lg p-4">
                        <h3 class="font-medium text-blue-800 mb-2">Training Stability</h3>
                        <p class="text-sm text-gray-700">LayerNorm > RMSNorm > GroupNorm > BatchNorm for transformers.
                            LayerNorm provides most consistent gradients.</p>
                    </div>
                    <div class="bg-white rounded-lg p-4">
                        <h3 class="font-medium text-green-800 mb-2">Computational Efficiency</h3>
                        <p class="text-sm text-gray-700">RMSNorm is ~15% faster than LayerNorm. BatchNorm fastest but
                            problematic for sequences.</p>
                    </div>
                    <div class="bg-white rounded-lg p-4">
                        <h3 class="font-medium text-purple-800 mb-2">Memory Usage</h3>
                        <p class="text-sm text-gray-700">RMSNorm uses less memory (no mean storage). BatchNorm requires
                            running statistics.</p>
                    </div>
                    <div class="bg-white rounded-lg p-4">
                        <h3 class="font-medium text-red-800 mb-2">Batch Size Sensitivity</h3>
                        <p class="text-sm text-gray-700">BatchNorm sensitive to batch size. LayerNorm/RMSNorm work well
                            with any batch size.</p>
                    </div>
                    <div class="bg-white rounded-lg p-4">
                        <h3 class="font-medium text-orange-800 mb-2">Sequence Length</h3>
                        <p class="text-sm text-gray-700">LayerNorm/RMSNorm handle variable lengths naturally. BatchNorm
                            requires padding considerations.</p>
                    </div>
                    <div class="bg-white rounded-lg p-4">
                        <h3 class="font-medium text-teal-800 mb-2">Modern Preference</h3>
                        <p class="text-sm text-gray-700">RMSNorm increasingly popular in large models (LLaMA, PaLM) for
                            efficiency gains.</p>
                    </div>
                </div>
            </div>
        </div>

        <script>
            function normalizationTool() {
                return {
                    // Parameters
                    batchSize: 16,
                    featureDim: 64,
                    dataShift: 0.5,
                    dataScale: 2.0,
                    gamma: 1.0,
                    beta: 0.0,
                    epsilon: 1e-6,
                    momentum: 0.9,
                    showGradients: false,

                    // State
                    activeNorm: 'layernorm',
                    rawData: null,
                    normalizedData: null,
                    stats: {
                        original: { mean: 0, std: 1 },
                        normalized: { mean: 0, std: 1 }
                    },

                    // Charts
                    distributionChart: null,
                    featureChart: null,
                    gradientChart: null,

                    // Normalization methods
                    normTypes: {
                        layernorm: {
                            name: 'LayerNorm',
                            description: 'Normalize across features',
                            complexity: 'O(d) operations',
                            memoryUsage: '2d parameters'
                        },
                        rmsnorm: {
                            name: 'RMSNorm',
                            description: 'RMS-based normalization',
                            complexity: 'O(d) operations',
                            memoryUsage: 'd parameters'
                        },
                        batchnorm: {
                            name: 'BatchNorm',
                            description: 'Normalize across batch',
                            complexity: 'O(d) operations',
                            memoryUsage: '4d parameters'
                        },
                        groupnorm: {
                            name: 'GroupNorm',
                            description: 'Normalize within groups',
                            complexity: 'O(d) operations',
                            memoryUsage: '2d parameters'
                        }
                    },

                    init() {
                        this.generateData();
                        this.updateNormalization();
                        setTimeout(() => {
                            if (window.MathJax) {
                                MathJax.typesetPromise();
                            }
                        }, 100);
                    },

                    generateData() {
                        // Generate random data with specified shift and scale
                        this.rawData = [];
                        for (let b = 0; b < this.batchSize; b++) {
                            const sample = [];
                            for (let d = 0; d < this.featureDim; d++) {
                                // Add some correlation and structure to make normalization effects more visible
                                const base = this.gaussianRandom() * this.dataScale + this.dataShift;
                                const correlated = base + 0.3 * this.gaussianRandom() * (d / this.featureDim);
                                sample.push(correlated);
                            }
                            this.rawData.push(sample);
                        }
                        this.updateNormalization();
                    },

                    updateNormalization() {
                        if (!this.rawData) return;

                        this.normalizedData = this.applyNormalization(this.rawData, this.activeNorm);
                        this.calculateStats();
                        this.updateCharts();
                    },

                    applyNormalization(data, method) {
                        const normalized = data.map(sample => [...sample]);

                        switch (method) {
                            case 'layernorm':
                                return this.layerNorm(normalized);
                            case 'rmsnorm':
                                return this.rmsNorm(normalized);
                            case 'batchnorm':
                                return this.batchNorm(normalized);
                            case 'groupnorm':
                                return this.groupNorm(normalized, 8); // 8 groups
                            default:
                                return normalized;
                        }
                    },

                    layerNorm(data) {
                        return data.map(sample => {
                            const mean = sample.reduce((sum, x) => sum + x, 0) / sample.length;
                            const variance = sample.reduce((sum, x) => sum + (x - mean) ** 2, 0) / sample.length;
                            const std = Math.sqrt(variance + this.epsilon);

                            return sample.map(x => this.gamma * (x - mean) / std + this.beta);
                        });
                    },

                    rmsNorm(data) {
                        return data.map(sample => {
                            const rms = Math.sqrt(sample.reduce((sum, x) => sum + x ** 2, 0) / sample.length + this.epsilon);
                            return sample.map(x => this.gamma * x / rms);
                        });
                    },

                    batchNorm(data) {
                        const batchSize = data.length;
                        const featureDim = data[0].length;
                        const normalized = Array(batchSize).fill(null).map(() => Array(featureDim));

                        // Calculate batch statistics for each feature
                        for (let d = 0; d < featureDim; d++) {
                            const feature_values = data.map(sample => sample[d]);
                            const mean = feature_values.reduce((sum, x) => sum + x, 0) / batchSize;
                            const variance = feature_values.reduce((sum, x) => sum + (x - mean) ** 2, 0) / batchSize;
                            const std = Math.sqrt(variance + this.epsilon);

                            for (let b = 0; b < batchSize; b++) {
                                normalized[b][d] = this.gamma * (data[b][d] - mean) / std + this.beta;
                            }
                        }

                        return normalized;
                    },

                    groupNorm(data, numGroups) {
                        const groupSize = Math.floor(this.featureDim / numGroups);

                        return data.map(sample => {
                            const normalized = [...sample];

                            for (let g = 0; g < numGroups; g++) {
                                const start = g * groupSize;
                                const end = Math.min(start + groupSize, this.featureDim);
                                const group = sample.slice(start, end);

                                const mean = group.reduce((sum, x) => sum + x, 0) / group.length;
                                const variance = group.reduce((sum, x) => sum + (x - mean) ** 2, 0) / group.length;
                                const std = Math.sqrt(variance + this.epsilon);

                                for (let i = start; i < end; i++) {
                                    normalized[i] = this.gamma * (sample[i] - mean) / std + this.beta;
                                }
                            }

                            return normalized;
                        });
                    },

                    calculateStats() {
                        const originalFlat = this.rawData.flat();
                        const normalizedFlat = this.normalizedData.flat();

                        this.stats.original = {
                            mean: originalFlat.reduce((sum, x) => sum + x, 0) / originalFlat.length,
                            std: Math.sqrt(originalFlat.reduce((sum, x) => sum + (x - this.stats.original?.mean || 0) ** 2, 0) / originalFlat.length)
                        };

                        const normMean = normalizedFlat.reduce((sum, x) => sum + x, 0) / normalizedFlat.length;
                        this.stats.normalized = {
                            mean: normMean,
                            std: Math.sqrt(normalizedFlat.reduce((sum, x) => sum + (x - normMean) ** 2, 0) / normalizedFlat.length)
                        };
                    },

                    updateCharts() {
                        this.updateDistributionChart();
                        this.updateFeatureChart();
                        if (this.showGradients) {
                            this.updateGradientChart();
                        }
                    },

                    updateDistributionChart() {
                        const ctx = document.getElementById('distributionChart');
                        if (!ctx) return;

                        if (this.distributionChart) {
                            this.distributionChart.destroy();
                        }

                        // Create histogram data
                        const originalFlat = this.rawData.flat();
                        const normalizedFlat = this.normalizedData.flat();

                        const bins = 30;
                        const originalHist = this.createHistogram(originalFlat, bins);
                        const normalizedHist = this.createHistogram(normalizedFlat, bins);

                        this.distributionChart = new Chart(ctx.getContext('2d'), {
                            type: 'line',
                            data: {
                                labels: originalHist.bins,
                                datasets: [
                                    {
                                        label: 'Before Normalization',
                                        data: originalHist.counts,
                                        borderColor: '#ef4444',
                                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                        fill: true,
                                        tension: 0.4
                                    },
                                    {
                                        label: `After ${this.normTypes[this.activeNorm].name}`,
                                        data: normalizedHist.counts,
                                        borderColor: '#22c55e',
                                        backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                        fill: true,
                                        tension: 0.4
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: {
                                        title: {
                                            display: true,
                                            text: 'Value'
                                        }
                                    },
                                    y: {
                                        title: {
                                            display: true,
                                            text: 'Frequency'
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: true
                                    }
                                }
                            }
                        });
                    },

                    updateFeatureChart() {
                        const ctx = document.getElementById('featureChart');
                        if (!ctx) return;

                        if (this.featureChart) {
                            this.featureChart.destroy();
                        }

                        // Calculate feature-wise statistics
                        const featureMeans = [];
                        const featureStds = [];
                        const normalizedMeans = [];
                        const normalizedStds = [];

                        for (let d = 0; d < this.featureDim; d++) {
                            const originalFeature = this.rawData.map(sample => sample[d]);
                            const normalizedFeature = this.normalizedData.map(sample => sample[d]);

                            const origMean = originalFeature.reduce((sum, x) => sum + x, 0) / originalFeature.length;
                            const origStd = Math.sqrt(originalFeature.reduce((sum, x) => sum + (x - origMean) ** 2, 0) / originalFeature.length);

                            const normMean = normalizedFeature.reduce((sum, x) => sum + x, 0) / normalizedFeature.length;
                            const normStd = Math.sqrt(normalizedFeature.reduce((sum, x) => sum + (x - normMean) ** 2, 0) / normalizedFeature.length);

                            featureMeans.push(origMean);
                            featureStds.push(origStd);
                            normalizedMeans.push(normMean);
                            normalizedStds.push(normStd);
                        }

                        const labels = Array.from({ length: Math.min(this.featureDim, 32) }, (_, i) => `F${i}`);

                        this.featureChart = new Chart(ctx.getContext('2d'), {
                            type: 'line',
                            data: {
                                labels: labels,
                                datasets: [
                                    {
                                        label: 'Original Mean',
                                        data: featureMeans.slice(0, 32),
                                        borderColor: '#ef4444',
                                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                        yAxisID: 'y'
                                    },
                                    {
                                        label: 'Original Std',
                                        data: featureStds.slice(0, 32),
                                        borderColor: '#f97316',
                                        backgroundColor: 'rgba(249, 115, 22, 0.1)',
                                        yAxisID: 'y'
                                    },
                                    {
                                        label: 'Normalized Mean',
                                        data: normalizedMeans.slice(0, 32),
                                        borderColor: '#22c55e',
                                        backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                        yAxisID: 'y1'
                                    },
                                    {
                                        label: 'Normalized Std',
                                        data: normalizedStds.slice(0, 32),
                                        borderColor: '#3b82f6',
                                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                        yAxisID: 'y1'
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    intersect: false,
                                    mode: 'index'
                                },
                                scales: {
                                    x: {
                                        title: {
                                            display: true,
                                            text: 'Feature Index'
                                        }
                                    },
                                    y: {
                                        type: 'linear',
                                        display: true,
                                        position: 'left',
                                        title: {
                                            display: true,
                                            text: 'Original Scale'
                                        }
                                    },
                                    y1: {
                                        type: 'linear',
                                        display: true,
                                        position: 'right',
                                        title: {
                                            display: true,
                                            text: 'Normalized Scale'
                                        },
                                        grid: {
                                            drawOnChartArea: false
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: true
                                    }
                                }
                            }
                        });
                    },

                    updateGradientChart() {
                        const ctx = document.getElementById('gradientChart');
                        if (!ctx) return;

                        if (this.gradientChart) {
                            this.gradientChart.destroy();
                        }

                        // Simulate gradient magnitudes through normalization
                        const layers = ['Input', 'Pre-Norm', 'Post-Norm', 'Output'];
                        const gradientMagnitudes = {
                            layernorm: [1.2, 0.8, 1.0, 0.9],
                            rmsnorm: [1.2, 0.9, 1.0, 0.95],
                            batchnorm: [1.2, 1.5, 0.7, 1.1],
                            groupnorm: [1.2, 1.0, 0.9, 0.95]
                        };

                        const gradientVariance = {
                            layernorm: [0.3, 0.1, 0.15, 0.12],
                            rmsnorm: [0.3, 0.12, 0.16, 0.14],
                            batchnorm: [0.3, 0.4, 0.25, 0.35],
                            groupnorm: [0.3, 0.2, 0.18, 0.16]
                        };

                        this.gradientChart = new Chart(ctx.getContext('2d'), {
                            type: 'bar',
                            data: {
                                labels: layers,
                                datasets: [
                                    {
                                        label: 'Gradient Magnitude',
                                        data: gradientMagnitudes[this.activeNorm],
                                        backgroundColor: 'rgba(59, 130, 246, 0.6)',
                                        borderColor: 'rgba(59, 130, 246, 1)',
                                        borderWidth: 1,
                                        yAxisID: 'y'
                                    },
                                    {
                                        label: 'Gradient Variance',
                                        data: gradientVariance[this.activeNorm],
                                        backgroundColor: 'rgba(239, 68, 68, 0.6)',
                                        borderColor: 'rgba(239, 68, 68, 1)',
                                        borderWidth: 1,
                                        yAxisID: 'y1'
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        type: 'linear',
                                        display: true,
                                        position: 'left',
                                        title: {
                                            display: true,
                                            text: 'Gradient Magnitude'
                                        }
                                    },
                                    y1: {
                                        type: 'linear',
                                        display: true,
                                        position: 'right',
                                        title: {
                                            display: true,
                                            text: 'Gradient Variance'
                                        },
                                        grid: {
                                            drawOnChartArea: false
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: true
                                    }
                                }
                            }
                        });
                    },

                    createHistogram(data, bins) {
                        const min = Math.min(...data);
                        const max = Math.max(...data);
                        const binWidth = (max - min) / bins;

                        const binCenters = [];
                        const counts = [];

                        for (let i = 0; i < bins; i++) {
                            const binStart = min + i * binWidth;
                            const binEnd = binStart + binWidth;
                            const binCenter = (binStart + binEnd) / 2;

                            const count = data.filter(x => x >= binStart && x < binEnd).length;

                            binCenters.push(binCenter.toFixed(2));
                            counts.push(count);
                        }

                        return { bins: binCenters, counts };
                    },

                    setActiveNorm(normType) {
                        this.activeNorm = normType;
                        this.updateNormalization();
                    },

                    resetParameters() {
                        this.gamma = 1.0;
                        this.beta = 0.0;
                        this.epsilon = 1e-6;
                        this.momentum = 0.9;
                        this.updateNormalization();
                    },

                    calculateFLOPs(normType) {
                        const d = this.featureDim;
                        const n = this.batchSize;

                        switch (normType) {
                            case 'layernorm':
                                return `${(4 * d).toLocaleString()}`; // mean, var, norm, scale+shift
                            case 'rmsnorm':
                                return `${(3 * d).toLocaleString()}`; // rms, norm, scale
                            case 'batchnorm':
                                return `${(4 * d).toLocaleString()}`; // batch mean, var, norm, scale+shift
                            case 'groupnorm':
                                return `${(4 * d).toLocaleString()}`; // group mean, var, norm, scale+shift
                            default:
                                return '0';
                        }
                    },

                    calculateParams(normType) {
                        const d = this.featureDim;

                        switch (normType) {
                            case 'layernorm':
                                return `${(2 * d).toLocaleString()}`; // γ, β
                            case 'rmsnorm':
                                return `${d.toLocaleString()}`; // γ only
                            case 'batchnorm':
                                return `${(4 * d).toLocaleString()}`; // γ, β, running_mean, running_var
                            case 'groupnorm':
                                return `${(2 * d).toLocaleString()}`; // γ, β
                            default:
                                return '0';
                        }
                    },

                    calculateMemory(normType) {
                        const d = this.featureDim;
                        const n = this.batchSize;

                        switch (normType) {
                            case 'layernorm':
                                return `${((2 * d + n * d) * 4 / 1024).toFixed(1)}KB`; // params + activations
                            case 'rmsnorm':
                                return `${((d + n * d) * 4 / 1024).toFixed(1)}KB`; // params + activations
                            case 'batchnorm':
                                return `${((4 * d + n * d) * 4 / 1024).toFixed(1)}KB`; // params + activations
                            case 'groupnorm':
                                return `${((2 * d + n * d) * 4 / 1024).toFixed(1)}KB`; // params + activations
                            default:
                                return '0KB';
                        }
                    },

                    gaussianRandom() {
                        let u = 0, v = 0;
                        while (u === 0) u = Math.random();
                        while (v === 0) v = Math.random();
                        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                    }
                }
            }
        </script>
        </div>
        </div>
    </section>
    <!-- Encoder/Decoder -->
    <section id="encoderdecoder" class="py-12">
        <div class="max-w-7xl mx-auto px-6">
            <h2 class="text-3xl font-bold tracking-tight text-slate-900">Encoder / Decoder & Masks</h2>
            <div class="grid lg:grid-cols-2 gap-6 mt-6">
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Autoregressive Decoder (Causal)</h3>
                    <p class="mt-3 text-sm text-slate-700">Decoder uses <span class="font-semibold">self-attention with
                            causal mask</span> + cross-attention to encoder outputs (for seq2seq tasks).</p>
                    <svg viewBox="0 0 760 300" class="w-full h-auto mt-3">
                        <!-- decoder block -->
                        <g>
                            <rect x="20" y="20" width="720" height="260" rx="16" fill="#fff" stroke="#e2e8f0" />
                            <text x="380" y="45" text-anchor="middle" font-size="13" fill="#475569">Transformer Decoder
                                Block</text>
                        </g>
                        <!-- sublayers -->
                        <g>
                            <rect x="50" y="70" width="260" height="52" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="180" y="98" text-anchor="middle" font-size="12" fill="#334155">Masked
                                Self-Attention</text>

                            <rect x="330" y="70" width="400" height="52" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="530" y="98" text-anchor="middle" font-size="12" fill="#334155">Residual +
                                LayerNorm</text>

                            <rect x="50" y="140" width="260" height="52" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="180" y="168" text-anchor="middle" font-size="12" fill="#334155">Cross-Attention
                                (Q=decoder, K/V=encoder)</text>

                            <rect x="330" y="140" width="400" height="52" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="530" y="168" text-anchor="middle" font-size="12" fill="#334155">Residual +
                                LayerNorm</text>

                            <rect x="50" y="210" width="260" height="52" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="180" y="238" text-anchor="middle" font-size="12" fill="#334155">Feed-Forward
                                (MLP)</text>

                            <rect x="330" y="210" width="400" height="52" rx="10" fill="#f8fafc" stroke="#e5e7eb" />
                            <text x="530" y="238" text-anchor="middle" font-size="12" fill="#334155">Residual +
                                LayerNorm</text>
                        </g>
                    </svg>
                    <p class="hint mt-2">Teacher forcing during training uses shifted targets; at inference we use KV
                        cache for speed.</p>
                </article>

                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Heads, Dimensions, & Costs</h3>
                    <ul class="mt-3 text-sm leading-7 text-slate-700 list-disc ml-5">
                        <li><span class="font-semibold">Shapes</span>: \(X\in \mathbb{R}^{T\times d}\), heads \(h\),
                            \(d_k=d/h\). Per head \(Q,K,V\in\mathbb{R}^{T\times d_k}\).</li>
                        <li><span class="font-semibold">Complexity</span>: attention is \(O(T^2 d)\) time, \(O(T^2)\)
                            memory (per head). Use local/sparse/linear attention for long $T$.</li>
                        <li><span class="font-semibold">Normalization</span>: pre-LN stabilizes deep stacks; residuals
                            help gradient flow.</li>
                        <li><span class="font-semibold">Decoder-only</span>: GPT-style causal transformer for
                            generation.</li>
                        <li><span class="font-semibold">Encoder-only</span>: BERT-style bidirectional modeling for
                            understanding.</li>
                    </ul>
                </article>
            </div>
        </div>
    </section>

    <!-- MHA & FFN details -->
    <section id="mha-ffn" class="py-12  bg-slate-50">
        <div class="max-w-7xl mx-auto px-6">
            <h2 class="text-3xl font-bold tracking-tight text-slate-900">Multi-Head Attention & Feed-Forward</h2>
            <div class="mt-6 grid lg:grid-cols-3 gap-6">
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Multi-Head Attention</h3>
                    <p class="mt-2 text-sm text-slate-700">
                        Each head learns different relations (syntax, coreference, long-range dependencies).
                        Concatenation plus a linear map mixes heads.
                    </p>
                    <p>
                        \[
                        \begin{aligned}
                        & \mathrm{MHA}(X) = \\
                        & \mathrm{Concat}\big(\mathrm{Attn}(XW_Q^{(i)},XW_K^{(i)},XW_V^{(i)})\big)_{i=1}^h W_O.
                        \end{aligned}
                        \]
                    </p>

                    </p>
                </article>
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Position-wise FFN</h3>
                    <p class="mt-2 text-sm text-slate-700">
                        Applied per token; hidden size often 4×-8× the model dim (e.g., \(d_{ff}\approx 4d\)).
                        SwiGLU/GELU are popular.
                    </p>
                    <p class="whitespace-nowrap overflow-x-auto mt-2">$$\mathrm{FFN}(x)=\phi(xW_1+b_1)W_2+b_2.$$
                    </p>
                </article>
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Efficiency Tricks</h3>
                    <ul class="mt-2 text-sm text-slate-700 list-disc ml-5">
                        <li><span class="font-semibold">FlashAttention</span>: IO-aware exact attention; reduces memory
                            traffic.</li>
                        <li><span class="font-semibold">KV Cache</span>: reuse $K,V$ for past tokens in decoding.</li>
                        <li><span class="font-semibold">RoPE / Relative Bias</span>: better long-context behavior.</li>
                        <li><span class="font-semibold">Grouped-Query / Multi-Query</span>: share keys/values across
                            heads to save memory.</li>
                    </ul>
                </article>
            </div>
        </div>
    </section>

    <!-- Best Practices -->
    <section id="tips" class="py-12">
        <div class="max-w-7xl mx-auto px-6">
            <h2 class="text-3xl font-bold tracking-tight text-slate-900">Training Tips & Debugging</h2>
            <div class="mt-6 grid lg:grid-cols-3 gap-6">
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Optimization</h3>
                    <ul class="mt-2 text-sm leading-7 text-slate-700 list-disc ml-5">
                        <li>Use AdamW with weight decay (e.g., 0.01).</li>
                        <li>Warmup + cosine decay; clip gradients (e.g., 1.0).</li>
                        <li>Scale batch size with LR; use mixed precision (AMP).</li>
                    </ul>
                </article>
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Regularization</h3>
                    <ul class="mt-2 text-sm leading-7 text-slate-700 list-disc ml-5">
                        <li>Dropout in MHA/FFN; token dropout for robust inputs.</li>
                        <li>Label smoothing for classification/language modeling.</li>
                        <li>Data augmentation (masking, span corruption, etc.).</li>
                    </ul>
                </article>
                <article class="bg-white border border-slate-200 rounded-2xl p-6 shadow">
                    <h3 class="text-xl font-semibold">Troubleshooting</h3>
                    <ul class="mt-2 text-sm leading-7 text-slate-700 list-disc ml-5">
                        <li><span class="font-semibold">Divergence</span>: reduce LR, increase warmup, check norm
                            scaling.</li>
                        <li><span class="font-semibold">Collapse</span>: monitor attention entropies; add dropout or
                            temperature.</li>
                        <li><span class="font-semibold">Long contexts</span>: try RoPE, ALiBi, or local/sparse
                            attention.</li>
                        <li>Inspect loss curves, grad norms, and activation stats.</li>
                    </ul>
                </article>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="py-10 bg-slate-900 text-slate-200">
        <div class="max-w-7xl mx-auto px-6">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <p class="text-sm">© <span id="year"></span> Transformers Cheatsheet — Single-file</p>
                <div class="text-xs text-slate-400">Tailwind • Alpine.js • Chart.js • MathJax • SVG/Canvas</div>
            </div>
        </div>
    </footer>

    <!-- Logic -->
    <script>
        // Safe DPR scaler that won't grow on each call
        function ensureCanvasSize(cvs) {
            if (!cvs) return;
            const dpr = window.devicePixelRatio || 1;

            // Establish a stable CSS baseline ONCE (from attributes or defaults)
            if (!cvs._baseCSS) {
                const attrW = parseFloat(cvs.getAttribute('width')) || 360; // treat as CSS px
                const attrH = parseFloat(cvs.getAttribute('height')) || 180; // treat as CSS px
                cvs._baseCSS = { w: attrW, h: attrH };

                // Make sure CSS size is explicit so clientWidth is reliable
                if (!cvs.style.width) cvs.style.width = attrW + 'px';
                if (!cvs.style.height) cvs.style.height = attrH + 'px';
            }

            // Prefer real layout size; if 0 (hidden/not laid out), use our baseline CSS size
            const cssW = cvs.clientWidth || cvs._baseCSS.w;
            const cssH = cvs.clientHeight || cvs._baseCSS.h;

            const needW = Math.round(cssW * dpr);
            const needH = Math.round(cssH * dpr);

            if (cvs.width !== needW) cvs.width = needW;
            if (cvs.height !== needH) cvs.height = needH;
        }


        // Footer year
        document.addEventListener('DOMContentLoaded', () => {
            const y = document.getElementById('year'); if (y) y.textContent = new Date().getFullYear();
        });

        // Toy training curves (loss, cosine lr, warmup)
        (function trainSpark() {
            const ctx = document.getElementById('sparkTrain'); if (!ctx || !Chart) return;
            const N = 160, warm = 10;
            const loss = Array.from({ length: N }, (_, i) => 2.2 * Math.exp(-(i) / 40) + 0.05 * Math.sin(i / 6) + 0.06 * Math.max(0, Math.random() - 0.7));
            const lr = Array.from({ length: N }, (_, i) => {
                if (i < warm) return (i + 1) / (warm) * 0.6;
                const t = (i - warm) / (N - warm);
                return 0.6 * 0.5 * (1 + Math.cos(Math.PI * t));
            });
            new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: loss.map((_, i) => i + 1), datasets: [
                        { label: 'loss', data: loss, yAxisID: 'y', tension: 0.25 },
                        { label: 'lr (warmup+cosine)', data: lr, yAxisID: 'y1', tension: 0.25 }
                    ]
                },
                options: { responsive: true, scales: { y: { type: 'linear', position: 'left' }, y1: { type: 'linear', position: 'right', grid: { drawOnChartArea: false } } }, plugins: { legend: { display: true } } }
            });
        })();

        // Positional encodings chart
        (function posines() {
            const el = document.getElementById('posines'); if (!el || !Chart) return;
            const T = 80, d = 8;
            const pe = (pos, i) => {
                const denom = Math.pow(10000, (2 * i) / d);
                return i % 2 === 0 ? Math.sin(pos / denom) : Math.cos(pos / denom);
            };
            const xs = Array.from({ length: T }, (_, i) => i);
            const datasets = [];
            for (let i = 0; i < 6; i++) {
                const ys = xs.map(x => pe(x, i));
                datasets.push({ label: `dim ${i}`, data: ys, tension: 0.25 });
            }
            new Chart(el.getContext('2d'), { type: 'line', data: { labels: xs, datasets }, options: { responsive: true, plugins: { legend: { display: true } }, elements: { point: { radius: 0 } }, scales: { x: { display: true }, y: { display: true } } } });
        })();

        // Temperature softmax chart
        (function tempSoftmax() {
            const el = document.getElementById('tempSoftmax'); if (!el || !Chart) return;
            const z = [0.2, 1.0, 2.0, 0.5, -0.2];
            function softmax_t(logits, t) {
                const s = logits.map(v => v / t);
                const m = Math.max(...s);
                const ex = s.map(v => Math.exp(v - m));
                const S = ex.reduce((a, b) => a + b, 0);
                return ex.map(v => v / S);
            }
            const temps = [0.5, 1.0, 2.0];
            const xs = z.map((_, i) => `logit${i}`);
            const datasets = temps.map((t, i) => ({ label: `τ=${t}`, data: softmax_t(z, t), type: 'line', tension: 0.25 }));
            new Chart(el.getContext('2d'), { type: 'bar', data: { labels: xs, datasets }, options: { responsive: true, scales: { y: { min: 0, max: 1 } } } });
        })();

        function attentionDemo() {
            return {
                // state
                T: 6, dk: 3, qpos: 0, temp: Math.SQRT2, causal: true,
                Q: null, K: null, V: null, A: null, y: null,
                heat: null,     // manual heatmap drawer
                bar: null,      // Chart.js instance
                _inited: false, // guard against double Alpine inits

                init() {
                    if (this._inited) return;   // idempotent
                    this._inited = true;

                    // create drawing targets first
                    this.heat = this.makeHeat('attHeat');
                    this.bar = this.makeBar('valueBar');

                    // then data
                    this.randomize();
                    this.recompute();

                    setTimeout(() => { window.MathJax?.typesetPromise?.(); }, 50);
                },

                randomize() {
                    this.Q = this.randn(this.T, this.dk);
                    this.K = this.randn(this.T, this.dk);
                    this.V = this.randn(this.T, this.dk);
                    this.qpos = Math.min(this.qpos, this.T - 1);
                    // NOTE: init() calls recompute() after charts exist
                    this.recompute();
                },

                recompute() {
                    // logits = QK^T / temp (+ causal mask)
                    const logits = this.zeros(this.T, this.T);
                    for (let i = 0; i < this.T; i++) {
                        for (let j = 0; j < this.T; j++) {
                            let dot = 0;
                            for (let k = 0; k < this.dk; k++) dot += this.Q[i][k] * this.K[j][k];
                            logits[i][j] = dot / this.temp;
                            if (this.causal && j > i) logits[i][j] = -1e9;
                        }
                    }
                    // softmax rows
                    const A = this.zeros(this.T, this.T);
                    for (let i = 0; i < this.T; i++) {
                        const row = logits[i], m = Math.max(...row);
                        const ex = row.map(v => Math.exp(v - m));
                        const S = ex.reduce((a, b) => a + b, 0);
                        for (let j = 0; j < this.T; j++) A[i][j] = ex[j] / S;
                    }
                    this.A = A;

                    // y_t = Σ_j α_{t,j} v_j  (for current query row i)
                    const i = this.qpos;
                    const y = new Array(this.dk).fill(0);
                    for (let j = 0; j < this.T; j++) {
                        for (let k = 0; k < this.dk; k++) {
                            y[k] += A[i][j] * this.V[j][k];
                        }
                    }
                    this.y = y;

                    this.drawHeat();
                    this.drawBar();
                },

                // ------- drawing
                makeHeat(id) {
                    const el = document.getElementById(id);
                    const ctx = el?.getContext('2d');
                    if (!ctx) return null;
                    return { canvas: el, ctx, cell: 24, pad: 6 };
                },

                drawHeat() {
                    if (!this.heat) return;
                    const { canvas, ctx, cell, pad } = this.heat;
                    const W = this.T * cell + 2 * pad, H = this.T * cell + 2 * pad;
                    canvas.width = W; canvas.height = H;
                    ctx.clearRect(0, 0, W, H);
                    for (let i = 0; i < this.T; i++) {
                        for (let j = 0; j < this.T; j++) {
                            const a = this.A[i][j];
                            const g = Math.round(255 - 180 * a);
                            ctx.fillStyle = `rgb(${g},${g + 10},255)`;
                            ctx.fillRect(pad + j * cell, pad + i * cell, cell - 1, cell - 1);
                        }
                    }
                    ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2;
                    ctx.strokeRect(pad - 1, pad + this.qpos * cell - 1, this.T * cell + 2, cell + 2);
                },
                makeBar(id) {
                    const el = document.getElementById(id); if (!el) return null;
                    const ctx = el.getContext('2d'); if (!ctx) return null;
                    return { canvas: el, ctx };
                },

                drawBar() {
                    if (!this.bar || !this.y) return;
                    const { canvas, ctx } = this.bar;
                    ensureCanvasSize(canvas);
                    const dpr = window.devicePixelRatio || 1;
                    const W = canvas.width, H = canvas.height;

                    // Clear
                    ctx.clearRect(0, 0, W, H);

                    // Padding and geometry
                    const padL = 36 * dpr, padR = 10 * dpr, padT = 14 * dpr, padB = 28 * dpr;
                    const chartW = W - padL - padR;
                    const chartH = H - padT - padB;

                    // Data range (include zero)
                    const vals = Array.from(this.y);
                    const minV = Math.min(0, ...vals);
                    const maxV = Math.max(0, ...vals);
                    const span = (maxV - minV) || 1;

                    // Scales
                    const xN = vals.length;
                    const gap = Math.max(2 * dpr, chartW * 0.04 / Math.max(1, xN - 1));
                    const barW = Math.max(6 * dpr, (chartW - gap * (xN - 1)) / Math.max(1, xN));
                    const xAt = i => padL + i * (barW + gap);
                    const yAt = v => padT + (1 - (v - minV) / span) * chartH;   // bigger v → higher

                    // Zero line
                    const y0 = yAt(0);
                    ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1 * dpr;
                    ctx.beginPath(); ctx.moveTo(padL, y0); ctx.lineTo(W - padR, y0); ctx.stroke();

                    // Bars (sign-aware coloring)
                    for (let i = 0; i < xN; i++) {
                        const v = vals[i] ?? 0;
                        const x = xAt(i);
                        const y = Math.min(yAt(v), yAt(0));
                        const h = Math.abs(yAt(v) - y0);
                        ctx.fillStyle = v >= 0 ? 'rgba(99,102,241,0.65)' : 'rgba(239,68,68,0.65)'; // indigo vs red
                        ctx.fillRect(x, y, barW, Math.max(1 * dpr, h));
                    }

                    // X labels (dim 0..)
                    ctx.save();
                    ctx.fillStyle = '#475569';
                    ctx.font = `${11 * dpr}px system-ui, -apple-system, Segoe UI, Roboto`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                    for (let i = 0; i < xN; i++) {
                        const x = xAt(i) + barW / 2;
                        ctx.fillText(`dim ${i}`, x, H - padB + 6 * dpr);
                    }
                    ctx.restore();

                    // Title (small)
                    ctx.save();
                    ctx.fillStyle = '#334155';
                    ctx.font = `${12 * dpr}px system-ui, -apple-system, Segoe UI, Roboto`;
                    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
                    ctx.fillText('y components', padL, padT - 4 * dpr);
                    ctx.restore();
                },


                // ------- utils
                randn(m, n) { const A = []; for (let i = 0; i < m; i++) { const r = []; for (let j = 0; j < n; j++) r.push(this.gauss()); A.push(r); } return A; },
                zeros(m, n) { const A = []; for (let i = 0; i < m; i++) { A.push(new Array(n).fill(0)); } return A; },
                gauss() { let u = 0, v = 0; while (!u) u = Math.random(); while (!v) v = Math.random(); return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v); }
            }
        }

        // Ensure MathJax typesets after DOM/plots
        (function ensureMathJax() {
            function typesetNow() {
                if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
            }
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                setTimeout(typesetNow, 60);
            } else {
                document.addEventListener('DOMContentLoaded', () => setTimeout(typesetNow, 60));
            }
            setTimeout(typesetNow, 450);
        })();
    </script>
</body>

</html>